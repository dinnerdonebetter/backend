// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: meal_plans.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveMealPlan = `-- name: ArchiveMealPlan :exec
UPDATE meal_plans SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_household = $1 AND id = $2
`

type ArchiveMealPlanParams struct {
	BelongsToHousehold string
	ID                 string
}

func (q *Queries) ArchiveMealPlan(ctx context.Context, arg *ArchiveMealPlanParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveMealPlan, arg.BelongsToHousehold, arg.ID)
	return err
}

const CreateMealPlan = `-- name: CreateMealPlan :exec
INSERT INTO meal_plans (id,notes,status,voting_deadline,starts_at,ends_at,belongs_to_household) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type CreateMealPlanParams struct {
	ID                 string
	Notes              string
	Status             MealPlanStatus
	VotingDeadline     int64
	StartsAt           int64
	EndsAt             int64
	BelongsToHousehold string
}

func (q *Queries) CreateMealPlan(ctx context.Context, arg *CreateMealPlanParams) error {
	_, err := q.db.ExecContext(ctx, CreateMealPlan,
		arg.ID,
		arg.Notes,
		arg.Status,
		arg.VotingDeadline,
		arg.StartsAt,
		arg.EndsAt,
		arg.BelongsToHousehold,
	)
	return err
}

const FinalizeMealPlan = `-- name: FinalizeMealPlan :exec
UPDATE meal_plans SET status = $1 WHERE archived_on IS NULL AND id = $2
`

type FinalizeMealPlanParams struct {
	Status MealPlanStatus
	ID     string
}

func (q *Queries) FinalizeMealPlan(ctx context.Context, arg *FinalizeMealPlanParams) error {
	_, err := q.db.ExecContext(ctx, FinalizeMealPlan, arg.Status, arg.ID)
	return err
}

const GetExpiredAndUnresolvedMealPlanIDs = `-- name: GetExpiredAndUnresolvedMealPlanIDs :many
SELECT
	meal_plans.id,
	meal_plans.notes,
	meal_plans.status,
	meal_plans.voting_deadline,
	meal_plans.starts_at,
	meal_plans.ends_at,
	meal_plans.created_on,
	meal_plans.last_updated_on,
	meal_plans.archived_on,
	meal_plans.belongs_to_household
FROM meal_plans
WHERE meal_plans.archived_on IS NULL
	AND meal_plans.status = 'awaiting_votes'
	AND to_timestamp(voting_deadline)::date < now()
GROUP BY meal_plans.id
ORDER BY meal_plans.id
`

func (q *Queries) GetExpiredAndUnresolvedMealPlanIDs(ctx context.Context) ([]*MealPlans, error) {
	rows, err := q.db.QueryContext(ctx, GetExpiredAndUnresolvedMealPlanIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*MealPlans
	for rows.Next() {
		var i MealPlans
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Status,
			&i.VotingDeadline,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.BelongsToHousehold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMealPlan = `-- name: GetMealPlan :many
SELECT
    meal_plans.id,
    meal_plans.notes,
    meal_plans.status,
    meal_plans.voting_deadline,
    meal_plans.starts_at,
    meal_plans.ends_at,
    meal_plans.created_on,
    meal_plans.last_updated_on,
    meal_plans.archived_on,
    meal_plans.belongs_to_household,
    meal_plan_options.id,
    meal_plan_options.day,
    meal_plan_options.meal_name,
    meal_plan_options.chosen,
    meal_plan_options.tiebroken,
    meal_plan_options.meal_id,
    meal_plan_options.notes,
    meal_plan_options.created_on,
    meal_plan_options.last_updated_on,
    meal_plan_options.archived_on,
    meal_plan_options.belongs_to_meal_plan,
    meal_plan_option_votes.id,
    meal_plan_option_votes.rank,
    meal_plan_option_votes.abstain,
    meal_plan_option_votes.notes,
    meal_plan_option_votes.by_user,
    meal_plan_option_votes.created_on,
    meal_plan_option_votes.last_updated_on,
    meal_plan_option_votes.archived_on,
    meal_plan_option_votes.belongs_to_meal_plan_option,
    meals.id,
    meals.name,
    meals.description,
    meals.created_on,
    meals.last_updated_on,
    meals.archived_on,
    meals.created_by_user
FROM meal_plans
         FULL OUTER JOIN meal_plan_options ON meal_plan_options.belongs_to_meal_plan=meal_plans.id
         FULL OUTER JOIN meal_plan_option_votes ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id
         FULL OUTER JOIN meals ON meal_plan_options.meal_id=meals.id
WHERE meal_plans.archived_on IS NULL
  AND meal_plans.id = $1
  AND meal_plans.belongs_to_household = $2
ORDER BY meal_plan_options.id
`

type GetMealPlanParams struct {
	ID                 string
	BelongsToHousehold string
}

type GetMealPlanRow struct {
	ID                      sql.NullString
	Notes                   sql.NullString
	Status                  NullMealPlanStatus
	VotingDeadline          sql.NullInt64
	StartsAt                sql.NullInt64
	EndsAt                  sql.NullInt64
	CreatedOn               sql.NullInt64
	LastUpdatedOn           sql.NullInt64
	ArchivedOn              sql.NullInt64
	BelongsToHousehold      sql.NullString
	ID_2                    sql.NullString
	Day                     sql.NullInt32
	MealName                NullMealName
	Chosen                  sql.NullBool
	Tiebroken               sql.NullBool
	MealID                  sql.NullString
	Notes_2                 sql.NullString
	CreatedOn_2             sql.NullInt64
	LastUpdatedOn_2         sql.NullInt64
	ArchivedOn_2            sql.NullInt64
	BelongsToMealPlan       sql.NullString
	ID_3                    sql.NullString
	Rank                    sql.NullInt32
	Abstain                 sql.NullBool
	Notes_3                 sql.NullString
	ByUser                  sql.NullString
	CreatedOn_3             sql.NullInt64
	LastUpdatedOn_3         sql.NullInt64
	ArchivedOn_3            sql.NullInt64
	BelongsToMealPlanOption sql.NullString
	ID_4                    sql.NullString
	Name                    sql.NullString
	Description             sql.NullString
	CreatedOn_4             sql.NullInt64
	LastUpdatedOn_4         sql.NullInt64
	ArchivedOn_4            sql.NullInt64
	CreatedByUser           sql.NullString
}

func (q *Queries) GetMealPlan(ctx context.Context, arg *GetMealPlanParams) ([]*GetMealPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, GetMealPlan, arg.ID, arg.BelongsToHousehold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMealPlanRow
	for rows.Next() {
		var i GetMealPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Status,
			&i.VotingDeadline,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.BelongsToHousehold,
			&i.ID_2,
			&i.Day,
			&i.MealName,
			&i.Chosen,
			&i.Tiebroken,
			&i.MealID,
			&i.Notes_2,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToMealPlan,
			&i.ID_3,
			&i.Rank,
			&i.Abstain,
			&i.Notes_3,
			&i.ByUser,
			&i.CreatedOn_3,
			&i.LastUpdatedOn_3,
			&i.ArchivedOn_3,
			&i.BelongsToMealPlanOption,
			&i.ID_4,
			&i.Name,
			&i.Description,
			&i.CreatedOn_4,
			&i.LastUpdatedOn_4,
			&i.ArchivedOn_4,
			&i.CreatedByUser,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetMealPlanPastVotingDeadline = `-- name: GetMealPlanPastVotingDeadline :many
SELECT
    meal_plans.id,
    meal_plans.notes,
    meal_plans.status,
    meal_plans.voting_deadline,
    meal_plans.starts_at,
    meal_plans.ends_at,
    meal_plans.created_on,
    meal_plans.last_updated_on,
    meal_plans.archived_on,
    meal_plans.belongs_to_household,
    meal_plan_options.id,
    meal_plan_options.day,
    meal_plan_options.meal_name,
    meal_plan_options.chosen,
    meal_plan_options.tiebroken,
    meal_plan_options.meal_id,
    meal_plan_options.notes,
    meal_plan_options.created_on,
    meal_plan_options.last_updated_on,
    meal_plan_options.archived_on,
    meal_plan_options.belongs_to_meal_plan,
    meal_plan_option_votes.id,
    meal_plan_option_votes.rank,
    meal_plan_option_votes.abstain,
    meal_plan_option_votes.notes,
    meal_plan_option_votes.by_user,
    meal_plan_option_votes.created_on,
    meal_plan_option_votes.last_updated_on,
    meal_plan_option_votes.archived_on,
    meal_plan_option_votes.belongs_to_meal_plan_option,
    meals.id,
    meals.name,
    meals.description,
    meals.created_on,
    meals.last_updated_on,
    meals.archived_on,
    meals.created_by_user
FROM meal_plans
 FULL OUTER JOIN meal_plan_options ON meal_plan_options.belongs_to_meal_plan=meal_plans.id
 FULL OUTER JOIN meal_plan_option_votes ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id
 FULL OUTER JOIN meals ON meal_plan_options.meal_id=meals.id
WHERE meal_plans.archived_on IS NULL
  AND meal_plans.id = $1
  AND meal_plans.belongs_to_household = $2
  AND meal_plans.status = 'awaiting_votes'
  AND extract(epoch from NOW()) > meal_plans.voting_deadline
ORDER BY meal_plan_options.id
`

type GetMealPlanPastVotingDeadlineParams struct {
	ID                 string
	BelongsToHousehold string
}

type GetMealPlanPastVotingDeadlineRow struct {
	ID                      sql.NullString
	Notes                   sql.NullString
	Status                  NullMealPlanStatus
	VotingDeadline          sql.NullInt64
	StartsAt                sql.NullInt64
	EndsAt                  sql.NullInt64
	CreatedOn               sql.NullInt64
	LastUpdatedOn           sql.NullInt64
	ArchivedOn              sql.NullInt64
	BelongsToHousehold      sql.NullString
	ID_2                    sql.NullString
	Day                     sql.NullInt32
	MealName                NullMealName
	Chosen                  sql.NullBool
	Tiebroken               sql.NullBool
	MealID                  sql.NullString
	Notes_2                 sql.NullString
	CreatedOn_2             sql.NullInt64
	LastUpdatedOn_2         sql.NullInt64
	ArchivedOn_2            sql.NullInt64
	BelongsToMealPlan       sql.NullString
	ID_3                    sql.NullString
	Rank                    sql.NullInt32
	Abstain                 sql.NullBool
	Notes_3                 sql.NullString
	ByUser                  sql.NullString
	CreatedOn_3             sql.NullInt64
	LastUpdatedOn_3         sql.NullInt64
	ArchivedOn_3            sql.NullInt64
	BelongsToMealPlanOption sql.NullString
	ID_4                    sql.NullString
	Name                    sql.NullString
	Description             sql.NullString
	CreatedOn_4             sql.NullInt64
	LastUpdatedOn_4         sql.NullInt64
	ArchivedOn_4            sql.NullInt64
	CreatedByUser           sql.NullString
}

func (q *Queries) GetMealPlanPastVotingDeadline(ctx context.Context, arg *GetMealPlanPastVotingDeadlineParams) ([]*GetMealPlanPastVotingDeadlineRow, error) {
	rows, err := q.db.QueryContext(ctx, GetMealPlanPastVotingDeadline, arg.ID, arg.BelongsToHousehold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMealPlanPastVotingDeadlineRow
	for rows.Next() {
		var i GetMealPlanPastVotingDeadlineRow
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Status,
			&i.VotingDeadline,
			&i.StartsAt,
			&i.EndsAt,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.BelongsToHousehold,
			&i.ID_2,
			&i.Day,
			&i.MealName,
			&i.Chosen,
			&i.Tiebroken,
			&i.MealID,
			&i.Notes_2,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToMealPlan,
			&i.ID_3,
			&i.Rank,
			&i.Abstain,
			&i.Notes_3,
			&i.ByUser,
			&i.CreatedOn_3,
			&i.LastUpdatedOn_3,
			&i.ArchivedOn_3,
			&i.BelongsToMealPlanOption,
			&i.ID_4,
			&i.Name,
			&i.Description,
			&i.CreatedOn_4,
			&i.LastUpdatedOn_4,
			&i.ArchivedOn_4,
			&i.CreatedByUser,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTotalMealPlansCount = `-- name: GetTotalMealPlansCount :one
SELECT COUNT(meal_plans.id) FROM meal_plans WHERE meal_plans.archived_on IS NULL
`

func (q *Queries) GetTotalMealPlansCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalMealPlansCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const MealPlanExists = `-- name: MealPlanExists :one
SELECT EXISTS ( SELECT meal_plans.id FROM meal_plans WHERE meal_plans.archived_on IS NULL AND meal_plans.id = $1 )
`

func (q *Queries) MealPlanExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, MealPlanExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const UpdateMealPlan = `-- name: UpdateMealPlan :exec
UPDATE meal_plans SET notes = $1, status = $2, voting_deadline = $3, starts_at = $4, ends_at = $5, last_updated_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_household = $6 AND id = $7
`

type UpdateMealPlanParams struct {
	Notes              string
	Status             MealPlanStatus
	VotingDeadline     int64
	StartsAt           int64
	EndsAt             int64
	BelongsToHousehold string
	ID                 string
}

func (q *Queries) UpdateMealPlan(ctx context.Context, arg *UpdateMealPlanParams) error {
	_, err := q.db.ExecContext(ctx, UpdateMealPlan,
		arg.Notes,
		arg.Status,
		arg.VotingDeadline,
		arg.StartsAt,
		arg.EndsAt,
		arg.BelongsToHousehold,
		arg.ID,
	)
	return err
}
