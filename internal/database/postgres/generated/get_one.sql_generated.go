// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_one.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getHouseholdInstrumentOwnership = `-- name: GetHouseholdInstrumentOwnership :one

SELECT
	household_instrument_ownerships.id,
	household_instrument_ownerships.notes,
	household_instrument_ownerships.quantity,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	household_instrument_ownerships.belongs_to_household,
	household_instrument_ownerships.created_at,
	household_instrument_ownerships.last_updated_at,
	household_instrument_ownerships.archived_at
FROM household_instrument_ownerships
INNER JOIN valid_instruments ON household_instrument_ownerships.valid_instrument_id = valid_instruments.id
WHERE household_instrument_ownerships.archived_at IS NULL
	AND household_instrument_ownerships.id = $1
	AND household_instrument_ownerships.belongs_to_household = $2
`

type GetHouseholdInstrumentOwnershipParams struct {
	ID                 string
	BelongsToHousehold string
}

type GetHouseholdInstrumentOwnershipRow struct {
	CreatedAt                      time.Time
	CreatedAt_2                    time.Time
	ArchivedAt_2                   sql.NullTime
	LastUpdatedAt_2                sql.NullTime
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	Name                           string
	IconPath                       string
	Slug                           string
	Description                    string
	PluralName                     string
	ID                             string
	BelongsToHousehold             string
	ID_2                           string
	Notes                          string
	Quantity                       int32
	UsableForStorage               bool
	DisplayInSummaryLists          bool
	IncludeInGeneratedInstructions bool
}

func (q *Queries) GetHouseholdInstrumentOwnership(ctx context.Context, db DBTX, arg *GetHouseholdInstrumentOwnershipParams) (*GetHouseholdInstrumentOwnershipRow, error) {
	row := db.QueryRowContext(ctx, getHouseholdInstrumentOwnership, arg.ID, arg.BelongsToHousehold)
	var i GetHouseholdInstrumentOwnershipRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.Quantity,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const getMeal = `-- name: GetMeal :one

SELECT
	meals.id,
	meals.name,
	meals.description,
	meals.min_estimated_portions,
    meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
	meals.created_at,
	meals.last_updated_at,
	meals.archived_at,
	meals.created_by_user,
	meal_components.recipe_id,
	meal_components.recipe_scale,
	meal_components.meal_component_type
FROM meals
	FULL OUTER JOIN meal_components ON meal_components.meal_id=meals.id
WHERE meals.archived_at IS NULL
	AND meal_components.archived_at IS NULL
	AND meals.id = $1
`

type GetMealRow struct {
	CreatedAt            sql.NullTime
	ArchivedAt           sql.NullTime
	LastUpdatedAt        sql.NullTime
	MinEstimatedPortions sql.NullString
	MaxEstimatedPortions sql.NullString
	ID                   sql.NullString
	Description          sql.NullString
	Name                 sql.NullString
	CreatedByUser        sql.NullString
	RecipeID             sql.NullString
	RecipeScale          sql.NullString
	MealComponentType    NullComponentType
	EligibleForMealPlans sql.NullBool
}

func (q *Queries) GetMeal(ctx context.Context, db DBTX, id string) (*GetMealRow, error) {
	row := db.QueryRowContext(ctx, getMeal, id)
	var i GetMealRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.RecipeID,
		&i.RecipeScale,
		&i.MealComponentType,
	)
	return &i, err
}

const getMealPlan = `-- name: GetMealPlan :one

SELECT
	meal_plans.id,
	meal_plans.notes,
	meal_plans.status,
	meal_plans.voting_deadline,
	meal_plans.grocery_list_initialized,
	meal_plans.tasks_created,
	meal_plans.election_method,
	meal_plans.created_at,
	meal_plans.last_updated_at,
	meal_plans.archived_at,
	meal_plans.belongs_to_household,
	meal_plans.created_by_user
FROM meal_plans
WHERE meal_plans.archived_at IS NULL
	AND meal_plans.id = $1
	AND meal_plans.belongs_to_household = $2
`

type GetMealPlanParams struct {
	ID                 string
	BelongsToHousehold string
}

type GetMealPlanRow struct {
	VotingDeadline         time.Time
	CreatedAt              time.Time
	LastUpdatedAt          sql.NullTime
	ArchivedAt             sql.NullTime
	ID                     string
	Notes                  string
	Status                 MealPlanStatus
	ElectionMethod         ValidElectionMethod
	BelongsToHousehold     string
	CreatedByUser          string
	GroceryListInitialized bool
	TasksCreated           bool
}

func (q *Queries) GetMealPlan(ctx context.Context, db DBTX, arg *GetMealPlanParams) (*GetMealPlanRow, error) {
	row := db.QueryRowContext(ctx, getMealPlan, arg.ID, arg.BelongsToHousehold)
	var i GetMealPlanRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.Status,
		&i.VotingDeadline,
		&i.GroceryListInitialized,
		&i.TasksCreated,
		&i.ElectionMethod,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToHousehold,
		&i.CreatedByUser,
	)
	return &i, err
}

const getMealPlanEvent = `-- name: GetMealPlanEvent :one

SELECT
	meal_plan_events.id,
	meal_plan_events.notes,
	meal_plan_events.starts_at,
	meal_plan_events.ends_at,
	meal_plan_events.meal_name,
	meal_plan_events.belongs_to_meal_plan,
	meal_plan_events.created_at,
	meal_plan_events.last_updated_at,
	meal_plan_events.archived_at
FROM meal_plan_events
WHERE meal_plan_events.archived_at IS NULL
	AND meal_plan_events.id = $1
	AND meal_plan_events.belongs_to_meal_plan = $2
`

type GetMealPlanEventParams struct {
	ID                string
	BelongsToMealPlan string
}

func (q *Queries) GetMealPlanEvent(ctx context.Context, db DBTX, arg *GetMealPlanEventParams) (*MealPlanEvents, error) {
	row := db.QueryRowContext(ctx, getMealPlanEvent, arg.ID, arg.BelongsToMealPlan)
	var i MealPlanEvents
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.StartsAt,
		&i.EndsAt,
		&i.MealName,
		&i.BelongsToMealPlan,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getMealPlanGroceryListItem = `-- name: GetMealPlanGroceryListItem :one

SELECT
	meal_plan_grocery_list_items.id,
	meal_plan_grocery_list_items.belongs_to_meal_plan,
	meal_plan_grocery_list_items.valid_ingredient,
	meal_plan_grocery_list_items.valid_measurement_unit,
	meal_plan_grocery_list_items.minimum_quantity_needed,
	meal_plan_grocery_list_items.maximum_quantity_needed,
	meal_plan_grocery_list_items.quantity_purchased,
	meal_plan_grocery_list_items.purchased_measurement_unit,
	meal_plan_grocery_list_items.purchased_upc,
	meal_plan_grocery_list_items.purchase_price,
	meal_plan_grocery_list_items.status_explanation,
	meal_plan_grocery_list_items.status,
	meal_plan_grocery_list_items.created_at,
	meal_plan_grocery_list_items.last_updated_at,
	meal_plan_grocery_list_items.archived_at
FROM meal_plan_grocery_list_items
	FULL OUTER JOIN meal_plans ON meal_plan_grocery_list_items.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_grocery_list_items.archived_at IS NULL
  AND meal_plan_grocery_list_items.id = $2
  AND meal_plan_grocery_list_items.belongs_to_meal_plan = $1
`

type GetMealPlanGroceryListItemParams struct {
	BelongsToMealPlan string
	ID                string
}

type GetMealPlanGroceryListItemRow struct {
	CreatedAt                sql.NullTime
	ArchivedAt               sql.NullTime
	LastUpdatedAt            sql.NullTime
	QuantityPurchased        sql.NullString
	MinimumQuantityNeeded    sql.NullString
	MaximumQuantityNeeded    sql.NullString
	ID                       sql.NullString
	PurchasedMeasurementUnit sql.NullString
	PurchasedUpc             sql.NullString
	PurchasePrice            sql.NullString
	StatusExplanation        sql.NullString
	Status                   NullGroceryListItemStatus
	ValidMeasurementUnit     sql.NullString
	ValidIngredient          sql.NullString
	BelongsToMealPlan        sql.NullString
}

func (q *Queries) GetMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *GetMealPlanGroceryListItemParams) (*GetMealPlanGroceryListItemRow, error) {
	row := db.QueryRowContext(ctx, getMealPlanGroceryListItem, arg.BelongsToMealPlan, arg.ID)
	var i GetMealPlanGroceryListItemRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToMealPlan,
		&i.ValidIngredient,
		&i.ValidMeasurementUnit,
		&i.MinimumQuantityNeeded,
		&i.MaximumQuantityNeeded,
		&i.QuantityPurchased,
		&i.PurchasedMeasurementUnit,
		&i.PurchasedUpc,
		&i.PurchasePrice,
		&i.StatusExplanation,
		&i.Status,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getMealPlanOption = `-- name: GetMealPlanOption :one

SELECT
	meal_plan_options.id,
	meal_plan_options.assigned_cook,
	meal_plan_options.assigned_dishwasher,
	meal_plan_options.chosen,
	meal_plan_options.tiebroken,
    meal_plan_options.meal_scale,
	meal_plan_options.meal_id,
	meal_plan_options.notes,
	meal_plan_options.created_at,
	meal_plan_options.last_updated_at,
	meal_plan_options.archived_at,
	meal_plan_options.belongs_to_meal_plan_event,
	meals.id,
	meals.name,
	meals.description,
	meals.min_estimated_portions,
	meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
	meals.created_at,
	meals.last_updated_at,
	meals.archived_at,
	meals.created_by_user
FROM meal_plan_options
	JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event = meal_plan_events.id
	JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan = meal_plans.id
	JOIN meals ON meal_plan_options.meal_id = meals.id
WHERE meal_plan_options.archived_at IS NULL
	AND meal_plan_options.belongs_to_meal_plan_event = $2
	AND meal_plan_options.id = $3
	AND meal_plan_events.id = $2
	AND meal_plan_events.belongs_to_meal_plan = $1
	AND meal_plans.archived_at IS NULL
	AND meal_plans.id = $1
`

type GetMealPlanOptionParams struct {
	BelongsToMealPlan      string
	ID                     string
	BelongsToMealPlanEvent sql.NullString
}

type GetMealPlanOptionRow struct {
	CreatedAt              time.Time
	CreatedAt_2            time.Time
	ArchivedAt_2           sql.NullTime
	LastUpdatedAt_2        sql.NullTime
	ArchivedAt             sql.NullTime
	LastUpdatedAt          sql.NullTime
	MealScale              string
	MinEstimatedPortions   string
	MealID                 string
	ID                     string
	CreatedByUser          string
	Notes                  string
	ID_2                   string
	Name                   string
	Description            string
	MaxEstimatedPortions   sql.NullString
	BelongsToMealPlanEvent sql.NullString
	AssignedDishwasher     sql.NullString
	AssignedCook           sql.NullString
	EligibleForMealPlans   bool
	Chosen                 bool
	Tiebroken              bool
}

func (q *Queries) GetMealPlanOption(ctx context.Context, db DBTX, arg *GetMealPlanOptionParams) (*GetMealPlanOptionRow, error) {
	row := db.QueryRowContext(ctx, getMealPlanOption, arg.BelongsToMealPlan, arg.BelongsToMealPlanEvent, arg.ID)
	var i GetMealPlanOptionRow
	err := row.Scan(
		&i.ID,
		&i.AssignedCook,
		&i.AssignedDishwasher,
		&i.Chosen,
		&i.Tiebroken,
		&i.MealScale,
		&i.MealID,
		&i.Notes,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanEvent,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedByUser,
	)
	return &i, err
}

const getMealPlanOptionVote = `-- name: GetMealPlanOptionVote :one


SELECT
	meal_plan_option_votes.id,
	meal_plan_option_votes.rank,
	meal_plan_option_votes.abstain,
	meal_plan_option_votes.notes,
	meal_plan_option_votes.by_user,
	meal_plan_option_votes.created_at,
	meal_plan_option_votes.last_updated_at,
	meal_plan_option_votes.archived_at,
	meal_plan_option_votes.belongs_to_meal_plan_option
FROM meal_plan_option_votes
	JOIN meal_plan_options ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id
	JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event=meal_plan_events.id
	JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_option_votes.archived_at IS NULL
	AND meal_plan_option_votes.belongs_to_meal_plan_option = $1
	AND meal_plan_option_votes.id = $2
	AND meal_plan_options.archived_at IS NULL
	AND meal_plan_options.belongs_to_meal_plan_event = $3
	AND meal_plan_events.archived_at IS NULL
	AND meal_plan_events.belongs_to_meal_plan = $4
	AND meal_plan_options.id = $1
	AND meal_plans.archived_at IS NULL
	AND meal_plans.id = $4
`

type GetMealPlanOptionVoteParams struct {
	BelongsToMealPlanOption string
	ID                      string
	BelongsToMealPlan       string
	BelongsToMealPlanEvent  sql.NullString
}

func (q *Queries) GetMealPlanOptionVote(ctx context.Context, db DBTX, arg *GetMealPlanOptionVoteParams) (*MealPlanOptionVotes, error) {
	row := db.QueryRowContext(ctx, getMealPlanOptionVote,
		arg.BelongsToMealPlanOption,
		arg.ID,
		arg.BelongsToMealPlanEvent,
		arg.BelongsToMealPlan,
	)
	var i MealPlanOptionVotes
	err := row.Scan(
		&i.ID,
		&i.Rank,
		&i.Abstain,
		&i.Notes,
		&i.ByUser,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanOption,
	)
	return &i, err
}

const getMealPlanTask = `-- name: GetMealPlanTask :one

SELECT
	meal_plan_tasks.id,
	meal_plan_options.id,
	meal_plan_options.assigned_cook,
	meal_plan_options.assigned_dishwasher,
	meal_plan_options.chosen,
	meal_plan_options.tiebroken,
    meal_plan_options.meal_scale,
	meal_plan_options.meal_id,
	meal_plan_options.notes,
	meal_plan_options.created_at,
	meal_plan_options.last_updated_at,
	meal_plan_options.archived_at,
	meal_plan_options.belongs_to_meal_plan_event,
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_task_steps.id,
	recipe_prep_task_steps.belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step,
	meal_plan_tasks.created_at,
	meal_plan_tasks.last_updated_at,
	meal_plan_tasks.completed_at,
	meal_plan_tasks.status,
	meal_plan_tasks.creation_explanation,
	meal_plan_tasks.status_explanation,
	meal_plan_tasks.assigned_to_user
FROM meal_plan_tasks
	FULL OUTER JOIN meal_plan_options ON meal_plan_tasks.belongs_to_meal_plan_option=meal_plan_options.id
	FULL OUTER JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event=meal_plan_events.id
	FULL OUTER JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan=meal_plans.id
	FULL OUTER JOIN meals ON meal_plan_options.meal_id=meals.id
	JOIN recipe_prep_tasks ON meal_plan_tasks.belongs_to_recipe_prep_task=recipe_prep_tasks.id
	JOIN recipe_prep_task_steps ON recipe_prep_task_steps.belongs_to_recipe_prep_task=recipe_prep_tasks.id
	JOIN recipe_steps ON recipe_prep_task_steps.belongs_to_recipe_step=recipe_steps.id
WHERE meal_plan_options.archived_at IS NULL
	AND meal_plan_events.archived_at IS NULL
	AND meal_plans.archived_at IS NULL
	AND meals.archived_at IS NULL
	AND recipe_steps.archived_at IS NULL
	AND meal_plan_tasks.id = $1
`

type GetMealPlanTaskRow struct {
	CreatedAt_2                            time.Time
	ArchivedAt_2                           sql.NullTime
	LastUpdatedAt                          sql.NullTime
	CompletedAt                            sql.NullTime
	LastUpdatedAt_3                        sql.NullTime
	CreatedAt_3                            sql.NullTime
	LastUpdatedAt_2                        sql.NullTime
	CreatedAt                              sql.NullTime
	ArchivedAt                             sql.NullTime
	BelongsToRecipeStep                    string
	ID_4                                   string
	BelongsToRecipePrepTask                string
	BelongsToRecipe                        string
	ID_3                                   string
	Name                                   string
	Description                            string
	Notes_2                                string
	ExplicitStorageInstructions            string
	MinimumStorageTemperatureInCelsius     sql.NullString
	ID_2                                   sql.NullString
	BelongsToMealPlanEvent                 sql.NullString
	CreationExplanation                    sql.NullString
	AssignedDishwasher                     sql.NullString
	ID                                     sql.NullString
	MaximumStorageTemperatureInCelsius     sql.NullString
	MealScale                              sql.NullString
	StatusExplanation                      sql.NullString
	MealID                                 sql.NullString
	AssignedCook                           sql.NullString
	Status                                 NullPrepStepStatus
	Notes                                  sql.NullString
	AssignedToUser                         sql.NullString
	StorageType                            NullStorageContainerType
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds int32
	Chosen                                 sql.NullBool
	Tiebroken                              sql.NullBool
	Optional                               bool
	SatisfiesRecipeStep                    bool
}

func (q *Queries) GetMealPlanTask(ctx context.Context, db DBTX, id string) (*GetMealPlanTaskRow, error) {
	row := db.QueryRowContext(ctx, getMealPlanTask, id)
	var i GetMealPlanTaskRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.AssignedCook,
		&i.AssignedDishwasher,
		&i.Chosen,
		&i.Tiebroken,
		&i.MealScale,
		&i.MealID,
		&i.Notes,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanEvent,
		&i.ID_3,
		&i.Name,
		&i.Description,
		&i.Notes_2,
		&i.Optional,
		&i.ExplicitStorageInstructions,
		&i.MinimumTimeBufferBeforeRecipeInSeconds,
		&i.MaximumTimeBufferBeforeRecipeInSeconds,
		&i.StorageType,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.BelongsToRecipe,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.ID_4,
		&i.BelongsToRecipeStep,
		&i.BelongsToRecipePrepTask,
		&i.SatisfiesRecipeStep,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.CompletedAt,
		&i.Status,
		&i.CreationExplanation,
		&i.StatusExplanation,
		&i.AssignedToUser,
	)
	return &i, err
}

const getPasswordResetToken = `-- name: GetPasswordResetToken :one

SELECT
	password_reset_tokens.id,
	password_reset_tokens.token,
	password_reset_tokens.expires_at,
	password_reset_tokens.created_at,
	password_reset_tokens.last_updated_at,
	password_reset_tokens.redeemed_at,
	password_reset_tokens.belongs_to_user
FROM password_reset_tokens
WHERE password_reset_tokens.redeemed_at IS NULL
	AND NOW() < password_reset_tokens.expires_at
	AND password_reset_tokens.token = $1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, db DBTX, token string) (*PasswordResetTokens, error) {
	row := db.QueryRowContext(ctx, getPasswordResetToken, token)
	var i PasswordResetTokens
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.RedeemedAt,
		&i.BelongsToUser,
	)
	return &i, err
}

const getRecipeMedia = `-- name: GetRecipeMedia :one

SELECT
	recipe_media.id,
	recipe_media.belongs_to_recipe,
	recipe_media.belongs_to_recipe_step,
	recipe_media.mime_type,
	recipe_media.internal_path,
	recipe_media.external_path,
	recipe_media.index,
	recipe_media.created_at,
	recipe_media.last_updated_at,
	recipe_media.archived_at
FROM recipe_media
WHERE recipe_media.archived_at IS NULL
	AND recipe_media.id = $1
`

type GetRecipeMediaRow struct {
	CreatedAt           time.Time
	LastUpdatedAt       sql.NullTime
	ArchivedAt          sql.NullTime
	ID                  string
	MimeType            string
	InternalPath        string
	ExternalPath        string
	BelongsToRecipe     sql.NullString
	BelongsToRecipeStep sql.NullString
	Index               int32
}

func (q *Queries) GetRecipeMedia(ctx context.Context, db DBTX, id string) (*GetRecipeMediaRow, error) {
	row := db.QueryRowContext(ctx, getRecipeMedia, id)
	var i GetRecipeMediaRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToRecipe,
		&i.BelongsToRecipeStep,
		&i.MimeType,
		&i.InternalPath,
		&i.ExternalPath,
		&i.Index,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRecipePrepTask = `-- name: GetRecipePrepTask :one

SELECT
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_task_steps.id,
	recipe_prep_task_steps.belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step
FROM recipe_prep_tasks
	 FULL OUTER JOIN recipe_prep_task_steps ON recipe_prep_tasks.id=recipe_prep_task_steps.belongs_to_recipe_prep_task
WHERE recipe_prep_tasks.archived_at IS NULL
	AND recipe_prep_tasks.id = $1
	AND recipe_prep_tasks.archived_at IS NULL
`

type GetRecipePrepTaskRow struct {
	CreatedAt                              sql.NullTime
	ArchivedAt                             sql.NullTime
	LastUpdatedAt                          sql.NullTime
	StorageType                            NullStorageContainerType
	Description                            sql.NullString
	ExplicitStorageInstructions            sql.NullString
	BelongsToRecipePrepTask                sql.NullString
	BelongsToRecipeStep                    sql.NullString
	ID                                     sql.NullString
	MinimumStorageTemperatureInCelsius     sql.NullString
	MaximumStorageTemperatureInCelsius     sql.NullString
	BelongsToRecipe                        sql.NullString
	Notes                                  sql.NullString
	ID_2                                   sql.NullString
	Name                                   sql.NullString
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	MinimumTimeBufferBeforeRecipeInSeconds sql.NullInt32
	Optional                               sql.NullBool
	SatisfiesRecipeStep                    sql.NullBool
}

func (q *Queries) GetRecipePrepTask(ctx context.Context, db DBTX, id string) (*GetRecipePrepTaskRow, error) {
	row := db.QueryRowContext(ctx, getRecipePrepTask, id)
	var i GetRecipePrepTaskRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Notes,
		&i.Optional,
		&i.ExplicitStorageInstructions,
		&i.MinimumTimeBufferBeforeRecipeInSeconds,
		&i.MaximumTimeBufferBeforeRecipeInSeconds,
		&i.StorageType,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.BelongsToRecipe,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_2,
		&i.BelongsToRecipeStep,
		&i.BelongsToRecipePrepTask,
		&i.SatisfiesRecipeStep,
	)
	return &i, err
}

const getRecipeRating = `-- name: GetRecipeRating :one

SELECT
	recipe_ratings.id,
    recipe_ratings.recipe_id,
    recipe_ratings.taste,
    recipe_ratings.difficulty,
    recipe_ratings.cleanup,
    recipe_ratings.instructions,
    recipe_ratings.overall,
    recipe_ratings.notes,
    recipe_ratings.by_user,
    recipe_ratings.created_at,
    recipe_ratings.last_updated_at,
    recipe_ratings.archived_at
FROM recipe_ratings
WHERE recipe_ratings.archived_at IS NULL
	AND recipe_ratings.id = $1
`

func (q *Queries) GetRecipeRating(ctx context.Context, db DBTX, id string) (*RecipeRatings, error) {
	row := db.QueryRowContext(ctx, getRecipeRating, id)
	var i RecipeRatings
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.Taste,
		&i.Difficulty,
		&i.Cleanup,
		&i.Instructions,
		&i.Overall,
		&i.Notes,
		&i.ByUser,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRecipeStep = `-- name: GetRecipeStep :one

SELECT
	recipe_steps.id,
	recipe_steps.index,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	recipe_steps.minimum_estimated_time_in_seconds,
	recipe_steps.maximum_estimated_time_in_seconds,
	recipe_steps.minimum_temperature_in_celsius,
	recipe_steps.maximum_temperature_in_celsius,
	recipe_steps.notes,
	recipe_steps.explicit_instructions,
	recipe_steps.condition_expression,
	recipe_steps.optional,
	recipe_steps.start_timer_automatically,
	recipe_steps.created_at,
	recipe_steps.last_updated_at,
	recipe_steps.archived_at,
	recipe_steps.belongs_to_recipe
FROM recipe_steps
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_preparations ON recipe_steps.preparation_id=valid_preparations.id
WHERE recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipe_steps.id = $2
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepParams struct {
	BelongsToRecipe string
	ID              string
}

type GetRecipeStepRow struct {
	CreatedAt                     time.Time
	CreatedAt_2                   time.Time
	ArchivedAt_2                  sql.NullTime
	LastUpdatedAt                 sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt_2               sql.NullTime
	ConditionExpression           string
	ID_2                          string
	Description                   string
	ID                            string
	Name                          string
	ExplicitInstructions          string
	Notes                         string
	IconPath                      string
	PastTense                     string
	Slug                          string
	BelongsToRecipe               string
	MaximumTemperatureInCelsius   sql.NullString
	MinimumTemperatureInCelsius   sql.NullString
	MinimumEstimatedTimeInSeconds sql.NullInt64
	MaximumEstimatedTimeInSeconds sql.NullInt64
	MaximumIngredientCount        sql.NullInt32
	MaximumVesselCount            sql.NullInt32
	MaximumInstrumentCount        sql.NullInt32
	MinimumVesselCount            int32
	Index                         int32
	MinimumIngredientCount        int32
	MinimumInstrumentCount        int32
	TemperatureRequired           bool
	TimeEstimateRequired          bool
	ConditionExpressionRequired   bool
	Optional                      bool
	StartTimerAutomatically       bool
	ConsumesVessel                bool
	RestrictToIngredients         bool
	YieldsNothing                 bool
	OnlyForVessels                bool
}

func (q *Queries) GetRecipeStep(ctx context.Context, db DBTX, arg *GetRecipeStepParams) (*GetRecipeStepRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStep, arg.BelongsToRecipe, arg.ID)
	var i GetRecipeStepRow
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.MinimumEstimatedTimeInSeconds,
		&i.MaximumEstimatedTimeInSeconds,
		&i.MinimumTemperatureInCelsius,
		&i.MaximumTemperatureInCelsius,
		&i.Notes,
		&i.ExplicitInstructions,
		&i.ConditionExpression,
		&i.Optional,
		&i.StartTimerAutomatically,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipe,
	)
	return &i, err
}

const getRecipeStepCompletionCondition = `-- name: GetRecipeStepCompletionCondition :one

SELECT
	recipe_step_completion_condition_ingredients.id,
	recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition,
	recipe_step_completion_condition_ingredients.recipe_step_ingredient,
	recipe_step_completion_conditions.id,
	recipe_step_completion_conditions.belongs_to_recipe_step,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	recipe_step_completion_conditions.optional,
	recipe_step_completion_conditions.notes,
	recipe_step_completion_conditions.created_at,
	recipe_step_completion_conditions.last_updated_at,
	recipe_step_completion_conditions.archived_at
FROM recipe_step_completion_conditions
    JOIN recipe_step_completion_condition_ingredients ON recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition = recipe_step_completion_conditions.id
    JOIN recipe_steps ON recipe_step_completion_conditions.belongs_to_recipe_step = recipe_steps.id
    JOIN recipes ON recipe_steps.belongs_to_recipe = recipes.id
    JOIN valid_ingredient_states ON recipe_step_completion_conditions.ingredient_state = valid_ingredient_states.id
WHERE recipe_step_completion_conditions.archived_at IS NULL
    AND recipe_step_completion_condition_ingredients.archived_at IS NULL
	AND recipe_step_completion_conditions.belongs_to_recipe_step = $2
	AND recipe_step_completion_conditions.id = $3
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipe_steps.id = $2
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepCompletionConditionParams struct {
	BelongsToRecipe     string
	BelongsToRecipeStep string
	ID                  string
}

type GetRecipeStepCompletionConditionRow struct {
	CreatedAt                              time.Time
	CreatedAt_2                            time.Time
	ArchivedAt_2                           sql.NullTime
	LastUpdatedAt_2                        sql.NullTime
	ArchivedAt                             sql.NullTime
	LastUpdatedAt                          sql.NullTime
	PastTense                              string
	ID_3                                   string
	IconPath                               string
	Slug                                   string
	ID                                     string
	AttributeType                          IngredientAttributeType
	Name                                   string
	Description                            string
	BelongsToRecipeStep                    string
	BelongsToRecipeStepCompletionCondition string
	Notes                                  string
	ID_2                                   string
	RecipeStepIngredient                   string
	Optional                               bool
}

func (q *Queries) GetRecipeStepCompletionCondition(ctx context.Context, db DBTX, arg *GetRecipeStepCompletionConditionParams) (*GetRecipeStepCompletionConditionRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepCompletionCondition, arg.BelongsToRecipe, arg.BelongsToRecipeStep, arg.ID)
	var i GetRecipeStepCompletionConditionRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToRecipeStepCompletionCondition,
		&i.RecipeStepIngredient,
		&i.ID_2,
		&i.BelongsToRecipeStep,
		&i.ID_3,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.Optional,
		&i.Notes,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const getRecipeStepIngredient = `-- name: GetRecipeStepIngredient :one

SELECT
	recipe_step_ingredients.id,
	recipe_step_ingredients.name,
	recipe_step_ingredients.optional,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	recipe_step_ingredients.minimum_quantity_value,
	recipe_step_ingredients.maximum_quantity_value,
	recipe_step_ingredients.quantity_notes,
	recipe_step_ingredients.recipe_step_product_id,
	recipe_step_ingredients.ingredient_notes,
	recipe_step_ingredients.option_index,
	recipe_step_ingredients.to_taste,
	recipe_step_ingredients.product_percentage_to_use,
    recipe_step_ingredients.vessel_index,
    recipe_step_ingredients.recipe_step_product_recipe_id,
	recipe_step_ingredients.created_at,
	recipe_step_ingredients.last_updated_at,
	recipe_step_ingredients.archived_at,
	recipe_step_ingredients.belongs_to_recipe_step
FROM recipe_step_ingredients
	 JOIN recipe_steps ON recipe_step_ingredients.belongs_to_recipe_step=recipe_steps.id
	 JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	 JOIN valid_ingredients ON recipe_step_ingredients.ingredient_id=valid_ingredients.id
	 JOIN valid_measurement_units ON recipe_step_ingredients.measurement_unit=valid_measurement_units.id
WHERE recipe_step_ingredients.archived_at IS NULL
	AND recipe_step_ingredients.belongs_to_recipe_step = $1
	AND recipe_step_ingredients.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepIngredientParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepIngredientRow struct {
	CreatedAt_3                             time.Time
	CreatedAt                               time.Time
	CreatedAt_2                             time.Time
	LastUpdatedAt                           sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	ArchivedAt                              sql.NullTime
	ArchivedAt_3                            sql.NullTime
	LastUpdatedAt_3                         sql.NullTime
	IconPath                                string
	PluralName_2                            string
	Name                                    string
	BelongsToRecipeStep                     string
	ID_3                                    string
	IngredientNotes                         string
	Name_3                                  string
	QuantityNotes                           string
	ID                                      string
	Description_2                           string
	IconPath_2                              string
	Warning                                 string
	MinimumQuantityValue                    string
	PluralName                              string
	Description                             string
	Slug_2                                  string
	ID_2                                    string
	StorageInstructions                     string
	Slug                                    string
	Name_2                                  string
	ShoppingSuggestions                     string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	RecipeStepProductRecipeID               sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue                    sql.NullString
	RecipeStepProductID                     sql.NullString
	ProductPercentageToUse                  sql.NullString
	VesselIndex                             sql.NullInt32
	OptionIndex                             int32
	IsLiquid                                sql.NullBool
	Volumetric_2                            sql.NullBool
	AnimalFlesh                             bool
	IsHeat                                  bool
	IsAcid                                  bool
	IsFat                                   bool
	IsSalt                                  bool
	IsFruit                                 bool
	Universal                               bool
	Metric                                  bool
	Imperial                                bool
	IsGrain                                 bool
	IsProtein                               bool
	IsStarch                                bool
	ContainsAlcohol                         bool
	RestrictToPreparations                  bool
	AnimalDerived                           bool
	Volumetric                              bool
	ContainsGluten                          bool
	ContainsFish                            bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ToTaste                                 bool
	ContainsWheat                           bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
	Optional                                bool
}

func (q *Queries) GetRecipeStepIngredient(ctx context.Context, db DBTX, arg *GetRecipeStepIngredientParams) (*GetRecipeStepIngredientRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepIngredient,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Optional,
		&i.ID_2,
		&i.Name_2,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_3,
		&i.Description_2,
		&i.Volumetric_2,
		&i.IconPath_2,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.RecipeStepProductID,
		&i.IngredientNotes,
		&i.OptionIndex,
		&i.ToTaste,
		&i.ProductPercentageToUse,
		&i.VesselIndex,
		&i.RecipeStepProductRecipeID,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepInstrument = `-- name: GetRecipeStepInstrument :one

SELECT
	recipe_step_instruments.id,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
    valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	recipe_step_instruments.recipe_step_product_id,
	recipe_step_instruments.name,
	recipe_step_instruments.notes,
	recipe_step_instruments.preference_rank,
	recipe_step_instruments.optional,
	recipe_step_instruments.minimum_quantity,
	recipe_step_instruments.maximum_quantity,
	recipe_step_instruments.option_index,
	recipe_step_instruments.created_at,
	recipe_step_instruments.last_updated_at,
	recipe_step_instruments.archived_at,
	recipe_step_instruments.belongs_to_recipe_step
FROM recipe_step_instruments
	LEFT JOIN valid_instruments ON recipe_step_instruments.instrument_id=valid_instruments.id
	JOIN recipe_steps ON recipe_step_instruments.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_instruments.archived_at IS NULL
	AND recipe_step_instruments.belongs_to_recipe_step = $1
	AND recipe_step_instruments.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepInstrumentParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepInstrumentRow struct {
	CreatedAt_2                    time.Time
	ArchivedAt                     sql.NullTime
	ArchivedAt_2                   sql.NullTime
	LastUpdatedAt_2                sql.NullTime
	LastUpdatedAt                  sql.NullTime
	CreatedAt                      sql.NullTime
	Name_2                         string
	BelongsToRecipeStep            string
	ID                             string
	Notes                          string
	Description                    sql.NullString
	PluralName                     sql.NullString
	IconPath                       sql.NullString
	Slug                           sql.NullString
	RecipeStepProductID            sql.NullString
	Name                           sql.NullString
	ID_2                           sql.NullString
	MaximumQuantity                sql.NullInt32
	MinimumQuantity                int32
	OptionIndex                    int32
	PreferenceRank                 int32
	IncludeInGeneratedInstructions sql.NullBool
	DisplayInSummaryLists          sql.NullBool
	UsableForStorage               sql.NullBool
	Optional                       bool
}

func (q *Queries) GetRecipeStepInstrument(ctx context.Context, db DBTX, arg *GetRecipeStepInstrumentParams) (*GetRecipeStepInstrumentRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepInstrument,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.RecipeStepProductID,
		&i.Name_2,
		&i.Notes,
		&i.PreferenceRank,
		&i.Optional,
		&i.MinimumQuantity,
		&i.MaximumQuantity,
		&i.OptionIndex,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepProduct = `-- name: GetRecipeStepProduct :one

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_step_products.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepProductRow struct {
	CreatedAt_2                        time.Time
	CreatedAt                          time.Time
	ArchivedAt_2                       sql.NullTime
	LastUpdatedAt_2                    sql.NullTime
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	QuantityNotes                      string
	ID_2                               string
	ID                                 string
	BelongsToRecipeStep                string
	Name                               string
	Slug                               string
	PluralName                         string
	Description                        string
	Name_2                             string
	IconPath                           string
	StorageInstructions                string
	Type                               RecipeStepProductType
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Volumetric                         sql.NullBool
	Universal                          bool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
	Imperial                           bool
	Metric                             bool
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, db DBTX, arg *GetRecipeStepProductParams) (*GetRecipeStepProductRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepProduct,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ID_2,
		&i.Name_2,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.Compostable,
		&i.MaximumStorageDurationInSeconds,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.IsLiquid,
		&i.IsWaste,
		&i.Index,
		&i.ContainedInVesselIndex,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepVessel = `-- name: GetRecipeStepVessel :one

SELECT
    recipe_step_vessels.id,
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
    valid_vessels.width_in_millimeters,
    valid_vessels.length_in_millimeters,
    valid_vessels.height_in_millimeters,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at,
    recipe_step_vessels.name,
    recipe_step_vessels.notes,
    recipe_step_vessels.belongs_to_recipe_step,
    recipe_step_vessels.recipe_step_product_id,
    recipe_step_vessels.vessel_predicate,
    recipe_step_vessels.minimum_quantity,
    recipe_step_vessels.maximum_quantity,
    recipe_step_vessels.unavailable_after_step,
    recipe_step_vessels.created_at,
    recipe_step_vessels.last_updated_at,
    recipe_step_vessels.archived_at
FROM recipe_step_vessels
	LEFT JOIN valid_vessels ON recipe_step_vessels.valid_vessel_id=valid_vessels.id
    LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
	JOIN recipe_steps ON recipe_step_vessels.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_vessels.archived_at IS NULL
	AND recipe_step_vessels.belongs_to_recipe_step = $1
	AND recipe_step_vessels.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepVesselParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepVesselRow struct {
	CreatedAt_3                    time.Time
	LastUpdatedAt_2                sql.NullTime
	LastUpdatedAt_3                sql.NullTime
	ArchivedAt_3                   sql.NullTime
	ArchivedAt_2                   sql.NullTime
	CreatedAt                      sql.NullTime
	CreatedAt_2                    sql.NullTime
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	VesselPredicate                string
	BelongsToRecipeStep            string
	Notes                          string
	Name_3                         string
	ID                             string
	Capacity                       sql.NullString
	IconPath                       sql.NullString
	ID_2                           sql.NullString
	Name                           sql.NullString
	PluralName                     sql.NullString
	Slug_2                         sql.NullString
	PluralName_2                   sql.NullString
	Description                    sql.NullString
	Description_2                  sql.NullString
	Name_2                         sql.NullString
	WidthInMillimeters             sql.NullString
	LengthInMillimeters            sql.NullString
	HeightInMillimeters            sql.NullString
	Shape                          NullVesselShape
	ID_3                           sql.NullString
	RecipeStepProductID            sql.NullString
	IconPath_2                     sql.NullString
	Slug                           sql.NullString
	MaximumQuantity                sql.NullInt32
	MinimumQuantity                int32
	UsableForStorage               sql.NullBool
	DisplayInSummaryLists          sql.NullBool
	IncludeInGeneratedInstructions sql.NullBool
	Volumetric                     sql.NullBool
	Imperial                       sql.NullBool
	Metric                         sql.NullBool
	Universal                      sql.NullBool
	UnavailableAfterStep           bool
}

func (q *Queries) GetRecipeStepVessel(ctx context.Context, db DBTX, arg *GetRecipeStepVesselParams) (*GetRecipeStepVesselRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepVessel,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepVesselRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Volumetric,
		&i.IconPath_2,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.Name_3,
		&i.Notes,
		&i.BelongsToRecipeStep,
		&i.RecipeStepProductID,
		&i.VesselPredicate,
		&i.MinimumQuantity,
		&i.MaximumQuantity,
		&i.UnavailableAfterStep,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const getServiceSetting = `-- name: GetServiceSetting :one

SELECT
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.admins_only,
    service_settings.enumeration,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at
FROM service_settings
WHERE service_settings.archived_at IS NULL
	AND service_settings.id = $1
`

type GetServiceSettingRow struct {
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	ID            string
	Name          string
	Type          SettingType
	Description   string
	Enumeration   string
	DefaultValue  sql.NullString
	AdminsOnly    bool
}

func (q *Queries) GetServiceSetting(ctx context.Context, db DBTX, id string) (*GetServiceSettingRow, error) {
	row := db.QueryRowContext(ctx, getServiceSetting, id)
	var i GetServiceSettingRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.AdminsOnly,
		&i.Enumeration,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidIngredient = `-- name: GetValidIngredient :one

SELECT
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at
FROM valid_ingredients
WHERE valid_ingredients.archived_at IS NULL
AND valid_ingredients.id = $1
`

type GetValidIngredientRow struct {
	CreatedAt                               time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	Warning                                 string
	Description                             string
	Name                                    string
	ShoppingSuggestions                     string
	Slug                                    string
	StorageInstructions                     string
	PluralName                              string
	ID                                      string
	IconPath                                string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	IsLiquid                                sql.NullBool
	AnimalDerived                           bool
	ContainsTreeNut                         bool
	AnimalFlesh                             bool
	ContainsGluten                          bool
	ContainsFish                            bool
	RestrictToPreparations                  bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsWheat                           bool
	ContainsSoy                             bool
	ContainsAlcohol                         bool
	Volumetric                              bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredient(ctx context.Context, db DBTX, id string) (*GetValidIngredientRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredient, id)
	var i GetValidIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidIngredientGroup = `-- name: GetValidIngredientGroup :many

SELECT
	valid_ingredient_groups.id,
	valid_ingredient_groups.name,
	valid_ingredient_groups.description,
	valid_ingredient_groups.slug,
	valid_ingredient_groups.created_at,
	valid_ingredient_groups.last_updated_at,
	valid_ingredient_groups.archived_at,
	valid_ingredient_group_members.id,
    valid_ingredient_group_members.belongs_to_group,
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at,
    valid_ingredient_group_members.created_at,
    valid_ingredient_group_members.archived_at
FROM valid_ingredient_group_members
 JOIN valid_ingredient_groups ON valid_ingredient_group_members.belongs_to_group=valid_ingredient_groups.id
  JOIN valid_ingredients ON valid_ingredients.id = valid_ingredient_group_members.valid_ingredient
WHERE valid_ingredient_groups.archived_at IS NULL
AND valid_ingredient_group_members.archived_at IS NULL
AND valid_ingredient_groups.id = $1
`

type GetValidIngredientGroupRow struct {
	CreatedAt_2                             time.Time
	CreatedAt                               time.Time
	CreatedAt_3                             time.Time
	ArchivedAt_3                            sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	LastUpdatedAt                           sql.NullTime
	ArchivedAt                              sql.NullTime
	Warning                                 string
	Name                                    string
	Name_2                                  string
	Description_2                           string
	IconPath                                string
	BelongsToGroup                          string
	ID_2                                    string
	Slug                                    string
	Description                             string
	ID_3                                    string
	ShoppingSuggestions                     string
	Slug_2                                  string
	StorageInstructions                     string
	ID                                      string
	PluralName                              string
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	IsLiquid                                sql.NullBool
	Volumetric                              bool
	AnimalDerived                           bool
	AnimalFlesh                             bool
	RestrictToPreparations                  bool
	ContainsGluten                          bool
	ContainsFish                            bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsAlcohol                         bool
	ContainsWheat                           bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredientGroup(ctx context.Context, db DBTX, id string) ([]*GetValidIngredientGroupRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientGroup, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientGroupRow{}
	for rows.Next() {
		var i GetValidIngredientGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.ID_2,
			&i.BelongsToGroup,
			&i.ID_3,
			&i.Name_2,
			&i.Description_2,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug_2,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.CreatedAt_3,
			&i.ArchivedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientMeasurementUnit = `-- name: GetValidIngredientMeasurementUnit :one

SELECT
	valid_ingredient_measurement_units.id,
	valid_ingredient_measurement_units.notes,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_measurement_units.minimum_allowable_quantity,
	valid_ingredient_measurement_units.maximum_allowable_quantity,
	valid_ingredient_measurement_units.created_at,
	valid_ingredient_measurement_units.last_updated_at,
	valid_ingredient_measurement_units.archived_at
FROM valid_ingredient_measurement_units
	JOIN valid_measurement_units ON valid_ingredient_measurement_units.valid_measurement_unit_id = valid_measurement_units.id
	JOIN valid_ingredients ON valid_ingredient_measurement_units.valid_ingredient_id = valid_ingredients.id
WHERE valid_ingredient_measurement_units.archived_at IS NULL
	AND valid_ingredient_measurement_units.id = $1
`

type GetValidIngredientMeasurementUnitRow struct {
	CreatedAt                               time.Time
	CreatedAt_2                             time.Time
	CreatedAt_3                             time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	LastUpdatedAt_3                         sql.NullTime
	ArchivedAt_3                            sql.NullTime
	Slug                                    string
	Slug_2                                  string
	ID_3                                    string
	Name_2                                  string
	Description_2                           string
	Warning                                 string
	PluralName_2                            string
	IconPath_2                              string
	IconPath                                string
	Description                             string
	ID                                      string
	MinimumAllowableQuantity                string
	Name                                    string
	ID_2                                    string
	Notes                                   string
	ShoppingSuggestions                     string
	PluralName                              string
	StorageInstructions                     string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MaximumAllowableQuantity                sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	Volumetric                              sql.NullBool
	IsLiquid                                sql.NullBool
	ContainsGluten                          bool
	AnimalDerived                           bool
	Volumetric_2                            bool
	RestrictToPreparations                  bool
	AnimalFlesh                             bool
	ContainsFish                            bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsAlcohol                         bool
	ContainsWheat                           bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
	Imperial                                bool
	Metric                                  bool
	Universal                               bool
}

func (q *Queries) GetValidIngredientMeasurementUnit(ctx context.Context, db DBTX, id string) (*GetValidIngredientMeasurementUnitRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientMeasurementUnit, id)
	var i GetValidIngredientMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric_2,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName_2,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumAllowableQuantity,
		&i.MaximumAllowableQuantity,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const getValidIngredientPreparation = `-- name: GetValidIngredientPreparation :one

SELECT
	valid_ingredient_preparations.id,
	valid_ingredient_preparations.notes,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_preparations.created_at,
	valid_ingredient_preparations.last_updated_at,
	valid_ingredient_preparations.archived_at
FROM valid_ingredient_preparations
	JOIN valid_ingredients ON valid_ingredient_preparations.valid_ingredient_id = valid_ingredients.id
	JOIN valid_preparations ON valid_ingredient_preparations.valid_preparation_id = valid_preparations.id
WHERE valid_ingredient_preparations.archived_at IS NULL
	AND valid_ingredient_preparations.id = $1
`

type GetValidIngredientPreparationRow struct {
	CreatedAt_3                             time.Time
	CreatedAt                               time.Time
	CreatedAt_2                             time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_3                            sql.NullTime
	LastUpdatedAt_3                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	ID_3                                    string
	ID_2                                    string
	IconPath_2                              string
	PluralName                              string
	StorageInstructions                     string
	IconPath                                string
	ID                                      string
	Description                             string
	Slug_2                                  string
	ShoppingSuggestions                     string
	Slug                                    string
	PastTense                               string
	Name                                    string
	Warning                                 string
	Notes                                   string
	Description_2                           string
	Name_2                                  string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	MaximumVesselCount                      sql.NullInt32
	MaximumIngredientCount                  sql.NullInt32
	MaximumInstrumentCount                  sql.NullInt32
	MinimumInstrumentCount                  int32
	MinimumVesselCount                      int32
	MinimumIngredientCount                  int32
	IsLiquid                                sql.NullBool
	ConsumesVessel                          bool
	ContainsFish                            bool
	ContainsGluten                          bool
	AnimalFlesh                             bool
	Volumetric                              bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	AnimalDerived                           bool
	ContainsWheat                           bool
	RestrictToPreparations                  bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsAlcohol                         bool
	ContainsEgg                             bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	OnlyForVessels                          bool
	ConditionExpressionRequired             bool
	TimeEstimateRequired                    bool
	TemperatureRequired                     bool
	RestrictToIngredients                   bool
	YieldsNothing                           bool
}

func (q *Queries) GetValidIngredientPreparation(ctx context.Context, db DBTX, id string) (*GetValidIngredientPreparationRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientPreparation, id)
	var i GetValidIngredientPreparationRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const getValidIngredientState = `-- name: GetValidIngredientState :one

SELECT
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at
FROM valid_ingredient_states
WHERE valid_ingredient_states.archived_at IS NULL
	AND valid_ingredient_states.id = $1
`

type GetValidIngredientStateRow struct {
	ID            string
	Name          string
	Description   string
	IconPath      string
	Slug          string
	PastTense     string
	AttributeType IngredientAttributeType
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
}

func (q *Queries) GetValidIngredientState(ctx context.Context, db DBTX, id string) (*GetValidIngredientStateRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientState, id)
	var i GetValidIngredientStateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidIngredientStateIngredient = `-- name: GetValidIngredientStateIngredient :one

SELECT
	valid_ingredient_state_ingredients.id,
	valid_ingredient_state_ingredients.notes,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_state_ingredients.created_at,
	valid_ingredient_state_ingredients.last_updated_at,
	valid_ingredient_state_ingredients.archived_at
FROM valid_ingredient_state_ingredients
	JOIN valid_ingredients ON valid_ingredient_state_ingredients.valid_ingredient = valid_ingredients.id
	JOIN valid_ingredient_states ON valid_ingredient_state_ingredients.valid_ingredient_state = valid_ingredient_states.id
WHERE valid_ingredient_state_ingredients.archived_at IS NULL
	AND valid_ingredient_state_ingredients.id = $1
`

type GetValidIngredientStateIngredientRow struct {
	CreatedAt                               time.Time
	CreatedAt_2                             time.Time
	CreatedAt_3                             time.Time
	ArchivedAt_3                            sql.NullTime
	LastUpdatedAt                           sql.NullTime
	ArchivedAt                              sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	LastUpdatedAt_3                         sql.NullTime
	Description                             string
	PluralName                              string
	AttributeType                           IngredientAttributeType
	ID_3                                    string
	Name_2                                  string
	Description_2                           string
	Warning                                 string
	IconPath_2                              string
	StorageInstructions                     string
	Slug                                    string
	IconPath                                string
	PastTense                               string
	Name                                    string
	ID_2                                    string
	Notes                                   string
	ShoppingSuggestions                     string
	Slug_2                                  string
	ID                                      string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	IsLiquid                                sql.NullBool
	ContainsFish                            bool
	AnimalDerived                           bool
	RestrictToPreparations                  bool
	Volumetric                              bool
	AnimalFlesh                             bool
	ContainsGluten                          bool
	ContainsSesame                          bool
	ContainsAlcohol                         bool
	ContainsShellfish                       bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsWheat                           bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredientStateIngredient(ctx context.Context, db DBTX, id string) (*GetValidIngredientStateIngredientRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientStateIngredient, id)
	var i GetValidIngredientStateIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const getValidInstrument = `-- name: GetValidInstrument :one

SELECT
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at
FROM valid_instruments
WHERE valid_instruments.archived_at IS NULL
	AND valid_instruments.id = $1
`

type GetValidInstrumentRow struct {
	CreatedAt                      time.Time
	LastUpdatedAt                  sql.NullTime
	ArchivedAt                     sql.NullTime
	ID                             string
	Name                           string
	PluralName                     string
	Description                    string
	IconPath                       string
	Slug                           string
	UsableForStorage               bool
	DisplayInSummaryLists          bool
	IncludeInGeneratedInstructions bool
}

func (q *Queries) GetValidInstrument(ctx context.Context, db DBTX, id string) (*GetValidInstrumentRow, error) {
	row := db.QueryRowContext(ctx, getValidInstrument, id)
	var i GetValidInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidMeasurementConversion = `-- name: GetValidMeasurementConversion :one

SELECT
	valid_measurement_conversions.id,
	valid_measurement_units_from.id,
	valid_measurement_units_from.name,
	valid_measurement_units_from.description,
	valid_measurement_units_from.volumetric,
	valid_measurement_units_from.icon_path,
	valid_measurement_units_from.universal,
	valid_measurement_units_from.metric,
	valid_measurement_units_from.imperial,
	valid_measurement_units_from.slug,
	valid_measurement_units_from.plural_name,
	valid_measurement_units_from.created_at,
	valid_measurement_units_from.last_updated_at,
	valid_measurement_units_from.archived_at,
	valid_measurement_units_to.id,
	valid_measurement_units_to.name,
	valid_measurement_units_to.description,
	valid_measurement_units_to.volumetric,
	valid_measurement_units_to.icon_path,
	valid_measurement_units_to.universal,
	valid_measurement_units_to.metric,
	valid_measurement_units_to.imperial,
	valid_measurement_units_to.slug,
	valid_measurement_units_to.plural_name,
	valid_measurement_units_to.created_at,
	valid_measurement_units_to.last_updated_at,
	valid_measurement_units_to.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_measurement_conversions.modifier,
	valid_measurement_conversions.notes,
	valid_measurement_conversions.created_at,
	valid_measurement_conversions.last_updated_at,
	valid_measurement_conversions.archived_at
FROM valid_measurement_conversions
	     LEFT JOIN valid_ingredients ON valid_measurement_conversions.only_for_ingredient = valid_ingredients.id
	     JOIN valid_measurement_units AS valid_measurement_units_from ON valid_measurement_conversions.from_unit = valid_measurement_units_from.id
	     JOIN valid_measurement_units AS valid_measurement_units_to ON valid_measurement_conversions.to_unit = valid_measurement_units_to.id
WHERE valid_measurement_conversions.id = $1
  AND valid_measurement_conversions.archived_at IS NULL
  AND valid_measurement_units_from.archived_at IS NULL
  AND valid_measurement_units_to.archived_at IS NULL
`

type GetValidMeasurementConversionRow struct {
	CreatedAt_4                             time.Time
	CreatedAt_2                             time.Time
	CreatedAt                               time.Time
	LastUpdatedAt                           sql.NullTime
	ArchivedAt                              sql.NullTime
	ArchivedAt_2                            sql.NullTime
	LastUpdatedAt_4                         sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	CreatedAt_3                             sql.NullTime
	ArchivedAt_4                            sql.NullTime
	LastUpdatedAt_3                         sql.NullTime
	ArchivedAt_3                            sql.NullTime
	Slug                                    string
	Name                                    string
	ID_3                                    string
	Name_2                                  string
	Description_2                           string
	Modifier                                string
	IconPath_2                              string
	ID                                      string
	PluralName                              string
	Notes                                   string
	Slug_2                                  string
	PluralName_2                            string
	ID_2                                    string
	Description                             string
	IconPath                                string
	Slug_3                                  sql.NullString
	Name_3                                  sql.NullString
	Description_3                           sql.NullString
	Warning                                 sql.NullString
	ShoppingSuggestions                     sql.NullString
	ID_4                                    sql.NullString
	StorageInstructions                     sql.NullString
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	PluralName_3                            sql.NullString
	IconPath_3                              sql.NullString
	ContainsSesame                          sql.NullBool
	ContainsEgg                             sql.NullBool
	ContainsGluten                          sql.NullBool
	AnimalFlesh                             sql.NullBool
	Volumetric_3                            sql.NullBool
	IsLiquid                                sql.NullBool
	ContainsShellfish                       sql.NullBool
	AnimalDerived                           sql.NullBool
	ContainsWheat                           sql.NullBool
	RestrictToPreparations                  sql.NullBool
	ContainsSoy                             sql.NullBool
	ContainsTreeNut                         sql.NullBool
	ContainsPeanut                          sql.NullBool
	ContainsDairy                           sql.NullBool
	ContainsAlcohol                         sql.NullBool
	ContainsFish                            sql.NullBool
	IsStarch                                sql.NullBool
	IsProtein                               sql.NullBool
	IsGrain                                 sql.NullBool
	IsFruit                                 sql.NullBool
	IsSalt                                  sql.NullBool
	IsFat                                   sql.NullBool
	IsAcid                                  sql.NullBool
	IsHeat                                  sql.NullBool
	Volumetric                              sql.NullBool
	Volumetric_2                            sql.NullBool
	Universal_2                             bool
	Metric_2                                bool
	Imperial                                bool
	Metric                                  bool
	Universal                               bool
	Imperial_2                              bool
}

func (q *Queries) GetValidMeasurementConversion(ctx context.Context, db DBTX, id string) (*GetValidMeasurementConversionRow, error) {
	row := db.QueryRowContext(ctx, getValidMeasurementConversion, id)
	var i GetValidMeasurementConversionRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Volumetric_2,
		&i.IconPath_2,
		&i.Universal_2,
		&i.Metric_2,
		&i.Imperial_2,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.ID_4,
		&i.Name_3,
		&i.Description_3,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric_3,
		&i.IsLiquid,
		&i.IconPath_3,
		&i.AnimalDerived,
		&i.PluralName_3,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_3,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.Modifier,
		&i.Notes,
		&i.CreatedAt_4,
		&i.LastUpdatedAt_4,
		&i.ArchivedAt_4,
	)
	return &i, err
}

const getValidMeasurementUnit = `-- name: GetValidMeasurementUnit :one

SELECT
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at
FROM valid_measurement_units
WHERE valid_measurement_units.archived_at IS NULL
	AND valid_measurement_units.id = $1
`

type GetValidMeasurementUnitRow struct {
	CreatedAt     time.Time
	ArchivedAt    sql.NullTime
	LastUpdatedAt sql.NullTime
	PluralName    string
	Name          string
	Description   string
	ID            string
	IconPath      string
	Slug          string
	Volumetric    sql.NullBool
	Imperial      bool
	Metric        bool
	Universal     bool
}

func (q *Queries) GetValidMeasurementUnit(ctx context.Context, db DBTX, id string) (*GetValidMeasurementUnitRow, error) {
	row := db.QueryRowContext(ctx, getValidMeasurementUnit, id)
	var i GetValidMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidPreparation = `-- name: GetValidPreparation :one

SELECT
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
    valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at
FROM valid_preparations
WHERE valid_preparations.archived_at IS NULL
	AND valid_preparations.id = $1
`

type GetValidPreparationRow struct {
	CreatedAt                   time.Time
	LastUpdatedAt               sql.NullTime
	ArchivedAt                  sql.NullTime
	Name                        string
	Description                 string
	IconPath                    string
	ID                          string
	Slug                        string
	PastTense                   string
	MaximumInstrumentCount      sql.NullInt32
	MaximumIngredientCount      sql.NullInt32
	MaximumVesselCount          sql.NullInt32
	MinimumVesselCount          int32
	MinimumInstrumentCount      int32
	MinimumIngredientCount      int32
	RestrictToIngredients       bool
	OnlyForVessels              bool
	ConsumesVessel              bool
	ConditionExpressionRequired bool
	TimeEstimateRequired        bool
	TemperatureRequired         bool
	YieldsNothing               bool
}

func (q *Queries) GetValidPreparation(ctx context.Context, db DBTX, id string) (*GetValidPreparationRow, error) {
	row := db.QueryRowContext(ctx, getValidPreparation, id)
	var i GetValidPreparationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidPreparationInstrument = `-- name: GetValidPreparationInstrument :one

SELECT
	valid_preparation_instruments.id,
	valid_preparation_instruments.notes,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	valid_preparation_instruments.created_at,
	valid_preparation_instruments.last_updated_at,
	valid_preparation_instruments.archived_at
FROM
	valid_preparation_instruments
	 JOIN valid_instruments ON valid_preparation_instruments.valid_instrument_id = valid_instruments.id
	 JOIN valid_preparations ON valid_preparation_instruments.valid_preparation_id = valid_preparations.id
WHERE
	valid_preparation_instruments.archived_at IS NULL
	AND valid_preparation_instruments.id = $1
`

type GetValidPreparationInstrumentRow struct {
	CreatedAt                      time.Time
	CreatedAt_2                    time.Time
	CreatedAt_3                    time.Time
	ArchivedAt_2                   sql.NullTime
	LastUpdatedAt                  sql.NullTime
	LastUpdatedAt_2                sql.NullTime
	ArchivedAt                     sql.NullTime
	ArchivedAt_3                   sql.NullTime
	LastUpdatedAt_3                sql.NullTime
	IconPath                       string
	PluralName                     string
	Description                    string
	Name                           string
	Slug_2                         string
	IconPath_2                     string
	Description_2                  string
	ID                             string
	Name_2                         string
	ID_3                           string
	Slug                           string
	PastTense                      string
	ID_2                           string
	Notes                          string
	MaximumIngredientCount         sql.NullInt32
	MaximumVesselCount             sql.NullInt32
	MaximumInstrumentCount         sql.NullInt32
	MinimumVesselCount             int32
	MinimumIngredientCount         int32
	MinimumInstrumentCount         int32
	DisplayInSummaryLists          bool
	UsableForStorage               bool
	IncludeInGeneratedInstructions bool
	TimeEstimateRequired           bool
	TemperatureRequired            bool
	ConditionExpressionRequired    bool
	ConsumesVessel                 bool
	OnlyForVessels                 bool
	RestrictToIngredients          bool
	YieldsNothing                  bool
}

func (q *Queries) GetValidPreparationInstrument(ctx context.Context, db DBTX, id string) (*GetValidPreparationInstrumentRow, error) {
	row := db.QueryRowContext(ctx, getValidPreparationInstrument, id)
	var i GetValidPreparationInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.PluralName,
		&i.Description_2,
		&i.IconPath_2,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const getValidPreparationVessel = `-- name: GetValidPreparationVessel :one

SELECT
    valid_preparation_vessels.id as valid_preparation_vessel_id,
    valid_preparation_vessels.notes as valid_preparation_vessel_notes,
    valid_preparations.id as valid_preparation_id,
    valid_preparations.name as valid_preparation_name,
    valid_preparations.description as valid_preparation_description,
    valid_preparations.icon_path as valid_preparation_icon_path,
    valid_preparations.yields_nothing as valid_preparation_yields_nothing,
    valid_preparations.restrict_to_ingredients as valid_preparation_restrict_to_ingredients,
    valid_preparations.minimum_ingredient_count as valid_preparation_minimum_ingredient_count,
    valid_preparations.maximum_ingredient_count as valid_preparation_maximum_ingredient_count,
    valid_preparations.minimum_instrument_count as valid_preparation_minimum_instrument_count,
    valid_preparations.maximum_instrument_count as valid_preparation_maximum_instrument_count,
    valid_preparations.temperature_required as valid_preparation_temperature_required,
    valid_preparations.time_estimate_required as valid_preparation_time_estimate_required,
    valid_preparations.condition_expression_required as valid_preparation_condition_expression_required,
    valid_preparations.consumes_vessel as valid_preparation_consumes_vessel,
    valid_preparations.only_for_vessels as valid_preparation_only_for_vessels,
    valid_preparations.minimum_vessel_count as valid_preparation_minimum_vessel_count,
    valid_preparations.maximum_vessel_count as valid_preparation_maximum_vessel_count,
    valid_preparations.slug as valid_preparation_slug,
    valid_preparations.past_tense as valid_preparation_past_tense,
    valid_preparations.created_at as valid_preparation_created_at,
    valid_preparations.last_updated_at as valid_preparation_last_updated_at,
    valid_preparations.archived_at as valid_preparation_archived_at,
    valid_vessels.id as valid_vessel_id,
    valid_vessels.name as valid_vessel_name,
    valid_vessels.plural_name as valid_vessel_plural_name,
    valid_vessels.description as valid_vessel_description,
    valid_vessels.icon_path as valid_vessel_icon_path,
    valid_vessels.usable_for_storage as valid_vessel_usable_for_storage,
    valid_vessels.slug as valid_vessel_slug,
    valid_vessels.display_in_summary_lists as valid_vessel_display_in_summary_lists,
    valid_vessels.include_in_generated_instructions as valid_vessel_include_in_generated_instructions,
    valid_vessels.capacity::float as valid_vessel_capacity,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float as valid_vessel_width_in_millimeters,
    valid_vessels.length_in_millimeters::float as valid_vessel_length_in_millimeters,
    valid_vessels.height_in_millimeters::float as valid_vessel_height_in_millimeters,
    valid_vessels.shape as valid_vessel_shape,
    valid_vessels.created_at as valid_vessel_created_at,
    valid_vessels.last_updated_at as valid_vessel_last_updated_at,
    valid_vessels.archived_at as valid_vessel_archived_at,
    valid_preparation_vessels.created_at as valid_preparation_vessel_created_at,
    valid_preparation_vessels.last_updated_at as valid_preparation_vessel_last_updated_at,
    valid_preparation_vessels.archived_at as valid_preparation_vessel_archived_at
FROM
	valid_preparation_vessels
	 JOIN valid_vessels ON valid_preparation_vessels.valid_vessel_id = valid_vessels.id
	 LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit = valid_measurement_units.id
	 JOIN valid_preparations ON valid_preparation_vessels.valid_preparation_id = valid_preparations.id
WHERE
	valid_preparation_vessels.archived_at IS NULL
	AND valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_preparations.archived_at IS NULL
	AND valid_preparation_vessels.id = $1
`

type GetValidPreparationVesselRow struct {
	ValidPreparationCreatedAt                   time.Time
	ValidPreparationVesselCreatedAt             time.Time
	ValidVesselCreatedAt                        time.Time
	ValidMeasurementUnitArchivedAt              sql.NullTime
	ValidPreparationArchivedAt                  sql.NullTime
	ValidPreparationLastUpdatedAt               sql.NullTime
	ValidMeasurementUnitCreatedAt               sql.NullTime
	ValidMeasurementUnitLastUpdatedAt           sql.NullTime
	ValidPreparationVesselArchivedAt            sql.NullTime
	ValidPreparationVesselLastUpdatedAt         sql.NullTime
	ValidVesselArchivedAt                       sql.NullTime
	ValidVesselLastUpdatedAt                    sql.NullTime
	ValidVesselShape                            VesselShape
	ValidPreparationSlug                        string
	ValidPreparationIconPath                    string
	ValidPreparationDescription                 string
	ValidPreparationVesselID                    string
	ValidVesselSlug                             string
	ValidVesselIconPath                         string
	ValidVesselDescription                      string
	ValidPreparationPastTense                   string
	ValidPreparationName                        string
	ValidPreparationID                          string
	ValidPreparationVesselNotes                 string
	ValidVesselID                               string
	ValidVesselName                             string
	ValidVesselPluralName                       string
	ValidMeasurementUnitPluralName              sql.NullString
	ValidMeasurementUnitSlug                    sql.NullString
	ValidMeasurementUnitIconPath                sql.NullString
	ValidMeasurementUnitDescription             sql.NullString
	ValidMeasurementUnitName                    sql.NullString
	ValidMeasurementUnitID                      sql.NullString
	ValidVesselWidthInMillimeters               float64
	ValidVesselCapacity                         float64
	ValidVesselHeightInMillimeters              float64
	ValidVesselLengthInMillimeters              float64
	ValidPreparationMaximumIngredientCount      sql.NullInt32
	ValidPreparationMaximumInstrumentCount      sql.NullInt32
	ValidPreparationMaximumVesselCount          sql.NullInt32
	ValidPreparationMinimumIngredientCount      int32
	ValidPreparationMinimumVesselCount          int32
	ValidPreparationMinimumInstrumentCount      int32
	ValidMeasurementUnitUniversal               sql.NullBool
	ValidMeasurementUnitImperial                sql.NullBool
	ValidMeasurementUnitVolumetric              sql.NullBool
	ValidMeasurementUnitMetric                  sql.NullBool
	ValidPreparationTemperatureRequired         bool
	ValidPreparationOnlyForVessels              bool
	ValidPreparationTimeEstimateRequired        bool
	ValidPreparationConsumesVessel              bool
	ValidVesselUsableForStorage                 bool
	ValidPreparationConditionExpressionRequired bool
	ValidVesselDisplayInSummaryLists            bool
	ValidVesselIncludeInGeneratedInstructions   bool
	ValidPreparationRestrictToIngredients       bool
	ValidPreparationYieldsNothing               bool
}

func (q *Queries) GetValidPreparationVessel(ctx context.Context, db DBTX, id string) (*GetValidPreparationVesselRow, error) {
	row := db.QueryRowContext(ctx, getValidPreparationVessel, id)
	var i GetValidPreparationVesselRow
	err := row.Scan(
		&i.ValidPreparationVesselID,
		&i.ValidPreparationVesselNotes,
		&i.ValidPreparationID,
		&i.ValidPreparationName,
		&i.ValidPreparationDescription,
		&i.ValidPreparationIconPath,
		&i.ValidPreparationYieldsNothing,
		&i.ValidPreparationRestrictToIngredients,
		&i.ValidPreparationMinimumIngredientCount,
		&i.ValidPreparationMaximumIngredientCount,
		&i.ValidPreparationMinimumInstrumentCount,
		&i.ValidPreparationMaximumInstrumentCount,
		&i.ValidPreparationTemperatureRequired,
		&i.ValidPreparationTimeEstimateRequired,
		&i.ValidPreparationConditionExpressionRequired,
		&i.ValidPreparationConsumesVessel,
		&i.ValidPreparationOnlyForVessels,
		&i.ValidPreparationMinimumVesselCount,
		&i.ValidPreparationMaximumVesselCount,
		&i.ValidPreparationSlug,
		&i.ValidPreparationPastTense,
		&i.ValidPreparationCreatedAt,
		&i.ValidPreparationLastUpdatedAt,
		&i.ValidPreparationArchivedAt,
		&i.ValidVesselID,
		&i.ValidVesselName,
		&i.ValidVesselPluralName,
		&i.ValidVesselDescription,
		&i.ValidVesselIconPath,
		&i.ValidVesselUsableForStorage,
		&i.ValidVesselSlug,
		&i.ValidVesselDisplayInSummaryLists,
		&i.ValidVesselIncludeInGeneratedInstructions,
		&i.ValidVesselCapacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.ValidVesselWidthInMillimeters,
		&i.ValidVesselLengthInMillimeters,
		&i.ValidVesselHeightInMillimeters,
		&i.ValidVesselShape,
		&i.ValidVesselCreatedAt,
		&i.ValidVesselLastUpdatedAt,
		&i.ValidVesselArchivedAt,
		&i.ValidPreparationVesselCreatedAt,
		&i.ValidPreparationVesselLastUpdatedAt,
		&i.ValidPreparationVesselArchivedAt,
	)
	return &i, err
}

const getValidVessel = `-- name: GetValidVessel :one

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_vessels.id = $1
`

type GetValidVesselRow struct {
	ValidMeasurementUnitCreatedAt     time.Time
	CreatedAt                         time.Time
	ArchivedAt                        sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitIconPath      string
	IconPath                          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	ValidMeasurementUnitDescription   string
	Description                       string
	ID                                string
	Shape                             VesselShape
	Slug                              string
	ValidMeasurementUnitPluralName    string
	ValidMeasurementUnitSlug          string
	ValidVesselsWidthInMillimeters    float64
	ValidVesselsLengthInMillimeters   float64
	ValidVesselsHeightInMillimeters   float64
	ValidVesselsCapacity              float64
	ValidMeasurementUnitVolumetric    sql.NullBool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	UsableForStorage                  bool
	DisplayInSummaryLists             bool
	ValidMeasurementUnitUniversal     bool
	IncludeInGeneratedInstructions    bool
}

func (q *Queries) GetValidVessel(ctx context.Context, db DBTX, id string) (*GetValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getValidVessel, id)
	var i GetValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.ValidVesselsCapacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.ValidVesselsWidthInMillimeters,
		&i.ValidVesselsLengthInMillimeters,
		&i.ValidVesselsHeightInMillimeters,
		&i.Shape,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getWebhook = `-- name: GetWebhook :many

SELECT
	webhooks.id,
	webhooks.name,
	webhooks.content_type,
	webhooks.url,
	webhooks.method,
	webhook_trigger_events.id,
	webhook_trigger_events.trigger_event,
	webhook_trigger_events.belongs_to_webhook,
	webhook_trigger_events.created_at,
	webhook_trigger_events.archived_at,
	webhooks.created_at,
	webhooks.last_updated_at,
	webhooks.archived_at,
	webhooks.belongs_to_household
FROM webhook_trigger_events
 JOIN webhooks ON webhook_trigger_events.belongs_to_webhook=webhooks.id
WHERE webhooks.archived_at IS NULL
  AND webhook_trigger_events.archived_at IS NULL
  AND webhooks.belongs_to_household = $1
  AND webhooks.id = $2
`

type GetWebhookParams struct {
	BelongsToHousehold string
	ID                 string
}

type GetWebhookRow struct {
	ID                 string
	Name               string
	ContentType        string
	URL                string
	Method             string
	ID_2               string
	TriggerEvent       WebhookEvent
	BelongsToWebhook   string
	CreatedAt          time.Time
	ArchivedAt         sql.NullTime
	CreatedAt_2        time.Time
	LastUpdatedAt      sql.NullTime
	ArchivedAt_2       sql.NullTime
	BelongsToHousehold string
}

func (q *Queries) GetWebhook(ctx context.Context, db DBTX, arg *GetWebhookParams) ([]*GetWebhookRow, error) {
	rows, err := db.QueryContext(ctx, getWebhook, arg.BelongsToHousehold, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebhookRow{}
	for rows.Next() {
		var i GetWebhookRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentType,
			&i.URL,
			&i.Method,
			&i.ID_2,
			&i.TriggerEvent,
			&i.BelongsToWebhook,
			&i.CreatedAt,
			&i.ArchivedAt,
			&i.CreatedAt_2,
			&i.LastUpdatedAt,
			&i.ArchivedAt_2,
			&i.BelongsToHousehold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
