// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_one.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const GetHouseholdInstrumentOwnership = `-- name: GetHouseholdInstrumentOwnership :one

SELECT
	household_instrument_ownerships.id,
	household_instrument_ownerships.notes,
	household_instrument_ownerships.quantity,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	household_instrument_ownerships.belongs_to_household,
	household_instrument_ownerships.created_at,
	household_instrument_ownerships.last_updated_at,
	household_instrument_ownerships.archived_at
FROM household_instrument_ownerships
INNER JOIN valid_instruments ON household_instrument_ownerships.valid_instrument_id = valid_instruments.id
WHERE household_instrument_ownerships.archived_at IS NULL
	AND household_instrument_ownerships.id = $1
	AND household_instrument_ownerships.belongs_to_household = $2
`

type GetHouseholdInstrumentOwnershipParams struct {
	ID                 string `db:"id"`
	BelongsToHousehold string `db:"belongs_to_household"`
}

type GetHouseholdInstrumentOwnershipRow struct {
	CreatedAt                      time.Time    `db:"created_at"`
	CreatedAt_2                    time.Time    `db:"created_at_2"`
	ArchivedAt_2                   sql.NullTime `db:"archived_at_2"`
	LastUpdatedAt_2                sql.NullTime `db:"last_updated_at_2"`
	ArchivedAt                     sql.NullTime `db:"archived_at"`
	LastUpdatedAt                  sql.NullTime `db:"last_updated_at"`
	Name                           string       `db:"name"`
	IconPath                       string       `db:"icon_path"`
	Slug                           string       `db:"slug"`
	Description                    string       `db:"description"`
	PluralName                     string       `db:"plural_name"`
	ID                             string       `db:"id"`
	BelongsToHousehold             string       `db:"belongs_to_household"`
	ID_2                           string       `db:"id_2"`
	Notes                          string       `db:"notes"`
	Quantity                       int32        `db:"quantity"`
	UsableForStorage               bool         `db:"usable_for_storage"`
	DisplayInSummaryLists          bool         `db:"display_in_summary_lists"`
	IncludeInGeneratedInstructions bool         `db:"include_in_generated_instructions"`
}

func (q *Queries) GetHouseholdInstrumentOwnership(ctx context.Context, db DBTX, arg *GetHouseholdInstrumentOwnershipParams) (*GetHouseholdInstrumentOwnershipRow, error) {
	row := db.QueryRowContext(ctx, GetHouseholdInstrumentOwnership, arg.ID, arg.BelongsToHousehold)
	var i GetHouseholdInstrumentOwnershipRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.Quantity,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const GetMeal = `-- name: GetMeal :one

SELECT
	meals.id,
	meals.name,
	meals.description,
	meals.min_estimated_portions,
    meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
	meals.created_at,
	meals.last_updated_at,
	meals.archived_at,
	meals.created_by_user,
	meal_components.recipe_id,
	meal_components.recipe_scale,
	meal_components.meal_component_type
FROM meals
	FULL OUTER JOIN meal_components ON meal_components.meal_id=meals.id
WHERE meals.archived_at IS NULL
	AND meal_components.archived_at IS NULL
	AND meals.id = $1
`

type GetMealRow struct {
	CreatedAt            sql.NullTime      `db:"created_at"`
	ArchivedAt           sql.NullTime      `db:"archived_at"`
	LastUpdatedAt        sql.NullTime      `db:"last_updated_at"`
	MinEstimatedPortions sql.NullString    `db:"min_estimated_portions"`
	MaxEstimatedPortions sql.NullString    `db:"max_estimated_portions"`
	ID                   sql.NullString    `db:"id"`
	Description          sql.NullString    `db:"description"`
	Name                 sql.NullString    `db:"name"`
	CreatedByUser        sql.NullString    `db:"created_by_user"`
	RecipeID             sql.NullString    `db:"recipe_id"`
	RecipeScale          sql.NullString    `db:"recipe_scale"`
	MealComponentType    NullComponentType `db:"meal_component_type"`
	EligibleForMealPlans sql.NullBool      `db:"eligible_for_meal_plans"`
}

func (q *Queries) GetMeal(ctx context.Context, db DBTX, id string) (*GetMealRow, error) {
	row := db.QueryRowContext(ctx, GetMeal, id)
	var i GetMealRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.RecipeID,
		&i.RecipeScale,
		&i.MealComponentType,
	)
	return &i, err
}

const GetMealPlan = `-- name: GetMealPlan :one

SELECT
	meal_plans.id,
	meal_plans.notes,
	meal_plans.status,
	meal_plans.voting_deadline,
	meal_plans.grocery_list_initialized,
	meal_plans.tasks_created,
	meal_plans.election_method,
	meal_plans.created_at,
	meal_plans.last_updated_at,
	meal_plans.archived_at,
	meal_plans.belongs_to_household,
	meal_plans.created_by_user
FROM meal_plans
WHERE meal_plans.archived_at IS NULL
	AND meal_plans.id = $1
	AND meal_plans.belongs_to_household = $2
`

type GetMealPlanParams struct {
	ID                 string `db:"id"`
	BelongsToHousehold string `db:"belongs_to_household"`
}

type GetMealPlanRow struct {
	VotingDeadline         time.Time           `db:"voting_deadline"`
	CreatedAt              time.Time           `db:"created_at"`
	LastUpdatedAt          sql.NullTime        `db:"last_updated_at"`
	ArchivedAt             sql.NullTime        `db:"archived_at"`
	ID                     string              `db:"id"`
	Notes                  string              `db:"notes"`
	Status                 MealPlanStatus      `db:"status"`
	ElectionMethod         ValidElectionMethod `db:"election_method"`
	BelongsToHousehold     string              `db:"belongs_to_household"`
	CreatedByUser          string              `db:"created_by_user"`
	GroceryListInitialized bool                `db:"grocery_list_initialized"`
	TasksCreated           bool                `db:"tasks_created"`
}

func (q *Queries) GetMealPlan(ctx context.Context, db DBTX, arg *GetMealPlanParams) (*GetMealPlanRow, error) {
	row := db.QueryRowContext(ctx, GetMealPlan, arg.ID, arg.BelongsToHousehold)
	var i GetMealPlanRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.Status,
		&i.VotingDeadline,
		&i.GroceryListInitialized,
		&i.TasksCreated,
		&i.ElectionMethod,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToHousehold,
		&i.CreatedByUser,
	)
	return &i, err
}

const GetMealPlanEvent = `-- name: GetMealPlanEvent :one

SELECT
	meal_plan_events.id,
	meal_plan_events.notes,
	meal_plan_events.starts_at,
	meal_plan_events.ends_at,
	meal_plan_events.meal_name,
	meal_plan_events.belongs_to_meal_plan,
	meal_plan_events.created_at,
	meal_plan_events.last_updated_at,
	meal_plan_events.archived_at
FROM meal_plan_events
WHERE meal_plan_events.archived_at IS NULL
	AND meal_plan_events.id = $1
	AND meal_plan_events.belongs_to_meal_plan = $2
`

type GetMealPlanEventParams struct {
	ID                string `db:"id"`
	BelongsToMealPlan string `db:"belongs_to_meal_plan"`
}

func (q *Queries) GetMealPlanEvent(ctx context.Context, db DBTX, arg *GetMealPlanEventParams) (*MealPlanEvents, error) {
	row := db.QueryRowContext(ctx, GetMealPlanEvent, arg.ID, arg.BelongsToMealPlan)
	var i MealPlanEvents
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.StartsAt,
		&i.EndsAt,
		&i.MealName,
		&i.BelongsToMealPlan,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetMealPlanGroceryListItem = `-- name: GetMealPlanGroceryListItem :one

SELECT
	meal_plan_grocery_list_items.id,
	meal_plan_grocery_list_items.belongs_to_meal_plan,
	meal_plan_grocery_list_items.valid_ingredient,
	meal_plan_grocery_list_items.valid_measurement_unit,
	meal_plan_grocery_list_items.minimum_quantity_needed,
	meal_plan_grocery_list_items.maximum_quantity_needed,
	meal_plan_grocery_list_items.quantity_purchased,
	meal_plan_grocery_list_items.purchased_measurement_unit,
	meal_plan_grocery_list_items.purchased_upc,
	meal_plan_grocery_list_items.purchase_price,
	meal_plan_grocery_list_items.status_explanation,
	meal_plan_grocery_list_items.status,
	meal_plan_grocery_list_items.created_at,
	meal_plan_grocery_list_items.last_updated_at,
	meal_plan_grocery_list_items.archived_at
FROM meal_plan_grocery_list_items
	FULL OUTER JOIN meal_plans ON meal_plan_grocery_list_items.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_grocery_list_items.archived_at IS NULL
  AND meal_plan_grocery_list_items.id = $2
  AND meal_plan_grocery_list_items.belongs_to_meal_plan = $1
`

type GetMealPlanGroceryListItemParams struct {
	BelongsToMealPlan string `db:"belongs_to_meal_plan"`
	ID                string `db:"id"`
}

type GetMealPlanGroceryListItemRow struct {
	CreatedAt                sql.NullTime              `db:"created_at"`
	ArchivedAt               sql.NullTime              `db:"archived_at"`
	LastUpdatedAt            sql.NullTime              `db:"last_updated_at"`
	QuantityPurchased        sql.NullString            `db:"quantity_purchased"`
	MinimumQuantityNeeded    sql.NullString            `db:"minimum_quantity_needed"`
	MaximumQuantityNeeded    sql.NullString            `db:"maximum_quantity_needed"`
	ID                       sql.NullString            `db:"id"`
	PurchasedMeasurementUnit sql.NullString            `db:"purchased_measurement_unit"`
	PurchasedUpc             sql.NullString            `db:"purchased_upc"`
	PurchasePrice            sql.NullString            `db:"purchase_price"`
	StatusExplanation        sql.NullString            `db:"status_explanation"`
	Status                   NullGroceryListItemStatus `db:"status"`
	ValidMeasurementUnit     sql.NullString            `db:"valid_measurement_unit"`
	ValidIngredient          sql.NullString            `db:"valid_ingredient"`
	BelongsToMealPlan        sql.NullString            `db:"belongs_to_meal_plan"`
}

func (q *Queries) GetMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *GetMealPlanGroceryListItemParams) (*GetMealPlanGroceryListItemRow, error) {
	row := db.QueryRowContext(ctx, GetMealPlanGroceryListItem, arg.BelongsToMealPlan, arg.ID)
	var i GetMealPlanGroceryListItemRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToMealPlan,
		&i.ValidIngredient,
		&i.ValidMeasurementUnit,
		&i.MinimumQuantityNeeded,
		&i.MaximumQuantityNeeded,
		&i.QuantityPurchased,
		&i.PurchasedMeasurementUnit,
		&i.PurchasedUpc,
		&i.PurchasePrice,
		&i.StatusExplanation,
		&i.Status,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetMealPlanOption = `-- name: GetMealPlanOption :one

SELECT
	meal_plan_options.id,
	meal_plan_options.assigned_cook,
	meal_plan_options.assigned_dishwasher,
	meal_plan_options.chosen,
	meal_plan_options.tiebroken,
    meal_plan_options.meal_scale,
	meal_plan_options.meal_id,
	meal_plan_options.notes,
	meal_plan_options.created_at,
	meal_plan_options.last_updated_at,
	meal_plan_options.archived_at,
	meal_plan_options.belongs_to_meal_plan_event,
	meals.id,
	meals.name,
	meals.description,
	meals.min_estimated_portions,
	meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
	meals.created_at,
	meals.last_updated_at,
	meals.archived_at,
	meals.created_by_user
FROM meal_plan_options
	JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event = meal_plan_events.id
	JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan = meal_plans.id
	JOIN meals ON meal_plan_options.meal_id = meals.id
WHERE meal_plan_options.archived_at IS NULL
	AND meal_plan_options.belongs_to_meal_plan_event = $2
	AND meal_plan_options.id = $3
	AND meal_plan_events.id = $2
	AND meal_plan_events.belongs_to_meal_plan = $1
	AND meal_plans.archived_at IS NULL
	AND meal_plans.id = $1
`

type GetMealPlanOptionParams struct {
	BelongsToMealPlan      string         `db:"belongs_to_meal_plan"`
	ID                     string         `db:"id"`
	BelongsToMealPlanEvent sql.NullString `db:"belongs_to_meal_plan_event"`
}

type GetMealPlanOptionRow struct {
	CreatedAt              time.Time      `db:"created_at"`
	CreatedAt_2            time.Time      `db:"created_at_2"`
	ArchivedAt_2           sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt_2        sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt             sql.NullTime   `db:"archived_at"`
	LastUpdatedAt          sql.NullTime   `db:"last_updated_at"`
	MealScale              string         `db:"meal_scale"`
	MinEstimatedPortions   string         `db:"min_estimated_portions"`
	MealID                 string         `db:"meal_id"`
	ID                     string         `db:"id"`
	CreatedByUser          string         `db:"created_by_user"`
	Notes                  string         `db:"notes"`
	ID_2                   string         `db:"id_2"`
	Name                   string         `db:"name"`
	Description            string         `db:"description"`
	MaxEstimatedPortions   sql.NullString `db:"max_estimated_portions"`
	BelongsToMealPlanEvent sql.NullString `db:"belongs_to_meal_plan_event"`
	AssignedDishwasher     sql.NullString `db:"assigned_dishwasher"`
	AssignedCook           sql.NullString `db:"assigned_cook"`
	EligibleForMealPlans   bool           `db:"eligible_for_meal_plans"`
	Chosen                 bool           `db:"chosen"`
	Tiebroken              bool           `db:"tiebroken"`
}

func (q *Queries) GetMealPlanOption(ctx context.Context, db DBTX, arg *GetMealPlanOptionParams) (*GetMealPlanOptionRow, error) {
	row := db.QueryRowContext(ctx, GetMealPlanOption, arg.BelongsToMealPlan, arg.BelongsToMealPlanEvent, arg.ID)
	var i GetMealPlanOptionRow
	err := row.Scan(
		&i.ID,
		&i.AssignedCook,
		&i.AssignedDishwasher,
		&i.Chosen,
		&i.Tiebroken,
		&i.MealScale,
		&i.MealID,
		&i.Notes,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanEvent,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedByUser,
	)
	return &i, err
}

const GetMealPlanOptionVote = `-- name: GetMealPlanOptionVote :one


SELECT
	meal_plan_option_votes.id,
	meal_plan_option_votes.rank,
	meal_plan_option_votes.abstain,
	meal_plan_option_votes.notes,
	meal_plan_option_votes.by_user,
	meal_plan_option_votes.created_at,
	meal_plan_option_votes.last_updated_at,
	meal_plan_option_votes.archived_at,
	meal_plan_option_votes.belongs_to_meal_plan_option
FROM meal_plan_option_votes
	JOIN meal_plan_options ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id
	JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event=meal_plan_events.id
	JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_option_votes.archived_at IS NULL
	AND meal_plan_option_votes.belongs_to_meal_plan_option = $1
	AND meal_plan_option_votes.id = $2
	AND meal_plan_options.archived_at IS NULL
	AND meal_plan_options.belongs_to_meal_plan_event = $3
	AND meal_plan_events.archived_at IS NULL
	AND meal_plan_events.belongs_to_meal_plan = $4
	AND meal_plan_options.id = $1
	AND meal_plans.archived_at IS NULL
	AND meal_plans.id = $4
`

type GetMealPlanOptionVoteParams struct {
	BelongsToMealPlanOption string         `db:"belongs_to_meal_plan_option"`
	ID                      string         `db:"id"`
	BelongsToMealPlan       string         `db:"belongs_to_meal_plan"`
	BelongsToMealPlanEvent  sql.NullString `db:"belongs_to_meal_plan_event"`
}

func (q *Queries) GetMealPlanOptionVote(ctx context.Context, db DBTX, arg *GetMealPlanOptionVoteParams) (*MealPlanOptionVotes, error) {
	row := db.QueryRowContext(ctx, GetMealPlanOptionVote,
		arg.BelongsToMealPlanOption,
		arg.ID,
		arg.BelongsToMealPlanEvent,
		arg.BelongsToMealPlan,
	)
	var i MealPlanOptionVotes
	err := row.Scan(
		&i.ID,
		&i.Rank,
		&i.Abstain,
		&i.Notes,
		&i.ByUser,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanOption,
	)
	return &i, err
}

const GetMealPlanTask = `-- name: GetMealPlanTask :one

SELECT
	meal_plan_tasks.id,
	meal_plan_options.id,
	meal_plan_options.assigned_cook,
	meal_plan_options.assigned_dishwasher,
	meal_plan_options.chosen,
	meal_plan_options.tiebroken,
    meal_plan_options.meal_scale,
	meal_plan_options.meal_id,
	meal_plan_options.notes,
	meal_plan_options.created_at,
	meal_plan_options.last_updated_at,
	meal_plan_options.archived_at,
	meal_plan_options.belongs_to_meal_plan_event,
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_task_steps.id,
	recipe_prep_task_steps.belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step,
	meal_plan_tasks.created_at,
	meal_plan_tasks.last_updated_at,
	meal_plan_tasks.completed_at,
	meal_plan_tasks.status,
	meal_plan_tasks.creation_explanation,
	meal_plan_tasks.status_explanation,
	meal_plan_tasks.assigned_to_user
FROM meal_plan_tasks
	FULL OUTER JOIN meal_plan_options ON meal_plan_tasks.belongs_to_meal_plan_option=meal_plan_options.id
	FULL OUTER JOIN meal_plan_events ON meal_plan_options.belongs_to_meal_plan_event=meal_plan_events.id
	FULL OUTER JOIN meal_plans ON meal_plan_events.belongs_to_meal_plan=meal_plans.id
	FULL OUTER JOIN meals ON meal_plan_options.meal_id=meals.id
	JOIN recipe_prep_tasks ON meal_plan_tasks.belongs_to_recipe_prep_task=recipe_prep_tasks.id
	JOIN recipe_prep_task_steps ON recipe_prep_task_steps.belongs_to_recipe_prep_task=recipe_prep_tasks.id
	JOIN recipe_steps ON recipe_prep_task_steps.belongs_to_recipe_step=recipe_steps.id
WHERE meal_plan_options.archived_at IS NULL
	AND meal_plan_events.archived_at IS NULL
	AND meal_plans.archived_at IS NULL
	AND meals.archived_at IS NULL
	AND recipe_steps.archived_at IS NULL
	AND meal_plan_tasks.id = $1
`

type GetMealPlanTaskRow struct {
	CreatedAt_2                            time.Time                `db:"created_at_2"`
	ArchivedAt_2                           sql.NullTime             `db:"archived_at_2"`
	LastUpdatedAt                          sql.NullTime             `db:"last_updated_at"`
	CompletedAt                            sql.NullTime             `db:"completed_at"`
	LastUpdatedAt_3                        sql.NullTime             `db:"last_updated_at_3"`
	CreatedAt_3                            sql.NullTime             `db:"created_at_3"`
	LastUpdatedAt_2                        sql.NullTime             `db:"last_updated_at_2"`
	CreatedAt                              sql.NullTime             `db:"created_at"`
	ArchivedAt                             sql.NullTime             `db:"archived_at"`
	BelongsToRecipeStep                    string                   `db:"belongs_to_recipe_step"`
	ID_4                                   string                   `db:"id_4"`
	BelongsToRecipePrepTask                string                   `db:"belongs_to_recipe_prep_task"`
	BelongsToRecipe                        string                   `db:"belongs_to_recipe"`
	ID_3                                   string                   `db:"id_3"`
	Name                                   string                   `db:"name"`
	Description                            string                   `db:"description"`
	Notes_2                                string                   `db:"notes_2"`
	ExplicitStorageInstructions            string                   `db:"explicit_storage_instructions"`
	MinimumStorageTemperatureInCelsius     sql.NullString           `db:"minimum_storage_temperature_in_celsius"`
	ID_2                                   sql.NullString           `db:"id_2"`
	BelongsToMealPlanEvent                 sql.NullString           `db:"belongs_to_meal_plan_event"`
	CreationExplanation                    sql.NullString           `db:"creation_explanation"`
	AssignedDishwasher                     sql.NullString           `db:"assigned_dishwasher"`
	ID                                     sql.NullString           `db:"id"`
	MaximumStorageTemperatureInCelsius     sql.NullString           `db:"maximum_storage_temperature_in_celsius"`
	MealScale                              sql.NullString           `db:"meal_scale"`
	StatusExplanation                      sql.NullString           `db:"status_explanation"`
	MealID                                 sql.NullString           `db:"meal_id"`
	AssignedCook                           sql.NullString           `db:"assigned_cook"`
	Status                                 NullPrepStepStatus       `db:"status"`
	Notes                                  sql.NullString           `db:"notes"`
	AssignedToUser                         sql.NullString           `db:"assigned_to_user"`
	StorageType                            NullStorageContainerType `db:"storage_type"`
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32            `db:"maximum_time_buffer_before_recipe_in_seconds"`
	MinimumTimeBufferBeforeRecipeInSeconds int32                    `db:"minimum_time_buffer_before_recipe_in_seconds"`
	Chosen                                 sql.NullBool             `db:"chosen"`
	Tiebroken                              sql.NullBool             `db:"tiebroken"`
	Optional                               bool                     `db:"optional"`
	SatisfiesRecipeStep                    bool                     `db:"satisfies_recipe_step"`
}

func (q *Queries) GetMealPlanTask(ctx context.Context, db DBTX, id string) (*GetMealPlanTaskRow, error) {
	row := db.QueryRowContext(ctx, GetMealPlanTask, id)
	var i GetMealPlanTaskRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.AssignedCook,
		&i.AssignedDishwasher,
		&i.Chosen,
		&i.Tiebroken,
		&i.MealScale,
		&i.MealID,
		&i.Notes,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToMealPlanEvent,
		&i.ID_3,
		&i.Name,
		&i.Description,
		&i.Notes_2,
		&i.Optional,
		&i.ExplicitStorageInstructions,
		&i.MinimumTimeBufferBeforeRecipeInSeconds,
		&i.MaximumTimeBufferBeforeRecipeInSeconds,
		&i.StorageType,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.BelongsToRecipe,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.ID_4,
		&i.BelongsToRecipeStep,
		&i.BelongsToRecipePrepTask,
		&i.SatisfiesRecipeStep,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.CompletedAt,
		&i.Status,
		&i.CreationExplanation,
		&i.StatusExplanation,
		&i.AssignedToUser,
	)
	return &i, err
}

const GetPasswordResetToken = `-- name: GetPasswordResetToken :one

SELECT
	password_reset_tokens.id,
	password_reset_tokens.token,
	password_reset_tokens.expires_at,
	password_reset_tokens.created_at,
	password_reset_tokens.last_updated_at,
	password_reset_tokens.redeemed_at,
	password_reset_tokens.belongs_to_user
FROM password_reset_tokens
WHERE password_reset_tokens.redeemed_at IS NULL
	AND NOW() < password_reset_tokens.expires_at
	AND password_reset_tokens.token = $1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, db DBTX, token string) (*PasswordResetTokens, error) {
	row := db.QueryRowContext(ctx, GetPasswordResetToken, token)
	var i PasswordResetTokens
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.RedeemedAt,
		&i.BelongsToUser,
	)
	return &i, err
}

const GetRecipeMedia = `-- name: GetRecipeMedia :one

SELECT
	recipe_media.id,
	recipe_media.belongs_to_recipe,
	recipe_media.belongs_to_recipe_step,
	recipe_media.mime_type,
	recipe_media.internal_path,
	recipe_media.external_path,
	recipe_media.index,
	recipe_media.created_at,
	recipe_media.last_updated_at,
	recipe_media.archived_at
FROM recipe_media
WHERE recipe_media.archived_at IS NULL
	AND recipe_media.id = $1
`

type GetRecipeMediaRow struct {
	CreatedAt           time.Time      `db:"created_at"`
	LastUpdatedAt       sql.NullTime   `db:"last_updated_at"`
	ArchivedAt          sql.NullTime   `db:"archived_at"`
	ID                  string         `db:"id"`
	MimeType            string         `db:"mime_type"`
	InternalPath        string         `db:"internal_path"`
	ExternalPath        string         `db:"external_path"`
	BelongsToRecipe     sql.NullString `db:"belongs_to_recipe"`
	BelongsToRecipeStep sql.NullString `db:"belongs_to_recipe_step"`
	Index               int32          `db:"index"`
}

func (q *Queries) GetRecipeMedia(ctx context.Context, db DBTX, id string) (*GetRecipeMediaRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeMedia, id)
	var i GetRecipeMediaRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToRecipe,
		&i.BelongsToRecipeStep,
		&i.MimeType,
		&i.InternalPath,
		&i.ExternalPath,
		&i.Index,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetRecipePrepTask = `-- name: GetRecipePrepTask :one

SELECT
	recipe_prep_tasks.id,
	recipe_prep_tasks.name,
	recipe_prep_tasks.description,
	recipe_prep_tasks.notes,
	recipe_prep_tasks.optional,
	recipe_prep_tasks.explicit_storage_instructions,
	recipe_prep_tasks.minimum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.maximum_time_buffer_before_recipe_in_seconds,
	recipe_prep_tasks.storage_type,
	recipe_prep_tasks.minimum_storage_temperature_in_celsius,
	recipe_prep_tasks.maximum_storage_temperature_in_celsius,
	recipe_prep_tasks.belongs_to_recipe,
	recipe_prep_tasks.created_at,
	recipe_prep_tasks.last_updated_at,
	recipe_prep_tasks.archived_at,
	recipe_prep_task_steps.id,
	recipe_prep_task_steps.belongs_to_recipe_step,
	recipe_prep_task_steps.belongs_to_recipe_prep_task,
	recipe_prep_task_steps.satisfies_recipe_step
FROM recipe_prep_tasks
	 FULL OUTER JOIN recipe_prep_task_steps ON recipe_prep_tasks.id=recipe_prep_task_steps.belongs_to_recipe_prep_task
WHERE recipe_prep_tasks.archived_at IS NULL
	AND recipe_prep_tasks.id = $1
	AND recipe_prep_tasks.archived_at IS NULL
`

type GetRecipePrepTaskRow struct {
	CreatedAt                              sql.NullTime             `db:"created_at"`
	ArchivedAt                             sql.NullTime             `db:"archived_at"`
	LastUpdatedAt                          sql.NullTime             `db:"last_updated_at"`
	StorageType                            NullStorageContainerType `db:"storage_type"`
	Description                            sql.NullString           `db:"description"`
	ExplicitStorageInstructions            sql.NullString           `db:"explicit_storage_instructions"`
	BelongsToRecipePrepTask                sql.NullString           `db:"belongs_to_recipe_prep_task"`
	BelongsToRecipeStep                    sql.NullString           `db:"belongs_to_recipe_step"`
	ID                                     sql.NullString           `db:"id"`
	MinimumStorageTemperatureInCelsius     sql.NullString           `db:"minimum_storage_temperature_in_celsius"`
	MaximumStorageTemperatureInCelsius     sql.NullString           `db:"maximum_storage_temperature_in_celsius"`
	BelongsToRecipe                        sql.NullString           `db:"belongs_to_recipe"`
	Notes                                  sql.NullString           `db:"notes"`
	ID_2                                   sql.NullString           `db:"id_2"`
	Name                                   sql.NullString           `db:"name"`
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32            `db:"maximum_time_buffer_before_recipe_in_seconds"`
	MinimumTimeBufferBeforeRecipeInSeconds sql.NullInt32            `db:"minimum_time_buffer_before_recipe_in_seconds"`
	Optional                               sql.NullBool             `db:"optional"`
	SatisfiesRecipeStep                    sql.NullBool             `db:"satisfies_recipe_step"`
}

func (q *Queries) GetRecipePrepTask(ctx context.Context, db DBTX, id string) (*GetRecipePrepTaskRow, error) {
	row := db.QueryRowContext(ctx, GetRecipePrepTask, id)
	var i GetRecipePrepTaskRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Notes,
		&i.Optional,
		&i.ExplicitStorageInstructions,
		&i.MinimumTimeBufferBeforeRecipeInSeconds,
		&i.MaximumTimeBufferBeforeRecipeInSeconds,
		&i.StorageType,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.BelongsToRecipe,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_2,
		&i.BelongsToRecipeStep,
		&i.BelongsToRecipePrepTask,
		&i.SatisfiesRecipeStep,
	)
	return &i, err
}

const GetRecipeRating = `-- name: GetRecipeRating :one

SELECT
	recipe_ratings.id,
    recipe_ratings.recipe_id,
    recipe_ratings.taste,
    recipe_ratings.difficulty,
    recipe_ratings.cleanup,
    recipe_ratings.instructions,
    recipe_ratings.overall,
    recipe_ratings.notes,
    recipe_ratings.by_user,
    recipe_ratings.created_at,
    recipe_ratings.last_updated_at,
    recipe_ratings.archived_at
FROM recipe_ratings
WHERE recipe_ratings.archived_at IS NULL
	AND recipe_ratings.id = $1
`

func (q *Queries) GetRecipeRating(ctx context.Context, db DBTX, id string) (*RecipeRatings, error) {
	row := db.QueryRowContext(ctx, GetRecipeRating, id)
	var i RecipeRatings
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.Taste,
		&i.Difficulty,
		&i.Cleanup,
		&i.Instructions,
		&i.Overall,
		&i.Notes,
		&i.ByUser,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetRecipeStep = `-- name: GetRecipeStep :one

SELECT
	recipe_steps.id,
	recipe_steps.index,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	recipe_steps.minimum_estimated_time_in_seconds,
	recipe_steps.maximum_estimated_time_in_seconds,
	recipe_steps.minimum_temperature_in_celsius,
	recipe_steps.maximum_temperature_in_celsius,
	recipe_steps.notes,
	recipe_steps.explicit_instructions,
	recipe_steps.condition_expression,
	recipe_steps.optional,
	recipe_steps.start_timer_automatically,
	recipe_steps.created_at,
	recipe_steps.last_updated_at,
	recipe_steps.archived_at,
	recipe_steps.belongs_to_recipe
FROM recipe_steps
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_preparations ON recipe_steps.preparation_id=valid_preparations.id
WHERE recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipe_steps.id = $2
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepParams struct {
	BelongsToRecipe string `db:"belongs_to_recipe"`
	ID              string `db:"id"`
}

type GetRecipeStepRow struct {
	CreatedAt                     time.Time      `db:"created_at"`
	CreatedAt_2                   time.Time      `db:"created_at_2"`
	ArchivedAt_2                  sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt                 sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                    sql.NullTime   `db:"archived_at"`
	LastUpdatedAt_2               sql.NullTime   `db:"last_updated_at_2"`
	ConditionExpression           string         `db:"condition_expression"`
	ID_2                          string         `db:"id_2"`
	Description                   string         `db:"description"`
	ID                            string         `db:"id"`
	Name                          string         `db:"name"`
	ExplicitInstructions          string         `db:"explicit_instructions"`
	Notes                         string         `db:"notes"`
	IconPath                      string         `db:"icon_path"`
	PastTense                     string         `db:"past_tense"`
	Slug                          string         `db:"slug"`
	BelongsToRecipe               string         `db:"belongs_to_recipe"`
	MaximumTemperatureInCelsius   sql.NullString `db:"maximum_temperature_in_celsius"`
	MinimumTemperatureInCelsius   sql.NullString `db:"minimum_temperature_in_celsius"`
	MinimumEstimatedTimeInSeconds sql.NullInt64  `db:"minimum_estimated_time_in_seconds"`
	MaximumEstimatedTimeInSeconds sql.NullInt64  `db:"maximum_estimated_time_in_seconds"`
	MaximumIngredientCount        sql.NullInt32  `db:"maximum_ingredient_count"`
	MaximumVesselCount            sql.NullInt32  `db:"maximum_vessel_count"`
	MaximumInstrumentCount        sql.NullInt32  `db:"maximum_instrument_count"`
	MinimumVesselCount            int32          `db:"minimum_vessel_count"`
	Index                         int32          `db:"index"`
	MinimumIngredientCount        int32          `db:"minimum_ingredient_count"`
	MinimumInstrumentCount        int32          `db:"minimum_instrument_count"`
	TemperatureRequired           bool           `db:"temperature_required"`
	TimeEstimateRequired          bool           `db:"time_estimate_required"`
	ConditionExpressionRequired   bool           `db:"condition_expression_required"`
	Optional                      bool           `db:"optional"`
	StartTimerAutomatically       bool           `db:"start_timer_automatically"`
	ConsumesVessel                bool           `db:"consumes_vessel"`
	RestrictToIngredients         bool           `db:"restrict_to_ingredients"`
	YieldsNothing                 bool           `db:"yields_nothing"`
	OnlyForVessels                bool           `db:"only_for_vessels"`
}

func (q *Queries) GetRecipeStep(ctx context.Context, db DBTX, arg *GetRecipeStepParams) (*GetRecipeStepRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStep, arg.BelongsToRecipe, arg.ID)
	var i GetRecipeStepRow
	err := row.Scan(
		&i.ID,
		&i.Index,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.MinimumEstimatedTimeInSeconds,
		&i.MaximumEstimatedTimeInSeconds,
		&i.MinimumTemperatureInCelsius,
		&i.MaximumTemperatureInCelsius,
		&i.Notes,
		&i.ExplicitInstructions,
		&i.ConditionExpression,
		&i.Optional,
		&i.StartTimerAutomatically,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipe,
	)
	return &i, err
}

const GetRecipeStepCompletionCondition = `-- name: GetRecipeStepCompletionCondition :one

SELECT
	recipe_step_completion_condition_ingredients.id,
	recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition,
	recipe_step_completion_condition_ingredients.recipe_step_ingredient,
	recipe_step_completion_conditions.id,
	recipe_step_completion_conditions.belongs_to_recipe_step,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	recipe_step_completion_conditions.optional,
	recipe_step_completion_conditions.notes,
	recipe_step_completion_conditions.created_at,
	recipe_step_completion_conditions.last_updated_at,
	recipe_step_completion_conditions.archived_at
FROM recipe_step_completion_condition_ingredients
	     JOIN recipe_step_completion_conditions ON recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition = recipe_step_completion_conditions.id
	     JOIN recipe_steps ON recipe_step_completion_conditions.belongs_to_recipe_step = recipe_steps.id
	     JOIN recipes ON recipe_steps.belongs_to_recipe = recipes.id
	     JOIN valid_ingredient_states ON recipe_step_completion_conditions.ingredient_state = valid_ingredient_states.id
WHERE recipe_step_completion_conditions.archived_at IS NULL
	AND recipe_step_completion_condition_ingredients.archived_at IS NULL
	AND recipe_step_completion_conditions.belongs_to_recipe_step = $2
	AND recipe_step_completion_conditions.id = $3
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipe_steps.id = $2
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepCompletionConditionParams struct {
	BelongsToRecipe     string `db:"belongs_to_recipe"`
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	ID                  string `db:"id"`
}

type GetRecipeStepCompletionConditionRow struct {
	CreatedAt                              time.Time               `db:"created_at"`
	CreatedAt_2                            time.Time               `db:"created_at_2"`
	ArchivedAt_2                           sql.NullTime            `db:"archived_at_2"`
	LastUpdatedAt_2                        sql.NullTime            `db:"last_updated_at_2"`
	ArchivedAt                             sql.NullTime            `db:"archived_at"`
	LastUpdatedAt                          sql.NullTime            `db:"last_updated_at"`
	PastTense                              string                  `db:"past_tense"`
	ID_3                                   string                  `db:"id_3"`
	IconPath                               string                  `db:"icon_path"`
	Slug                                   string                  `db:"slug"`
	ID                                     string                  `db:"id"`
	AttributeType                          IngredientAttributeType `db:"attribute_type"`
	Name                                   string                  `db:"name"`
	Description                            string                  `db:"description"`
	BelongsToRecipeStep                    string                  `db:"belongs_to_recipe_step"`
	BelongsToRecipeStepCompletionCondition string                  `db:"belongs_to_recipe_step_completion_condition"`
	Notes                                  string                  `db:"notes"`
	ID_2                                   string                  `db:"id_2"`
	RecipeStepIngredient                   string                  `db:"recipe_step_ingredient"`
	Optional                               bool                    `db:"optional"`
}

func (q *Queries) GetRecipeStepCompletionCondition(ctx context.Context, db DBTX, arg *GetRecipeStepCompletionConditionParams) (*GetRecipeStepCompletionConditionRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStepCompletionCondition, arg.BelongsToRecipe, arg.BelongsToRecipeStep, arg.ID)
	var i GetRecipeStepCompletionConditionRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToRecipeStepCompletionCondition,
		&i.RecipeStepIngredient,
		&i.ID_2,
		&i.BelongsToRecipeStep,
		&i.ID_3,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.Optional,
		&i.Notes,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const GetRecipeStepIngredient = `-- name: GetRecipeStepIngredient :one

SELECT
	recipe_step_ingredients.id,
	recipe_step_ingredients.name,
	recipe_step_ingredients.optional,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	recipe_step_ingredients.minimum_quantity_value,
	recipe_step_ingredients.maximum_quantity_value,
	recipe_step_ingredients.quantity_notes,
	recipe_step_ingredients.recipe_step_product_id,
	recipe_step_ingredients.ingredient_notes,
	recipe_step_ingredients.option_index,
	recipe_step_ingredients.to_taste,
	recipe_step_ingredients.product_percentage_to_use,
    recipe_step_ingredients.vessel_index,
    recipe_step_ingredients.recipe_step_product_recipe_id,
	recipe_step_ingredients.created_at,
	recipe_step_ingredients.last_updated_at,
	recipe_step_ingredients.archived_at,
	recipe_step_ingredients.belongs_to_recipe_step
FROM recipe_step_ingredients
	 JOIN recipe_steps ON recipe_step_ingredients.belongs_to_recipe_step=recipe_steps.id
	 JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	 JOIN valid_ingredients ON recipe_step_ingredients.ingredient_id=valid_ingredients.id
	 JOIN valid_measurement_units ON recipe_step_ingredients.measurement_unit=valid_measurement_units.id
WHERE recipe_step_ingredients.archived_at IS NULL
	AND recipe_step_ingredients.belongs_to_recipe_step = $1
	AND recipe_step_ingredients.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepIngredientParams struct {
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	ID                  string `db:"id"`
	BelongsToRecipe     string `db:"belongs_to_recipe"`
	ID_2                string `db:"id_2"`
	ID_3                string `db:"id_3"`
}

type GetRecipeStepIngredientRow struct {
	CreatedAt_3                             time.Time      `db:"created_at_3"`
	CreatedAt                               time.Time      `db:"created_at"`
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	LastUpdatedAt_3                         sql.NullTime   `db:"last_updated_at_3"`
	IconPath                                string         `db:"icon_path"`
	PluralName_2                            string         `db:"plural_name_2"`
	Name                                    string         `db:"name"`
	BelongsToRecipeStep                     string         `db:"belongs_to_recipe_step"`
	ID_3                                    string         `db:"id_3"`
	IngredientNotes                         string         `db:"ingredient_notes"`
	Name_3                                  string         `db:"name_3"`
	QuantityNotes                           string         `db:"quantity_notes"`
	ID                                      string         `db:"id"`
	Description_2                           string         `db:"description_2"`
	IconPath_2                              string         `db:"icon_path_2"`
	Warning                                 string         `db:"warning"`
	MinimumQuantityValue                    string         `db:"minimum_quantity_value"`
	PluralName                              string         `db:"plural_name"`
	Description                             string         `db:"description"`
	Slug_2                                  string         `db:"slug_2"`
	ID_2                                    string         `db:"id_2"`
	StorageInstructions                     string         `db:"storage_instructions"`
	Slug                                    string         `db:"slug"`
	Name_2                                  string         `db:"name_2"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	RecipeStepProductRecipeID               sql.NullString `db:"recipe_step_product_recipe_id"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	MaximumQuantityValue                    sql.NullString `db:"maximum_quantity_value"`
	RecipeStepProductID                     sql.NullString `db:"recipe_step_product_id"`
	ProductPercentageToUse                  sql.NullString `db:"product_percentage_to_use"`
	VesselIndex                             sql.NullInt32  `db:"vessel_index"`
	OptionIndex                             int32          `db:"option_index"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	Volumetric_2                            sql.NullBool   `db:"volumetric_2"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	IsHeat                                  bool           `db:"is_heat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsFat                                   bool           `db:"is_fat"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFruit                                 bool           `db:"is_fruit"`
	Universal                               bool           `db:"universal"`
	Metric                                  bool           `db:"metric"`
	Imperial                                bool           `db:"imperial"`
	IsGrain                                 bool           `db:"is_grain"`
	IsProtein                               bool           `db:"is_protein"`
	IsStarch                                bool           `db:"is_starch"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	AnimalDerived                           bool           `db:"animal_derived"`
	Volumetric                              bool           `db:"volumetric"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ToTaste                                 bool           `db:"to_taste"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
	Optional                                bool           `db:"optional"`
}

func (q *Queries) GetRecipeStepIngredient(ctx context.Context, db DBTX, arg *GetRecipeStepIngredientParams) (*GetRecipeStepIngredientRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStepIngredient,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Optional,
		&i.ID_2,
		&i.Name_2,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_3,
		&i.Description_2,
		&i.Volumetric_2,
		&i.IconPath_2,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.RecipeStepProductID,
		&i.IngredientNotes,
		&i.OptionIndex,
		&i.ToTaste,
		&i.ProductPercentageToUse,
		&i.VesselIndex,
		&i.RecipeStepProductRecipeID,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const GetRecipeStepInstrument = `-- name: GetRecipeStepInstrument :one

SELECT
	recipe_step_instruments.id,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
    valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	recipe_step_instruments.recipe_step_product_id,
	recipe_step_instruments.name,
	recipe_step_instruments.notes,
	recipe_step_instruments.preference_rank,
	recipe_step_instruments.optional,
	recipe_step_instruments.minimum_quantity,
	recipe_step_instruments.maximum_quantity,
	recipe_step_instruments.option_index,
	recipe_step_instruments.created_at,
	recipe_step_instruments.last_updated_at,
	recipe_step_instruments.archived_at,
	recipe_step_instruments.belongs_to_recipe_step
FROM recipe_step_instruments
	LEFT JOIN valid_instruments ON recipe_step_instruments.instrument_id=valid_instruments.id
	JOIN recipe_steps ON recipe_step_instruments.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_instruments.archived_at IS NULL
	AND recipe_step_instruments.belongs_to_recipe_step = $1
	AND recipe_step_instruments.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepInstrumentParams struct {
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	ID                  string `db:"id"`
	BelongsToRecipe     string `db:"belongs_to_recipe"`
	ID_2                string `db:"id_2"`
	ID_3                string `db:"id_3"`
}

type GetRecipeStepInstrumentRow struct {
	CreatedAt_2                    time.Time      `db:"created_at_2"`
	ArchivedAt                     sql.NullTime   `db:"archived_at"`
	ArchivedAt_2                   sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt_2                sql.NullTime   `db:"last_updated_at_2"`
	LastUpdatedAt                  sql.NullTime   `db:"last_updated_at"`
	CreatedAt                      sql.NullTime   `db:"created_at"`
	Name_2                         string         `db:"name_2"`
	BelongsToRecipeStep            string         `db:"belongs_to_recipe_step"`
	ID                             string         `db:"id"`
	Notes                          string         `db:"notes"`
	Description                    sql.NullString `db:"description"`
	PluralName                     sql.NullString `db:"plural_name"`
	IconPath                       sql.NullString `db:"icon_path"`
	Slug                           sql.NullString `db:"slug"`
	RecipeStepProductID            sql.NullString `db:"recipe_step_product_id"`
	Name                           sql.NullString `db:"name"`
	ID_2                           sql.NullString `db:"id_2"`
	MaximumQuantity                sql.NullInt32  `db:"maximum_quantity"`
	MinimumQuantity                int32          `db:"minimum_quantity"`
	OptionIndex                    int32          `db:"option_index"`
	PreferenceRank                 int32          `db:"preference_rank"`
	IncludeInGeneratedInstructions sql.NullBool   `db:"include_in_generated_instructions"`
	DisplayInSummaryLists          sql.NullBool   `db:"display_in_summary_lists"`
	UsableForStorage               sql.NullBool   `db:"usable_for_storage"`
	Optional                       bool           `db:"optional"`
}

func (q *Queries) GetRecipeStepInstrument(ctx context.Context, db DBTX, arg *GetRecipeStepInstrumentParams) (*GetRecipeStepInstrumentRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStepInstrument,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.RecipeStepProductID,
		&i.Name_2,
		&i.Notes,
		&i.PreferenceRank,
		&i.Optional,
		&i.MinimumQuantity,
		&i.MaximumQuantity,
		&i.OptionIndex,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const GetRecipeStepProduct = `-- name: GetRecipeStepProduct :one

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_step_products.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepProductParams struct {
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	ID                  string `db:"id"`
	BelongsToRecipe     string `db:"belongs_to_recipe"`
	ID_2                string `db:"id_2"`
	ID_3                string `db:"id_3"`
}

type GetRecipeStepProductRow struct {
	CreatedAt_2                        time.Time             `db:"created_at_2"`
	CreatedAt                          time.Time             `db:"created_at"`
	ArchivedAt_2                       sql.NullTime          `db:"archived_at_2"`
	LastUpdatedAt_2                    sql.NullTime          `db:"last_updated_at_2"`
	ArchivedAt                         sql.NullTime          `db:"archived_at"`
	LastUpdatedAt                      sql.NullTime          `db:"last_updated_at"`
	QuantityNotes                      string                `db:"quantity_notes"`
	ID_2                               string                `db:"id_2"`
	ID                                 string                `db:"id"`
	BelongsToRecipeStep                string                `db:"belongs_to_recipe_step"`
	Name                               string                `db:"name"`
	Slug                               string                `db:"slug"`
	PluralName                         string                `db:"plural_name"`
	Description                        string                `db:"description"`
	Name_2                             string                `db:"name_2"`
	IconPath                           string                `db:"icon_path"`
	StorageInstructions                string                `db:"storage_instructions"`
	Type                               RecipeStepProductType `db:"type"`
	MaximumQuantityValue               sql.NullString        `db:"maximum_quantity_value"`
	MinimumStorageTemperatureInCelsius sql.NullString        `db:"minimum_storage_temperature_in_celsius"`
	MaximumStorageTemperatureInCelsius sql.NullString        `db:"maximum_storage_temperature_in_celsius"`
	MinimumQuantityValue               sql.NullString        `db:"minimum_quantity_value"`
	MaximumStorageDurationInSeconds    sql.NullInt32         `db:"maximum_storage_duration_in_seconds"`
	ContainedInVesselIndex             sql.NullInt32         `db:"contained_in_vessel_index"`
	Index                              int32                 `db:"index"`
	Volumetric                         sql.NullBool          `db:"volumetric"`
	Universal                          bool                  `db:"universal"`
	IsWaste                            bool                  `db:"is_waste"`
	IsLiquid                           bool                  `db:"is_liquid"`
	Compostable                        bool                  `db:"compostable"`
	Imperial                           bool                  `db:"imperial"`
	Metric                             bool                  `db:"metric"`
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, db DBTX, arg *GetRecipeStepProductParams) (*GetRecipeStepProductRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStepProduct,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ID_2,
		&i.Name_2,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.Compostable,
		&i.MaximumStorageDurationInSeconds,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.IsLiquid,
		&i.IsWaste,
		&i.Index,
		&i.ContainedInVesselIndex,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const GetRecipeStepVessel = `-- name: GetRecipeStepVessel :one

SELECT
    recipe_step_vessels.id,
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
    valid_vessels.width_in_millimeters,
    valid_vessels.length_in_millimeters,
    valid_vessels.height_in_millimeters,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at,
    recipe_step_vessels.name,
    recipe_step_vessels.notes,
    recipe_step_vessels.belongs_to_recipe_step,
    recipe_step_vessels.recipe_step_product_id,
    recipe_step_vessels.vessel_predicate,
    recipe_step_vessels.minimum_quantity,
    recipe_step_vessels.maximum_quantity,
    recipe_step_vessels.unavailable_after_step,
    recipe_step_vessels.created_at,
    recipe_step_vessels.last_updated_at,
    recipe_step_vessels.archived_at
FROM recipe_step_vessels
	LEFT JOIN valid_vessels ON recipe_step_vessels.valid_vessel_id=valid_vessels.id
    LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
	JOIN recipe_steps ON recipe_step_vessels.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_vessels.archived_at IS NULL
	AND recipe_step_vessels.belongs_to_recipe_step = $1
	AND recipe_step_vessels.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $4
	AND recipes.archived_at IS NULL
	AND recipes.id = $5
`

type GetRecipeStepVesselParams struct {
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	ID                  string `db:"id"`
	BelongsToRecipe     string `db:"belongs_to_recipe"`
	ID_2                string `db:"id_2"`
	ID_3                string `db:"id_3"`
}

type GetRecipeStepVesselRow struct {
	CreatedAt_3                    time.Time       `db:"created_at_3"`
	LastUpdatedAt_2                sql.NullTime    `db:"last_updated_at_2"`
	LastUpdatedAt_3                sql.NullTime    `db:"last_updated_at_3"`
	ArchivedAt_3                   sql.NullTime    `db:"archived_at_3"`
	ArchivedAt_2                   sql.NullTime    `db:"archived_at_2"`
	CreatedAt                      sql.NullTime    `db:"created_at"`
	CreatedAt_2                    sql.NullTime    `db:"created_at_2"`
	ArchivedAt                     sql.NullTime    `db:"archived_at"`
	LastUpdatedAt                  sql.NullTime    `db:"last_updated_at"`
	VesselPredicate                string          `db:"vessel_predicate"`
	BelongsToRecipeStep            string          `db:"belongs_to_recipe_step"`
	Notes                          string          `db:"notes"`
	Name_3                         string          `db:"name_3"`
	ID                             string          `db:"id"`
	Capacity                       sql.NullString  `db:"capacity"`
	IconPath                       sql.NullString  `db:"icon_path"`
	ID_2                           sql.NullString  `db:"id_2"`
	Name                           sql.NullString  `db:"name"`
	PluralName                     sql.NullString  `db:"plural_name"`
	Slug_2                         sql.NullString  `db:"slug_2"`
	PluralName_2                   sql.NullString  `db:"plural_name_2"`
	Description                    sql.NullString  `db:"description"`
	Description_2                  sql.NullString  `db:"description_2"`
	Name_2                         sql.NullString  `db:"name_2"`
	WidthInMillimeters             sql.NullString  `db:"width_in_millimeters"`
	LengthInMillimeters            sql.NullString  `db:"length_in_millimeters"`
	HeightInMillimeters            sql.NullString  `db:"height_in_millimeters"`
	Shape                          NullVesselShape `db:"shape"`
	ID_3                           sql.NullString  `db:"id_3"`
	RecipeStepProductID            sql.NullString  `db:"recipe_step_product_id"`
	IconPath_2                     sql.NullString  `db:"icon_path_2"`
	Slug                           sql.NullString  `db:"slug"`
	MaximumQuantity                sql.NullInt32   `db:"maximum_quantity"`
	MinimumQuantity                int32           `db:"minimum_quantity"`
	UsableForStorage               sql.NullBool    `db:"usable_for_storage"`
	DisplayInSummaryLists          sql.NullBool    `db:"display_in_summary_lists"`
	IncludeInGeneratedInstructions sql.NullBool    `db:"include_in_generated_instructions"`
	Volumetric                     sql.NullBool    `db:"volumetric"`
	Imperial                       sql.NullBool    `db:"imperial"`
	Metric                         sql.NullBool    `db:"metric"`
	Universal                      sql.NullBool    `db:"universal"`
	UnavailableAfterStep           bool            `db:"unavailable_after_step"`
}

func (q *Queries) GetRecipeStepVessel(ctx context.Context, db DBTX, arg *GetRecipeStepVesselParams) (*GetRecipeStepVesselRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeStepVessel,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var i GetRecipeStepVesselRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Volumetric,
		&i.IconPath_2,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.Name_3,
		&i.Notes,
		&i.BelongsToRecipeStep,
		&i.RecipeStepProductID,
		&i.VesselPredicate,
		&i.MinimumQuantity,
		&i.MaximumQuantity,
		&i.UnavailableAfterStep,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const GetServiceSetting = `-- name: GetServiceSetting :one

SELECT
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.admins_only,
    service_settings.enumeration,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at
FROM service_settings
WHERE service_settings.archived_at IS NULL
	AND service_settings.id = $1
`

type GetServiceSettingRow struct {
	CreatedAt     time.Time      `db:"created_at"`
	LastUpdatedAt sql.NullTime   `db:"last_updated_at"`
	ArchivedAt    sql.NullTime   `db:"archived_at"`
	ID            string         `db:"id"`
	Name          string         `db:"name"`
	Type          SettingType    `db:"type"`
	Description   string         `db:"description"`
	Enumeration   string         `db:"enumeration"`
	DefaultValue  sql.NullString `db:"default_value"`
	AdminsOnly    bool           `db:"admins_only"`
}

func (q *Queries) GetServiceSetting(ctx context.Context, db DBTX, id string) (*GetServiceSettingRow, error) {
	row := db.QueryRowContext(ctx, GetServiceSetting, id)
	var i GetServiceSettingRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.AdminsOnly,
		&i.Enumeration,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidIngredient = `-- name: GetValidIngredient :one

SELECT
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at
FROM valid_ingredients
WHERE valid_ingredients.archived_at IS NULL
AND valid_ingredients.id = $1
`

type GetValidIngredientRow struct {
	CreatedAt                               time.Time      `db:"created_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	Warning                                 string         `db:"warning"`
	Description                             string         `db:"description"`
	Name                                    string         `db:"name"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	Slug                                    string         `db:"slug"`
	StorageInstructions                     string         `db:"storage_instructions"`
	PluralName                              string         `db:"plural_name"`
	ID                                      string         `db:"id"`
	IconPath                                string         `db:"icon_path"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	AnimalDerived                           bool           `db:"animal_derived"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	Volumetric                              bool           `db:"volumetric"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
}

func (q *Queries) GetValidIngredient(ctx context.Context, db DBTX, id string) (*GetValidIngredientRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredient, id)
	var i GetValidIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidIngredientGroup = `-- name: GetValidIngredientGroup :many

SELECT
	valid_ingredient_groups.id,
	valid_ingredient_groups.name,
	valid_ingredient_groups.description,
	valid_ingredient_groups.slug,
	valid_ingredient_groups.created_at,
	valid_ingredient_groups.last_updated_at,
	valid_ingredient_groups.archived_at,
	valid_ingredient_group_members.id,
    valid_ingredient_group_members.belongs_to_group,
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at,
    valid_ingredient_group_members.created_at,
    valid_ingredient_group_members.archived_at
FROM valid_ingredient_group_members
 JOIN valid_ingredient_groups ON valid_ingredient_group_members.belongs_to_group=valid_ingredient_groups.id
  JOIN valid_ingredients ON valid_ingredients.id = valid_ingredient_group_members.valid_ingredient
WHERE valid_ingredient_groups.archived_at IS NULL
AND valid_ingredient_group_members.archived_at IS NULL
AND valid_ingredient_groups.id = $1
`

type GetValidIngredientGroupRow struct {
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	CreatedAt                               time.Time      `db:"created_at"`
	CreatedAt_3                             time.Time      `db:"created_at_3"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	Warning                                 string         `db:"warning"`
	Name                                    string         `db:"name"`
	Name_2                                  string         `db:"name_2"`
	Description_2                           string         `db:"description_2"`
	IconPath                                string         `db:"icon_path"`
	BelongsToGroup                          string         `db:"belongs_to_group"`
	ID_2                                    string         `db:"id_2"`
	Slug                                    string         `db:"slug"`
	Description                             string         `db:"description"`
	ID_3                                    string         `db:"id_3"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	Slug_2                                  string         `db:"slug_2"`
	StorageInstructions                     string         `db:"storage_instructions"`
	ID                                      string         `db:"id"`
	PluralName                              string         `db:"plural_name"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	Volumetric                              bool           `db:"volumetric"`
	AnimalDerived                           bool           `db:"animal_derived"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
}

func (q *Queries) GetValidIngredientGroup(ctx context.Context, db DBTX, id string) ([]*GetValidIngredientGroupRow, error) {
	rows, err := db.QueryContext(ctx, GetValidIngredientGroup, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientGroupRow{}
	for rows.Next() {
		var i GetValidIngredientGroupRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.ID_2,
			&i.BelongsToGroup,
			&i.ID_3,
			&i.Name_2,
			&i.Description_2,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug_2,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.CreatedAt_3,
			&i.ArchivedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetValidIngredientMeasurementUnit = `-- name: GetValidIngredientMeasurementUnit :one

SELECT
	valid_ingredient_measurement_units.id,
	valid_ingredient_measurement_units.notes,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_measurement_units.minimum_allowable_quantity,
	valid_ingredient_measurement_units.maximum_allowable_quantity,
	valid_ingredient_measurement_units.created_at,
	valid_ingredient_measurement_units.last_updated_at,
	valid_ingredient_measurement_units.archived_at
FROM valid_ingredient_measurement_units
	JOIN valid_measurement_units ON valid_ingredient_measurement_units.valid_measurement_unit_id = valid_measurement_units.id
	JOIN valid_ingredients ON valid_ingredient_measurement_units.valid_ingredient_id = valid_ingredients.id
WHERE valid_ingredient_measurement_units.archived_at IS NULL
	AND valid_ingredient_measurement_units.id = $1
`

type GetValidIngredientMeasurementUnitRow struct {
	CreatedAt                               time.Time      `db:"created_at"`
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	CreatedAt_3                             time.Time      `db:"created_at_3"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt_3                         sql.NullTime   `db:"last_updated_at_3"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	Slug                                    string         `db:"slug"`
	Slug_2                                  string         `db:"slug_2"`
	ID_3                                    string         `db:"id_3"`
	Name_2                                  string         `db:"name_2"`
	Description_2                           string         `db:"description_2"`
	Warning                                 string         `db:"warning"`
	PluralName_2                            string         `db:"plural_name_2"`
	IconPath_2                              string         `db:"icon_path_2"`
	IconPath                                string         `db:"icon_path"`
	Description                             string         `db:"description"`
	ID                                      string         `db:"id"`
	MinimumAllowableQuantity                string         `db:"minimum_allowable_quantity"`
	Name                                    string         `db:"name"`
	ID_2                                    string         `db:"id_2"`
	Notes                                   string         `db:"notes"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	PluralName                              string         `db:"plural_name"`
	StorageInstructions                     string         `db:"storage_instructions"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MaximumAllowableQuantity                sql.NullString `db:"maximum_allowable_quantity"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	Volumetric                              sql.NullBool   `db:"volumetric"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	AnimalDerived                           bool           `db:"animal_derived"`
	Volumetric_2                            bool           `db:"volumetric_2"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
	Imperial                                bool           `db:"imperial"`
	Metric                                  bool           `db:"metric"`
	Universal                               bool           `db:"universal"`
}

func (q *Queries) GetValidIngredientMeasurementUnit(ctx context.Context, db DBTX, id string) (*GetValidIngredientMeasurementUnitRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredientMeasurementUnit, id)
	var i GetValidIngredientMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric_2,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName_2,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumAllowableQuantity,
		&i.MaximumAllowableQuantity,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const GetValidIngredientPreparation = `-- name: GetValidIngredientPreparation :one

SELECT
	valid_ingredient_preparations.id,
	valid_ingredient_preparations.notes,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_preparations.created_at,
	valid_ingredient_preparations.last_updated_at,
	valid_ingredient_preparations.archived_at
FROM valid_ingredient_preparations
	JOIN valid_ingredients ON valid_ingredient_preparations.valid_ingredient_id = valid_ingredients.id
	JOIN valid_preparations ON valid_ingredient_preparations.valid_preparation_id = valid_preparations.id
WHERE valid_ingredient_preparations.archived_at IS NULL
	AND valid_ingredient_preparations.id = $1
`

type GetValidIngredientPreparationRow struct {
	CreatedAt_3                             time.Time      `db:"created_at_3"`
	CreatedAt                               time.Time      `db:"created_at"`
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	LastUpdatedAt_3                         sql.NullTime   `db:"last_updated_at_3"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	ID_3                                    string         `db:"id_3"`
	ID_2                                    string         `db:"id_2"`
	IconPath_2                              string         `db:"icon_path_2"`
	PluralName                              string         `db:"plural_name"`
	StorageInstructions                     string         `db:"storage_instructions"`
	IconPath                                string         `db:"icon_path"`
	ID                                      string         `db:"id"`
	Description                             string         `db:"description"`
	Slug_2                                  string         `db:"slug_2"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	Slug                                    string         `db:"slug"`
	PastTense                               string         `db:"past_tense"`
	Name                                    string         `db:"name"`
	Warning                                 string         `db:"warning"`
	Notes                                   string         `db:"notes"`
	Description_2                           string         `db:"description_2"`
	Name_2                                  string         `db:"name_2"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	MaximumVesselCount                      sql.NullInt32  `db:"maximum_vessel_count"`
	MaximumIngredientCount                  sql.NullInt32  `db:"maximum_ingredient_count"`
	MaximumInstrumentCount                  sql.NullInt32  `db:"maximum_instrument_count"`
	MinimumInstrumentCount                  int32          `db:"minimum_instrument_count"`
	MinimumVesselCount                      int32          `db:"minimum_vessel_count"`
	MinimumIngredientCount                  int32          `db:"minimum_ingredient_count"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	ConsumesVessel                          bool           `db:"consumes_vessel"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	Volumetric                              bool           `db:"volumetric"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	AnimalDerived                           bool           `db:"animal_derived"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsEgg                             bool           `db:"contains_egg"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	OnlyForVessels                          bool           `db:"only_for_vessels"`
	ConditionExpressionRequired             bool           `db:"condition_expression_required"`
	TimeEstimateRequired                    bool           `db:"time_estimate_required"`
	TemperatureRequired                     bool           `db:"temperature_required"`
	RestrictToIngredients                   bool           `db:"restrict_to_ingredients"`
	YieldsNothing                           bool           `db:"yields_nothing"`
}

func (q *Queries) GetValidIngredientPreparation(ctx context.Context, db DBTX, id string) (*GetValidIngredientPreparationRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredientPreparation, id)
	var i GetValidIngredientPreparationRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const GetValidIngredientState = `-- name: GetValidIngredientState :one

SELECT
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at
FROM valid_ingredient_states
WHERE valid_ingredient_states.archived_at IS NULL
	AND valid_ingredient_states.id = $1
`

type GetValidIngredientStateRow struct {
	ID            string                  `db:"id"`
	Name          string                  `db:"name"`
	Description   string                  `db:"description"`
	IconPath      string                  `db:"icon_path"`
	Slug          string                  `db:"slug"`
	PastTense     string                  `db:"past_tense"`
	AttributeType IngredientAttributeType `db:"attribute_type"`
	CreatedAt     time.Time               `db:"created_at"`
	LastUpdatedAt sql.NullTime            `db:"last_updated_at"`
	ArchivedAt    sql.NullTime            `db:"archived_at"`
}

func (q *Queries) GetValidIngredientState(ctx context.Context, db DBTX, id string) (*GetValidIngredientStateRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredientState, id)
	var i GetValidIngredientStateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidIngredientStateIngredient = `-- name: GetValidIngredientStateIngredient :one

SELECT
	valid_ingredient_state_ingredients.id,
	valid_ingredient_state_ingredients.notes,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_ingredient_state_ingredients.created_at,
	valid_ingredient_state_ingredients.last_updated_at,
	valid_ingredient_state_ingredients.archived_at
FROM valid_ingredient_state_ingredients
	JOIN valid_ingredients ON valid_ingredient_state_ingredients.valid_ingredient = valid_ingredients.id
	JOIN valid_ingredient_states ON valid_ingredient_state_ingredients.valid_ingredient_state = valid_ingredient_states.id
WHERE valid_ingredient_state_ingredients.archived_at IS NULL
	AND valid_ingredient_state_ingredients.id = $1
`

type GetValidIngredientStateIngredientRow struct {
	CreatedAt                               time.Time               `db:"created_at"`
	CreatedAt_2                             time.Time               `db:"created_at_2"`
	CreatedAt_3                             time.Time               `db:"created_at_3"`
	ArchivedAt_3                            sql.NullTime            `db:"archived_at_3"`
	LastUpdatedAt                           sql.NullTime            `db:"last_updated_at"`
	ArchivedAt                              sql.NullTime            `db:"archived_at"`
	LastUpdatedAt_2                         sql.NullTime            `db:"last_updated_at_2"`
	ArchivedAt_2                            sql.NullTime            `db:"archived_at_2"`
	LastUpdatedAt_3                         sql.NullTime            `db:"last_updated_at_3"`
	Description                             string                  `db:"description"`
	PluralName                              string                  `db:"plural_name"`
	AttributeType                           IngredientAttributeType `db:"attribute_type"`
	ID_3                                    string                  `db:"id_3"`
	Name_2                                  string                  `db:"name_2"`
	Description_2                           string                  `db:"description_2"`
	Warning                                 string                  `db:"warning"`
	IconPath_2                              string                  `db:"icon_path_2"`
	StorageInstructions                     string                  `db:"storage_instructions"`
	Slug                                    string                  `db:"slug"`
	IconPath                                string                  `db:"icon_path"`
	PastTense                               string                  `db:"past_tense"`
	Name                                    string                  `db:"name"`
	ID_2                                    string                  `db:"id_2"`
	Notes                                   string                  `db:"notes"`
	ShoppingSuggestions                     string                  `db:"shopping_suggestions"`
	Slug_2                                  string                  `db:"slug_2"`
	ID                                      string                  `db:"id"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString          `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString          `db:"minimum_ideal_storage_temperature_in_celsius"`
	IsLiquid                                sql.NullBool            `db:"is_liquid"`
	ContainsFish                            bool                    `db:"contains_fish"`
	AnimalDerived                           bool                    `db:"animal_derived"`
	RestrictToPreparations                  bool                    `db:"restrict_to_preparations"`
	Volumetric                              bool                    `db:"volumetric"`
	AnimalFlesh                             bool                    `db:"animal_flesh"`
	ContainsGluten                          bool                    `db:"contains_gluten"`
	ContainsSesame                          bool                    `db:"contains_sesame"`
	ContainsAlcohol                         bool                    `db:"contains_alcohol"`
	ContainsShellfish                       bool                    `db:"contains_shellfish"`
	IsStarch                                bool                    `db:"is_starch"`
	IsProtein                               bool                    `db:"is_protein"`
	IsGrain                                 bool                    `db:"is_grain"`
	IsFruit                                 bool                    `db:"is_fruit"`
	IsSalt                                  bool                    `db:"is_salt"`
	IsFat                                   bool                    `db:"is_fat"`
	IsAcid                                  bool                    `db:"is_acid"`
	IsHeat                                  bool                    `db:"is_heat"`
	ContainsWheat                           bool                    `db:"contains_wheat"`
	ContainsSoy                             bool                    `db:"contains_soy"`
	ContainsTreeNut                         bool                    `db:"contains_tree_nut"`
	ContainsPeanut                          bool                    `db:"contains_peanut"`
	ContainsDairy                           bool                    `db:"contains_dairy"`
	ContainsEgg                             bool                    `db:"contains_egg"`
}

func (q *Queries) GetValidIngredientStateIngredient(ctx context.Context, db DBTX, id string) (*GetValidIngredientStateIngredientRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredientStateIngredient, id)
	var i GetValidIngredientStateIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.Slug,
		&i.PastTense,
		&i.AttributeType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath_2,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_2,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const GetValidInstrument = `-- name: GetValidInstrument :one

SELECT
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at
FROM valid_instruments
WHERE valid_instruments.archived_at IS NULL
	AND valid_instruments.id = $1
`

type GetValidInstrumentRow struct {
	CreatedAt                      time.Time    `db:"created_at"`
	LastUpdatedAt                  sql.NullTime `db:"last_updated_at"`
	ArchivedAt                     sql.NullTime `db:"archived_at"`
	ID                             string       `db:"id"`
	Name                           string       `db:"name"`
	PluralName                     string       `db:"plural_name"`
	Description                    string       `db:"description"`
	IconPath                       string       `db:"icon_path"`
	Slug                           string       `db:"slug"`
	UsableForStorage               bool         `db:"usable_for_storage"`
	DisplayInSummaryLists          bool         `db:"display_in_summary_lists"`
	IncludeInGeneratedInstructions bool         `db:"include_in_generated_instructions"`
}

func (q *Queries) GetValidInstrument(ctx context.Context, db DBTX, id string) (*GetValidInstrumentRow, error) {
	row := db.QueryRowContext(ctx, GetValidInstrument, id)
	var i GetValidInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidMeasurementConversion = `-- name: GetValidMeasurementConversion :one

SELECT
	valid_measurement_conversions.id,
	valid_measurement_units_from.id,
	valid_measurement_units_from.name,
	valid_measurement_units_from.description,
	valid_measurement_units_from.volumetric,
	valid_measurement_units_from.icon_path,
	valid_measurement_units_from.universal,
	valid_measurement_units_from.metric,
	valid_measurement_units_from.imperial,
	valid_measurement_units_from.slug,
	valid_measurement_units_from.plural_name,
	valid_measurement_units_from.created_at,
	valid_measurement_units_from.last_updated_at,
	valid_measurement_units_from.archived_at,
	valid_measurement_units_to.id,
	valid_measurement_units_to.name,
	valid_measurement_units_to.description,
	valid_measurement_units_to.volumetric,
	valid_measurement_units_to.icon_path,
	valid_measurement_units_to.universal,
	valid_measurement_units_to.metric,
	valid_measurement_units_to.imperial,
	valid_measurement_units_to.slug,
	valid_measurement_units_to.plural_name,
	valid_measurement_units_to.created_at,
	valid_measurement_units_to.last_updated_at,
	valid_measurement_units_to.archived_at,
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at,
	valid_measurement_conversions.modifier,
	valid_measurement_conversions.notes,
	valid_measurement_conversions.created_at,
	valid_measurement_conversions.last_updated_at,
	valid_measurement_conversions.archived_at
FROM valid_measurement_conversions
	     LEFT JOIN valid_ingredients ON valid_measurement_conversions.only_for_ingredient = valid_ingredients.id
	     JOIN valid_measurement_units AS valid_measurement_units_from ON valid_measurement_conversions.from_unit = valid_measurement_units_from.id
	     JOIN valid_measurement_units AS valid_measurement_units_to ON valid_measurement_conversions.to_unit = valid_measurement_units_to.id
WHERE valid_measurement_conversions.id = $1
  AND valid_measurement_conversions.archived_at IS NULL
  AND valid_measurement_units_from.archived_at IS NULL
  AND valid_measurement_units_to.archived_at IS NULL
`

type GetValidMeasurementConversionRow struct {
	CreatedAt_4                             time.Time      `db:"created_at_4"`
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	CreatedAt                               time.Time      `db:"created_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt_4                         sql.NullTime   `db:"last_updated_at_4"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	CreatedAt_3                             sql.NullTime   `db:"created_at_3"`
	ArchivedAt_4                            sql.NullTime   `db:"archived_at_4"`
	LastUpdatedAt_3                         sql.NullTime   `db:"last_updated_at_3"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	Slug                                    string         `db:"slug"`
	Name                                    string         `db:"name"`
	ID_3                                    string         `db:"id_3"`
	Name_2                                  string         `db:"name_2"`
	Description_2                           string         `db:"description_2"`
	Modifier                                string         `db:"modifier"`
	IconPath_2                              string         `db:"icon_path_2"`
	ID                                      string         `db:"id"`
	PluralName                              string         `db:"plural_name"`
	Notes                                   string         `db:"notes"`
	Slug_2                                  string         `db:"slug_2"`
	PluralName_2                            string         `db:"plural_name_2"`
	ID_2                                    string         `db:"id_2"`
	Description                             string         `db:"description"`
	IconPath                                string         `db:"icon_path"`
	Slug_3                                  sql.NullString `db:"slug_3"`
	Name_3                                  sql.NullString `db:"name_3"`
	Description_3                           sql.NullString `db:"description_3"`
	Warning                                 sql.NullString `db:"warning"`
	ShoppingSuggestions                     sql.NullString `db:"shopping_suggestions"`
	ID_4                                    sql.NullString `db:"id_4"`
	StorageInstructions                     sql.NullString `db:"storage_instructions"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	PluralName_3                            sql.NullString `db:"plural_name_3"`
	IconPath_3                              sql.NullString `db:"icon_path_3"`
	ContainsSesame                          sql.NullBool   `db:"contains_sesame"`
	ContainsEgg                             sql.NullBool   `db:"contains_egg"`
	ContainsGluten                          sql.NullBool   `db:"contains_gluten"`
	AnimalFlesh                             sql.NullBool   `db:"animal_flesh"`
	Volumetric_3                            sql.NullBool   `db:"volumetric_3"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	ContainsShellfish                       sql.NullBool   `db:"contains_shellfish"`
	AnimalDerived                           sql.NullBool   `db:"animal_derived"`
	ContainsWheat                           sql.NullBool   `db:"contains_wheat"`
	RestrictToPreparations                  sql.NullBool   `db:"restrict_to_preparations"`
	ContainsSoy                             sql.NullBool   `db:"contains_soy"`
	ContainsTreeNut                         sql.NullBool   `db:"contains_tree_nut"`
	ContainsPeanut                          sql.NullBool   `db:"contains_peanut"`
	ContainsDairy                           sql.NullBool   `db:"contains_dairy"`
	ContainsAlcohol                         sql.NullBool   `db:"contains_alcohol"`
	ContainsFish                            sql.NullBool   `db:"contains_fish"`
	IsStarch                                sql.NullBool   `db:"is_starch"`
	IsProtein                               sql.NullBool   `db:"is_protein"`
	IsGrain                                 sql.NullBool   `db:"is_grain"`
	IsFruit                                 sql.NullBool   `db:"is_fruit"`
	IsSalt                                  sql.NullBool   `db:"is_salt"`
	IsFat                                   sql.NullBool   `db:"is_fat"`
	IsAcid                                  sql.NullBool   `db:"is_acid"`
	IsHeat                                  sql.NullBool   `db:"is_heat"`
	Volumetric                              sql.NullBool   `db:"volumetric"`
	Volumetric_2                            sql.NullBool   `db:"volumetric_2"`
	Universal_2                             bool           `db:"universal_2"`
	Metric_2                                bool           `db:"metric_2"`
	Imperial                                bool           `db:"imperial"`
	Metric                                  bool           `db:"metric"`
	Universal                               bool           `db:"universal"`
	Imperial_2                              bool           `db:"imperial_2"`
}

func (q *Queries) GetValidMeasurementConversion(ctx context.Context, db DBTX, id string) (*GetValidMeasurementConversionRow, error) {
	row := db.QueryRowContext(ctx, GetValidMeasurementConversion, id)
	var i GetValidMeasurementConversionRow
	err := row.Scan(
		&i.ID,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.Volumetric_2,
		&i.IconPath_2,
		&i.Universal_2,
		&i.Metric_2,
		&i.Imperial_2,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.ID_4,
		&i.Name_3,
		&i.Description_3,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric_3,
		&i.IsLiquid,
		&i.IconPath_3,
		&i.AnimalDerived,
		&i.PluralName_3,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug_3,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.Modifier,
		&i.Notes,
		&i.CreatedAt_4,
		&i.LastUpdatedAt_4,
		&i.ArchivedAt_4,
	)
	return &i, err
}

const GetValidMeasurementUnit = `-- name: GetValidMeasurementUnit :one

SELECT
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at
FROM valid_measurement_units
WHERE valid_measurement_units.archived_at IS NULL
	AND valid_measurement_units.id = $1
`

type GetValidMeasurementUnitRow struct {
	CreatedAt     time.Time    `db:"created_at"`
	ArchivedAt    sql.NullTime `db:"archived_at"`
	LastUpdatedAt sql.NullTime `db:"last_updated_at"`
	PluralName    string       `db:"plural_name"`
	Name          string       `db:"name"`
	Description   string       `db:"description"`
	ID            string       `db:"id"`
	IconPath      string       `db:"icon_path"`
	Slug          string       `db:"slug"`
	Volumetric    sql.NullBool `db:"volumetric"`
	Imperial      bool         `db:"imperial"`
	Metric        bool         `db:"metric"`
	Universal     bool         `db:"universal"`
}

func (q *Queries) GetValidMeasurementUnit(ctx context.Context, db DBTX, id string) (*GetValidMeasurementUnitRow, error) {
	row := db.QueryRowContext(ctx, GetValidMeasurementUnit, id)
	var i GetValidMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidPreparation = `-- name: GetValidPreparation :one

SELECT
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
    valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at
FROM valid_preparations
WHERE valid_preparations.archived_at IS NULL
	AND valid_preparations.id = $1
`

type GetValidPreparationRow struct {
	CreatedAt                   time.Time     `db:"created_at"`
	LastUpdatedAt               sql.NullTime  `db:"last_updated_at"`
	ArchivedAt                  sql.NullTime  `db:"archived_at"`
	Name                        string        `db:"name"`
	Description                 string        `db:"description"`
	IconPath                    string        `db:"icon_path"`
	ID                          string        `db:"id"`
	Slug                        string        `db:"slug"`
	PastTense                   string        `db:"past_tense"`
	MaximumInstrumentCount      sql.NullInt32 `db:"maximum_instrument_count"`
	MaximumIngredientCount      sql.NullInt32 `db:"maximum_ingredient_count"`
	MaximumVesselCount          sql.NullInt32 `db:"maximum_vessel_count"`
	MinimumVesselCount          int32         `db:"minimum_vessel_count"`
	MinimumInstrumentCount      int32         `db:"minimum_instrument_count"`
	MinimumIngredientCount      int32         `db:"minimum_ingredient_count"`
	RestrictToIngredients       bool          `db:"restrict_to_ingredients"`
	OnlyForVessels              bool          `db:"only_for_vessels"`
	ConsumesVessel              bool          `db:"consumes_vessel"`
	ConditionExpressionRequired bool          `db:"condition_expression_required"`
	TimeEstimateRequired        bool          `db:"time_estimate_required"`
	TemperatureRequired         bool          `db:"temperature_required"`
	YieldsNothing               bool          `db:"yields_nothing"`
}

func (q *Queries) GetValidPreparation(ctx context.Context, db DBTX, id string) (*GetValidPreparationRow, error) {
	row := db.QueryRowContext(ctx, GetValidPreparation, id)
	var i GetValidPreparationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidPreparationInstrument = `-- name: GetValidPreparationInstrument :one

SELECT
	valid_preparation_instruments.id,
	valid_preparation_instruments.notes,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	valid_preparation_instruments.created_at,
	valid_preparation_instruments.last_updated_at,
	valid_preparation_instruments.archived_at
FROM
	valid_preparation_instruments
	 JOIN valid_instruments ON valid_preparation_instruments.valid_instrument_id = valid_instruments.id
	 JOIN valid_preparations ON valid_preparation_instruments.valid_preparation_id = valid_preparations.id
WHERE
	valid_preparation_instruments.archived_at IS NULL
	AND valid_preparation_instruments.id = $1
`

type GetValidPreparationInstrumentRow struct {
	CreatedAt                      time.Time     `db:"created_at"`
	CreatedAt_2                    time.Time     `db:"created_at_2"`
	CreatedAt_3                    time.Time     `db:"created_at_3"`
	ArchivedAt_2                   sql.NullTime  `db:"archived_at_2"`
	LastUpdatedAt                  sql.NullTime  `db:"last_updated_at"`
	LastUpdatedAt_2                sql.NullTime  `db:"last_updated_at_2"`
	ArchivedAt                     sql.NullTime  `db:"archived_at"`
	ArchivedAt_3                   sql.NullTime  `db:"archived_at_3"`
	LastUpdatedAt_3                sql.NullTime  `db:"last_updated_at_3"`
	IconPath                       string        `db:"icon_path"`
	PluralName                     string        `db:"plural_name"`
	Description                    string        `db:"description"`
	Name                           string        `db:"name"`
	Slug_2                         string        `db:"slug_2"`
	IconPath_2                     string        `db:"icon_path_2"`
	Description_2                  string        `db:"description_2"`
	ID                             string        `db:"id"`
	Name_2                         string        `db:"name_2"`
	ID_3                           string        `db:"id_3"`
	Slug                           string        `db:"slug"`
	PastTense                      string        `db:"past_tense"`
	ID_2                           string        `db:"id_2"`
	Notes                          string        `db:"notes"`
	MaximumIngredientCount         sql.NullInt32 `db:"maximum_ingredient_count"`
	MaximumVesselCount             sql.NullInt32 `db:"maximum_vessel_count"`
	MaximumInstrumentCount         sql.NullInt32 `db:"maximum_instrument_count"`
	MinimumVesselCount             int32         `db:"minimum_vessel_count"`
	MinimumIngredientCount         int32         `db:"minimum_ingredient_count"`
	MinimumInstrumentCount         int32         `db:"minimum_instrument_count"`
	DisplayInSummaryLists          bool          `db:"display_in_summary_lists"`
	UsableForStorage               bool          `db:"usable_for_storage"`
	IncludeInGeneratedInstructions bool          `db:"include_in_generated_instructions"`
	TimeEstimateRequired           bool          `db:"time_estimate_required"`
	TemperatureRequired            bool          `db:"temperature_required"`
	ConditionExpressionRequired    bool          `db:"condition_expression_required"`
	ConsumesVessel                 bool          `db:"consumes_vessel"`
	OnlyForVessels                 bool          `db:"only_for_vessels"`
	RestrictToIngredients          bool          `db:"restrict_to_ingredients"`
	YieldsNothing                  bool          `db:"yields_nothing"`
}

func (q *Queries) GetValidPreparationInstrument(ctx context.Context, db DBTX, id string) (*GetValidPreparationInstrumentRow, error) {
	row := db.QueryRowContext(ctx, GetValidPreparationInstrument, id)
	var i GetValidPreparationInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.PluralName,
		&i.Description_2,
		&i.IconPath_2,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
	)
	return &i, err
}

const GetValidPreparationVessel = `-- name: GetValidPreparationVessel :one

SELECT
    valid_preparation_vessels.id,
    valid_preparation_vessels.notes,
    valid_preparations.id,
    valid_preparations.name,
    valid_preparations.description,
    valid_preparations.icon_path,
    valid_preparations.yields_nothing,
    valid_preparations.restrict_to_ingredients,
    valid_preparations.minimum_ingredient_count,
    valid_preparations.maximum_ingredient_count,
    valid_preparations.minimum_instrument_count,
    valid_preparations.maximum_instrument_count,
    valid_preparations.temperature_required,
    valid_preparations.time_estimate_required,
    valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
    valid_preparations.slug,
    valid_preparations.past_tense,
    valid_preparations.created_at,
    valid_preparations.last_updated_at,
    valid_preparations.archived_at,
    valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity,
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.universal,
    valid_measurement_units.metric,
    valid_measurement_units.imperial,
    valid_measurement_units.slug,
    valid_measurement_units.plural_name,
    valid_measurement_units.created_at,
    valid_measurement_units.last_updated_at,
    valid_measurement_units.archived_at,
    valid_vessels.width_in_millimeters,
    valid_vessels.length_in_millimeters,
    valid_vessels.height_in_millimeters,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at,
    valid_preparation_vessels.created_at,
    valid_preparation_vessels.last_updated_at,
    valid_preparation_vessels.archived_at
FROM
	valid_preparation_vessels
	 JOIN valid_vessels ON valid_preparation_vessels.valid_vessel_id = valid_vessels.id
	 LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit = valid_measurement_units.id
	 JOIN valid_preparations ON valid_preparation_vessels.valid_preparation_id = valid_preparations.id
WHERE
	valid_preparation_vessels.archived_at IS NULL
	AND valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_preparations.archived_at IS NULL
	AND valid_preparation_vessels.id = $1
`

type GetValidPreparationVesselRow struct {
	CreatedAt_4                    time.Time      `db:"created_at_4"`
	CreatedAt                      time.Time      `db:"created_at"`
	CreatedAt_3                    time.Time      `db:"created_at_3"`
	LastUpdatedAt_4                sql.NullTime   `db:"last_updated_at_4"`
	LastUpdatedAt                  sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                     sql.NullTime   `db:"archived_at"`
	ArchivedAt_4                   sql.NullTime   `db:"archived_at_4"`
	CreatedAt_2                    sql.NullTime   `db:"created_at_2"`
	LastUpdatedAt_2                sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_3                   sql.NullTime   `db:"archived_at_3"`
	LastUpdatedAt_3                sql.NullTime   `db:"last_updated_at_3"`
	ArchivedAt_2                   sql.NullTime   `db:"archived_at_2"`
	PastTense                      string         `db:"past_tense"`
	Slug_2                         string         `db:"slug_2"`
	Name                           string         `db:"name"`
	IconPath_2                     string         `db:"icon_path_2"`
	Shape                          VesselShape    `db:"shape"`
	Capacity                       string         `db:"capacity"`
	ID_2                           string         `db:"id_2"`
	Slug                           string         `db:"slug"`
	ID                             string         `db:"id"`
	Notes                          string         `db:"notes"`
	Description                    string         `db:"description"`
	IconPath                       string         `db:"icon_path"`
	ID_3                           string         `db:"id_3"`
	Name_2                         string         `db:"name_2"`
	PluralName                     string         `db:"plural_name"`
	Description_2                  string         `db:"description_2"`
	PluralName_2                   sql.NullString `db:"plural_name_2"`
	IconPath_3                     sql.NullString `db:"icon_path_3"`
	Slug_3                         sql.NullString `db:"slug_3"`
	HeightInMillimeters            sql.NullString `db:"height_in_millimeters"`
	LengthInMillimeters            sql.NullString `db:"length_in_millimeters"`
	WidthInMillimeters             sql.NullString `db:"width_in_millimeters"`
	ID_4                           sql.NullString `db:"id_4"`
	Name_3                         sql.NullString `db:"name_3"`
	Description_3                  sql.NullString `db:"description_3"`
	MaximumIngredientCount         sql.NullInt32  `db:"maximum_ingredient_count"`
	MaximumInstrumentCount         sql.NullInt32  `db:"maximum_instrument_count"`
	MaximumVesselCount             sql.NullInt32  `db:"maximum_vessel_count"`
	MinimumVesselCount             int32          `db:"minimum_vessel_count"`
	MinimumInstrumentCount         int32          `db:"minimum_instrument_count"`
	MinimumIngredientCount         int32          `db:"minimum_ingredient_count"`
	Volumetric                     sql.NullBool   `db:"volumetric"`
	Imperial                       sql.NullBool   `db:"imperial"`
	Metric                         sql.NullBool   `db:"metric"`
	Universal                      sql.NullBool   `db:"universal"`
	OnlyForVessels                 bool           `db:"only_for_vessels"`
	TimeEstimateRequired           bool           `db:"time_estimate_required"`
	ConditionExpressionRequired    bool           `db:"condition_expression_required"`
	TemperatureRequired            bool           `db:"temperature_required"`
	ConsumesVessel                 bool           `db:"consumes_vessel"`
	UsableForStorage               bool           `db:"usable_for_storage"`
	IncludeInGeneratedInstructions bool           `db:"include_in_generated_instructions"`
	DisplayInSummaryLists          bool           `db:"display_in_summary_lists"`
	RestrictToIngredients          bool           `db:"restrict_to_ingredients"`
	YieldsNothing                  bool           `db:"yields_nothing"`
}

func (q *Queries) GetValidPreparationVessel(ctx context.Context, db DBTX, id string) (*GetValidPreparationVesselRow, error) {
	row := db.QueryRowContext(ctx, GetValidPreparationVessel, id)
	var i GetValidPreparationVesselRow
	err := row.Scan(
		&i.ID,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.ID_3,
		&i.Name_2,
		&i.PluralName,
		&i.Description_2,
		&i.IconPath_2,
		&i.UsableForStorage,
		&i.Slug_2,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ID_4,
		&i.Name_3,
		&i.Description_3,
		&i.Volumetric,
		&i.IconPath_3,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_3,
		&i.PluralName_2,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.CreatedAt_4,
		&i.LastUpdatedAt_4,
		&i.ArchivedAt_4,
	)
	return &i, err
}

const GetValidVessel = `-- name: GetValidVessel :one

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
    valid_vessels.width_in_millimeters,
    valid_vessels.length_in_millimeters,
    valid_vessels.height_in_millimeters,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_vessels.id = $1
`

type GetValidVesselRow struct {
	CreatedAt                      time.Time      `db:"created_at"`
	CreatedAt_2                    time.Time      `db:"created_at_2"`
	ArchivedAt_2                   sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt_2                sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt                     sql.NullTime   `db:"archived_at"`
	LastUpdatedAt                  sql.NullTime   `db:"last_updated_at"`
	IconPath_2                     string         `db:"icon_path_2"`
	IconPath                       string         `db:"icon_path"`
	Name                           string         `db:"name"`
	Capacity                       string         `db:"capacity"`
	ID_2                           string         `db:"id_2"`
	Name_2                         string         `db:"name_2"`
	Description_2                  string         `db:"description_2"`
	PluralName                     string         `db:"plural_name"`
	ID                             string         `db:"id"`
	Description                    string         `db:"description"`
	Shape                          VesselShape    `db:"shape"`
	Slug                           string         `db:"slug"`
	Slug_2                         string         `db:"slug_2"`
	PluralName_2                   string         `db:"plural_name_2"`
	WidthInMillimeters             sql.NullString `db:"width_in_millimeters"`
	LengthInMillimeters            sql.NullString `db:"length_in_millimeters"`
	HeightInMillimeters            sql.NullString `db:"height_in_millimeters"`
	Volumetric                     sql.NullBool   `db:"volumetric"`
	Imperial                       bool           `db:"imperial"`
	UsableForStorage               bool           `db:"usable_for_storage"`
	DisplayInSummaryLists          bool           `db:"display_in_summary_lists"`
	Metric                         bool           `db:"metric"`
	Universal                      bool           `db:"universal"`
	IncludeInGeneratedInstructions bool           `db:"include_in_generated_instructions"`
}

func (q *Queries) GetValidVessel(ctx context.Context, db DBTX, id string) (*GetValidVesselRow, error) {
	row := db.QueryRowContext(ctx, GetValidVessel, id)
	var i GetValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Capacity,
		&i.ID_2,
		&i.Name_2,
		&i.Description_2,
		&i.Volumetric,
		&i.IconPath_2,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug_2,
		&i.PluralName_2,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.WidthInMillimeters,
		&i.LengthInMillimeters,
		&i.HeightInMillimeters,
		&i.Shape,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const GetWebhook = `-- name: GetWebhook :many

SELECT
	webhooks.id,
	webhooks.name,
	webhooks.content_type,
	webhooks.url,
	webhooks.method,
	webhook_trigger_events.id,
	webhook_trigger_events.trigger_event,
	webhook_trigger_events.belongs_to_webhook,
	webhook_trigger_events.created_at,
	webhook_trigger_events.archived_at,
	webhooks.created_at,
	webhooks.last_updated_at,
	webhooks.archived_at,
	webhooks.belongs_to_household
FROM webhook_trigger_events
 JOIN webhooks ON webhook_trigger_events.belongs_to_webhook=webhooks.id
WHERE webhooks.archived_at IS NULL
  AND webhook_trigger_events.archived_at IS NULL
  AND webhooks.belongs_to_household = $1
  AND webhooks.id = $2
`

type GetWebhookParams struct {
	BelongsToHousehold string `db:"belongs_to_household"`
	ID                 string `db:"id"`
}

type GetWebhookRow struct {
	ID                 string       `db:"id"`
	Name               string       `db:"name"`
	ContentType        string       `db:"content_type"`
	Url                string       `db:"url"`
	Method             string       `db:"method"`
	ID_2               string       `db:"id_2"`
	TriggerEvent       WebhookEvent `db:"trigger_event"`
	BelongsToWebhook   string       `db:"belongs_to_webhook"`
	CreatedAt          time.Time    `db:"created_at"`
	ArchivedAt         sql.NullTime `db:"archived_at"`
	CreatedAt_2        time.Time    `db:"created_at_2"`
	LastUpdatedAt      sql.NullTime `db:"last_updated_at"`
	ArchivedAt_2       sql.NullTime `db:"archived_at_2"`
	BelongsToHousehold string       `db:"belongs_to_household"`
}

func (q *Queries) GetWebhook(ctx context.Context, db DBTX, arg *GetWebhookParams) ([]*GetWebhookRow, error) {
	rows, err := db.QueryContext(ctx, GetWebhook, arg.BelongsToHousehold, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebhookRow{}
	for rows.Next() {
		var i GetWebhookRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentType,
			&i.Url,
			&i.Method,
			&i.ID_2,
			&i.TriggerEvent,
			&i.BelongsToWebhook,
			&i.CreatedAt,
			&i.ArchivedAt,
			&i.CreatedAt_2,
			&i.LastUpdatedAt,
			&i.ArchivedAt_2,
			&i.BelongsToHousehold,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
