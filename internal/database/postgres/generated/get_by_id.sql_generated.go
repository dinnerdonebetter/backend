// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_by_id.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const GetRecipeByID = `-- name: GetRecipeByID :one

SELECT
	recipes.id,
	recipes.name,
	recipes.slug,
	recipes.source,
	recipes.description,
	recipes.inspired_by_recipe_id,
	recipes.min_estimated_portions,
	recipes.max_estimated_portions,
	recipes.portion_name,
	recipes.plural_portion_name,
	recipes.seal_of_approval,
	recipes.eligible_for_meals,
	recipes.yields_component_type,
	recipes.created_at,
	recipes.last_updated_at,
	recipes.archived_at,
	recipes.created_by_user,
	recipe_steps.id,
	recipe_steps.index,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	recipe_steps.minimum_estimated_time_in_seconds,
	recipe_steps.maximum_estimated_time_in_seconds,
	recipe_steps.minimum_temperature_in_celsius,
	recipe_steps.maximum_temperature_in_celsius,
	recipe_steps.notes,
	recipe_steps.explicit_instructions,
	recipe_steps.condition_expression,
	recipe_steps.optional,
	recipe_steps.start_timer_automatically,
	recipe_steps.created_at,
	recipe_steps.last_updated_at,
	recipe_steps.archived_at,
	recipe_steps.belongs_to_recipe
FROM recipes
	FULL OUTER JOIN recipe_steps ON recipes.id=recipe_steps.belongs_to_recipe
	FULL OUTER JOIN valid_preparations ON recipe_steps.preparation_id=valid_preparations.id
WHERE recipes.archived_at IS NULL
	AND recipes.id = $1
ORDER BY recipe_steps.index
`

type GetRecipeByIDRow struct {
	ID                            sql.NullString    `db:"id"`
	Name                          sql.NullString    `db:"name"`
	Slug                          sql.NullString    `db:"slug"`
	Source                        sql.NullString    `db:"source"`
	Description                   sql.NullString    `db:"description"`
	InspiredByRecipeID            sql.NullString    `db:"inspired_by_recipe_id"`
	MinEstimatedPortions          sql.NullString    `db:"min_estimated_portions"`
	MaxEstimatedPortions          sql.NullString    `db:"max_estimated_portions"`
	PortionName                   sql.NullString    `db:"portion_name"`
	PluralPortionName             sql.NullString    `db:"plural_portion_name"`
	SealOfApproval                sql.NullBool      `db:"seal_of_approval"`
	EligibleForMeals              sql.NullBool      `db:"eligible_for_meals"`
	YieldsComponentType           NullComponentType `db:"yields_component_type"`
	CreatedAt                     sql.NullTime      `db:"created_at"`
	LastUpdatedAt                 sql.NullTime      `db:"last_updated_at"`
	ArchivedAt                    sql.NullTime      `db:"archived_at"`
	CreatedByUser                 sql.NullString    `db:"created_by_user"`
	ID_2                          sql.NullString    `db:"id_2"`
	Index                         sql.NullInt32     `db:"index"`
	ID_3                          sql.NullString    `db:"id_3"`
	Name_2                        sql.NullString    `db:"name_2"`
	Description_2                 sql.NullString    `db:"description_2"`
	IconPath                      sql.NullString    `db:"icon_path"`
	YieldsNothing                 sql.NullBool      `db:"yields_nothing"`
	RestrictToIngredients         sql.NullBool      `db:"restrict_to_ingredients"`
	MinimumIngredientCount        sql.NullInt32     `db:"minimum_ingredient_count"`
	MaximumIngredientCount        sql.NullInt32     `db:"maximum_ingredient_count"`
	MinimumInstrumentCount        sql.NullInt32     `db:"minimum_instrument_count"`
	MaximumInstrumentCount        sql.NullInt32     `db:"maximum_instrument_count"`
	TemperatureRequired           sql.NullBool      `db:"temperature_required"`
	TimeEstimateRequired          sql.NullBool      `db:"time_estimate_required"`
	ConditionExpressionRequired   sql.NullBool      `db:"condition_expression_required"`
	ConsumesVessel                sql.NullBool      `db:"consumes_vessel"`
	OnlyForVessels                sql.NullBool      `db:"only_for_vessels"`
	MinimumVesselCount            sql.NullInt32     `db:"minimum_vessel_count"`
	MaximumVesselCount            sql.NullInt32     `db:"maximum_vessel_count"`
	Slug_2                        sql.NullString    `db:"slug_2"`
	PastTense                     sql.NullString    `db:"past_tense"`
	CreatedAt_2                   sql.NullTime      `db:"created_at_2"`
	LastUpdatedAt_2               sql.NullTime      `db:"last_updated_at_2"`
	ArchivedAt_2                  sql.NullTime      `db:"archived_at_2"`
	MinimumEstimatedTimeInSeconds sql.NullInt64     `db:"minimum_estimated_time_in_seconds"`
	MaximumEstimatedTimeInSeconds sql.NullInt64     `db:"maximum_estimated_time_in_seconds"`
	MinimumTemperatureInCelsius   sql.NullString    `db:"minimum_temperature_in_celsius"`
	MaximumTemperatureInCelsius   sql.NullString    `db:"maximum_temperature_in_celsius"`
	Notes                         sql.NullString    `db:"notes"`
	ExplicitInstructions          sql.NullString    `db:"explicit_instructions"`
	ConditionExpression           sql.NullString    `db:"condition_expression"`
	Optional                      sql.NullBool      `db:"optional"`
	StartTimerAutomatically       sql.NullBool      `db:"start_timer_automatically"`
	CreatedAt_3                   sql.NullTime      `db:"created_at_3"`
	LastUpdatedAt_3               sql.NullTime      `db:"last_updated_at_3"`
	ArchivedAt_3                  sql.NullTime      `db:"archived_at_3"`
	BelongsToRecipe               sql.NullString    `db:"belongs_to_recipe"`
}

func (q *Queries) GetRecipeByID(ctx context.Context, db DBTX, id string) (*GetRecipeByIDRow, error) {
	row := db.QueryRowContext(ctx, GetRecipeByID, id)
	var i GetRecipeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Source,
		&i.Description,
		&i.InspiredByRecipeID,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.PortionName,
		&i.PluralPortionName,
		&i.SealOfApproval,
		&i.EligibleForMeals,
		&i.YieldsComponentType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.ID_2,
		&i.Index,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug_2,
		&i.PastTense,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumEstimatedTimeInSeconds,
		&i.MaximumEstimatedTimeInSeconds,
		&i.MinimumTemperatureInCelsius,
		&i.MaximumTemperatureInCelsius,
		&i.Notes,
		&i.ExplicitInstructions,
		&i.ConditionExpression,
		&i.Optional,
		&i.StartTimerAutomatically,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.BelongsToRecipe,
	)
	return &i, err
}

const GetServiceSettingConfigurationByID = `-- name: GetServiceSettingConfigurationByID :one

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.id = $1
`

type GetServiceSettingConfigurationByIDRow struct {
	ID                 string         `db:"id"`
	Value              string         `db:"value"`
	Notes              string         `db:"notes"`
	ID_2               string         `db:"id_2"`
	Name               string         `db:"name"`
	Type               SettingType    `db:"type"`
	Description        string         `db:"description"`
	DefaultValue       sql.NullString `db:"default_value"`
	Enumeration        string         `db:"enumeration"`
	AdminsOnly         bool           `db:"admins_only"`
	CreatedAt          time.Time      `db:"created_at"`
	LastUpdatedAt      sql.NullTime   `db:"last_updated_at"`
	ArchivedAt         sql.NullTime   `db:"archived_at"`
	BelongsToUser      string         `db:"belongs_to_user"`
	BelongsToHousehold string         `db:"belongs_to_household"`
	CreatedAt_2        time.Time      `db:"created_at_2"`
	LastUpdatedAt_2    sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_2       sql.NullTime   `db:"archived_at_2"`
}

func (q *Queries) GetServiceSettingConfigurationByID(ctx context.Context, db DBTX, id string) (*GetServiceSettingConfigurationByIDRow, error) {
	row := db.QueryRowContext(ctx, GetServiceSettingConfigurationByID, id)
	var i GetServiceSettingConfigurationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.Enumeration,
		&i.AdminsOnly,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToUser,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const GetUserByID = `-- name: GetUserByID :one

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	ID                           string         `db:"id"`
	FirstName                    string         `db:"first_name"`
	LastName                     string         `db:"last_name"`
	Username                     string         `db:"username"`
	EmailAddress                 string         `db:"email_address"`
	EmailAddressVerifiedAt       sql.NullTime   `db:"email_address_verified_at"`
	AvatarSrc                    sql.NullString `db:"avatar_src"`
	HashedPassword               string         `db:"hashed_password"`
	RequiresPasswordChange       bool           `db:"requires_password_change"`
	PasswordLastChangedAt        sql.NullTime   `db:"password_last_changed_at"`
	TwoFactorSecret              string         `db:"two_factor_secret"`
	TwoFactorSecretVerifiedAt    sql.NullTime   `db:"two_factor_secret_verified_at"`
	ServiceRole                  string         `db:"service_role"`
	UserAccountStatus            string         `db:"user_account_status"`
	UserAccountStatusExplanation string         `db:"user_account_status_explanation"`
	Birthday                     sql.NullTime   `db:"birthday"`
	LastAcceptedTermsOfService   sql.NullTime   `db:"last_accepted_terms_of_service"`
	LastAcceptedPrivacyPolicy    sql.NullTime   `db:"last_accepted_privacy_policy"`
	CreatedAt                    time.Time      `db:"created_at"`
	LastUpdatedAt                sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                   sql.NullTime   `db:"archived_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, GetUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.EmailAddress,
		&i.EmailAddressVerifiedAt,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedAt,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidIngredientByID = `-- name: GetValidIngredientByID :one

SELECT valid_ingredients.id,
       valid_ingredients.name,
       valid_ingredients.description,
       valid_ingredients.warning,
       valid_ingredients.contains_egg,
       valid_ingredients.contains_dairy,
       valid_ingredients.contains_peanut,
       valid_ingredients.contains_tree_nut,
       valid_ingredients.contains_soy,
       valid_ingredients.contains_wheat,
       valid_ingredients.contains_shellfish,
       valid_ingredients.contains_sesame,
       valid_ingredients.contains_fish,
       valid_ingredients.contains_gluten,
       valid_ingredients.animal_flesh,
       valid_ingredients.volumetric,
       valid_ingredients.is_liquid,
       valid_ingredients.icon_path,
       valid_ingredients.animal_derived,
       valid_ingredients.plural_name,
       valid_ingredients.restrict_to_preparations,
       valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
       valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
       valid_ingredients.storage_instructions,
       valid_ingredients.slug,
       valid_ingredients.contains_alcohol,
       valid_ingredients.shopping_suggestions,
       valid_ingredients.is_starch,
       valid_ingredients.is_protein,
       valid_ingredients.is_grain,
       valid_ingredients.is_fruit,
       valid_ingredients.is_salt,
       valid_ingredients.is_fat,
       valid_ingredients.is_acid,
       valid_ingredients.is_heat,
       valid_ingredients.created_at,
       valid_ingredients.last_updated_at,
       valid_ingredients.archived_at
  FROM valid_ingredients
 WHERE valid_ingredients.archived_at IS NULL
`

type GetValidIngredientByIDRow struct {
	ID                                      string         `db:"id"`
	Name                                    string         `db:"name"`
	Description                             string         `db:"description"`
	Warning                                 string         `db:"warning"`
	ContainsEgg                             bool           `db:"contains_egg"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	Volumetric                              bool           `db:"volumetric"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	IconPath                                string         `db:"icon_path"`
	AnimalDerived                           bool           `db:"animal_derived"`
	PluralName                              string         `db:"plural_name"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	StorageInstructions                     string         `db:"storage_instructions"`
	Slug                                    string         `db:"slug"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	CreatedAt                               time.Time      `db:"created_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
}

func (q *Queries) GetValidIngredientByID(ctx context.Context, db DBTX) (*GetValidIngredientByIDRow, error) {
	row := db.QueryRowContext(ctx, GetValidIngredientByID)
	var i GetValidIngredientByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidInstrumentByID = `-- name: GetValidInstrumentByID :one

SELECT valid_instruments.id,
       valid_instruments.name,
       valid_instruments.plural_name,
       valid_instruments.description,
       valid_instruments.icon_path,
       valid_instruments.usable_for_storage,
       valid_instruments.display_in_summary_lists,
       valid_instruments.include_in_generated_instructions,
       valid_instruments.slug,
       valid_instruments.created_at,
       valid_instruments.last_updated_at,
       valid_instruments.archived_at
  FROM valid_instruments
 WHERE valid_instruments.archived_at IS NULL
`

type GetValidInstrumentByIDRow struct {
	ID                             string       `db:"id"`
	Name                           string       `db:"name"`
	PluralName                     string       `db:"plural_name"`
	Description                    string       `db:"description"`
	IconPath                       string       `db:"icon_path"`
	UsableForStorage               bool         `db:"usable_for_storage"`
	DisplayInSummaryLists          bool         `db:"display_in_summary_lists"`
	IncludeInGeneratedInstructions bool         `db:"include_in_generated_instructions"`
	Slug                           string       `db:"slug"`
	CreatedAt                      time.Time    `db:"created_at"`
	LastUpdatedAt                  sql.NullTime `db:"last_updated_at"`
	ArchivedAt                     sql.NullTime `db:"archived_at"`
}

func (q *Queries) GetValidInstrumentByID(ctx context.Context, db DBTX) (*GetValidInstrumentByIDRow, error) {
	row := db.QueryRowContext(ctx, GetValidInstrumentByID)
	var i GetValidInstrumentByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidMeasurementUnitByID = `-- name: GetValidMeasurementUnitByID :one

SELECT valid_measurement_units.id,
       valid_measurement_units.name,
       valid_measurement_units.description,
       valid_measurement_units.volumetric,
       valid_measurement_units.icon_path,
       valid_measurement_units.universal,
       valid_measurement_units.metric,
       valid_measurement_units.imperial,
       valid_measurement_units.slug,
       valid_measurement_units.plural_name,
       valid_measurement_units.created_at,
       valid_measurement_units.last_updated_at,
       valid_measurement_units.archived_at
  FROM valid_measurement_units
 WHERE valid_measurement_units.archived_at IS NULL
`

type GetValidMeasurementUnitByIDRow struct {
	ID            string       `db:"id"`
	Name          string       `db:"name"`
	Description   string       `db:"description"`
	Volumetric    sql.NullBool `db:"volumetric"`
	IconPath      string       `db:"icon_path"`
	Universal     bool         `db:"universal"`
	Metric        bool         `db:"metric"`
	Imperial      bool         `db:"imperial"`
	Slug          string       `db:"slug"`
	PluralName    string       `db:"plural_name"`
	CreatedAt     time.Time    `db:"created_at"`
	LastUpdatedAt sql.NullTime `db:"last_updated_at"`
	ArchivedAt    sql.NullTime `db:"archived_at"`
}

func (q *Queries) GetValidMeasurementUnitByID(ctx context.Context, db DBTX) (*GetValidMeasurementUnitByIDRow, error) {
	row := db.QueryRowContext(ctx, GetValidMeasurementUnitByID)
	var i GetValidMeasurementUnitByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const GetValidPreparationByID = `-- name: GetValidPreparationByID :one

SELECT valid_preparations.id,
       valid_preparations.name,
       valid_preparations.description,
       valid_preparations.icon_path,
       valid_preparations.yields_nothing,
       valid_preparations.restrict_to_ingredients,
       valid_preparations.minimum_ingredient_count,
       valid_preparations.maximum_ingredient_count,
       valid_preparations.minimum_instrument_count,
       valid_preparations.maximum_instrument_count,
       valid_preparations.temperature_required,
       valid_preparations.time_estimate_required,
       valid_preparations.condition_expression_required,
       valid_preparations.consumes_vessel,
       valid_preparations.only_for_vessels,
       valid_preparations.minimum_vessel_count,
       valid_preparations.maximum_vessel_count,
       valid_preparations.slug,
       valid_preparations.past_tense,
       valid_preparations.created_at,
       valid_preparations.last_updated_at,
       valid_preparations.archived_at
  FROM valid_preparations
 WHERE valid_preparations.archived_at IS NULL
`

type GetValidPreparationByIDRow struct {
	ID                          string        `db:"id"`
	Name                        string        `db:"name"`
	Description                 string        `db:"description"`
	IconPath                    string        `db:"icon_path"`
	YieldsNothing               bool          `db:"yields_nothing"`
	RestrictToIngredients       bool          `db:"restrict_to_ingredients"`
	MinimumIngredientCount      int32         `db:"minimum_ingredient_count"`
	MaximumIngredientCount      sql.NullInt32 `db:"maximum_ingredient_count"`
	MinimumInstrumentCount      int32         `db:"minimum_instrument_count"`
	MaximumInstrumentCount      sql.NullInt32 `db:"maximum_instrument_count"`
	TemperatureRequired         bool          `db:"temperature_required"`
	TimeEstimateRequired        bool          `db:"time_estimate_required"`
	ConditionExpressionRequired bool          `db:"condition_expression_required"`
	ConsumesVessel              bool          `db:"consumes_vessel"`
	OnlyForVessels              bool          `db:"only_for_vessels"`
	MinimumVesselCount          int32         `db:"minimum_vessel_count"`
	MaximumVesselCount          sql.NullInt32 `db:"maximum_vessel_count"`
	Slug                        string        `db:"slug"`
	PastTense                   string        `db:"past_tense"`
	CreatedAt                   time.Time     `db:"created_at"`
	LastUpdatedAt               sql.NullTime  `db:"last_updated_at"`
	ArchivedAt                  sql.NullTime  `db:"archived_at"`
}

func (q *Queries) GetValidPreparationByID(ctx context.Context, db DBTX) (*GetValidPreparationByIDRow, error) {
	row := db.QueryRowContext(ctx, GetValidPreparationByID)
	var i GetValidPreparationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}
