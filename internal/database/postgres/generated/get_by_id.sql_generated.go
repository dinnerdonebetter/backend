// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_by_id.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getRecipeByID = `-- name: GetRecipeByID :one

SELECT
	recipes.id,
	recipes.name,
	recipes.slug,
	recipes.source,
	recipes.description,
	recipes.inspired_by_recipe_id,
	recipes.min_estimated_portions,
	recipes.max_estimated_portions,
	recipes.portion_name,
	recipes.plural_portion_name,
	recipes.seal_of_approval,
	recipes.eligible_for_meals,
	recipes.yields_component_type,
	recipes.created_at,
	recipes.last_updated_at,
	recipes.archived_at,
	recipes.created_by_user,
	recipe_steps.id,
	recipe_steps.index,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	recipe_steps.minimum_estimated_time_in_seconds,
	recipe_steps.maximum_estimated_time_in_seconds,
	recipe_steps.minimum_temperature_in_celsius,
	recipe_steps.maximum_temperature_in_celsius,
	recipe_steps.notes,
	recipe_steps.explicit_instructions,
	recipe_steps.condition_expression,
	recipe_steps.optional,
	recipe_steps.start_timer_automatically,
	recipe_steps.created_at,
	recipe_steps.last_updated_at,
	recipe_steps.archived_at,
	recipe_steps.belongs_to_recipe
FROM recipes
	FULL OUTER JOIN recipe_steps ON recipes.id=recipe_steps.belongs_to_recipe
	FULL OUTER JOIN valid_preparations ON recipe_steps.preparation_id=valid_preparations.id
WHERE recipes.archived_at IS NULL
	AND recipes.id = $1
ORDER BY recipe_steps.index
`

type GetRecipeByIDRow struct {
	ID                            sql.NullString
	Name                          sql.NullString
	Slug                          sql.NullString
	Source                        sql.NullString
	Description                   sql.NullString
	InspiredByRecipeID            sql.NullString
	MinEstimatedPortions          sql.NullString
	MaxEstimatedPortions          sql.NullString
	PortionName                   sql.NullString
	PluralPortionName             sql.NullString
	SealOfApproval                sql.NullBool
	EligibleForMeals              sql.NullBool
	YieldsComponentType           NullComponentType
	CreatedAt                     sql.NullTime
	LastUpdatedAt                 sql.NullTime
	ArchivedAt                    sql.NullTime
	CreatedByUser                 sql.NullString
	ID_2                          sql.NullString
	Index                         sql.NullInt32
	ID_3                          sql.NullString
	Name_2                        sql.NullString
	Description_2                 sql.NullString
	IconPath                      sql.NullString
	YieldsNothing                 sql.NullBool
	RestrictToIngredients         sql.NullBool
	MinimumIngredientCount        sql.NullInt32
	MaximumIngredientCount        sql.NullInt32
	MinimumInstrumentCount        sql.NullInt32
	MaximumInstrumentCount        sql.NullInt32
	TemperatureRequired           sql.NullBool
	TimeEstimateRequired          sql.NullBool
	ConditionExpressionRequired   sql.NullBool
	ConsumesVessel                sql.NullBool
	OnlyForVessels                sql.NullBool
	MinimumVesselCount            sql.NullInt32
	MaximumVesselCount            sql.NullInt32
	Slug_2                        sql.NullString
	PastTense                     sql.NullString
	CreatedAt_2                   sql.NullTime
	LastUpdatedAt_2               sql.NullTime
	ArchivedAt_2                  sql.NullTime
	MinimumEstimatedTimeInSeconds sql.NullInt64
	MaximumEstimatedTimeInSeconds sql.NullInt64
	MinimumTemperatureInCelsius   sql.NullString
	MaximumTemperatureInCelsius   sql.NullString
	Notes                         sql.NullString
	ExplicitInstructions          sql.NullString
	ConditionExpression           sql.NullString
	Optional                      sql.NullBool
	StartTimerAutomatically       sql.NullBool
	CreatedAt_3                   sql.NullTime
	LastUpdatedAt_3               sql.NullTime
	ArchivedAt_3                  sql.NullTime
	BelongsToRecipe               sql.NullString
}

func (q *Queries) GetRecipeByID(ctx context.Context, db DBTX, id string) (*GetRecipeByIDRow, error) {
	row := db.QueryRowContext(ctx, getRecipeByID, id)
	var i GetRecipeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Source,
		&i.Description,
		&i.InspiredByRecipeID,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.PortionName,
		&i.PluralPortionName,
		&i.SealOfApproval,
		&i.EligibleForMeals,
		&i.YieldsComponentType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.ID_2,
		&i.Index,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug_2,
		&i.PastTense,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumEstimatedTimeInSeconds,
		&i.MaximumEstimatedTimeInSeconds,
		&i.MinimumTemperatureInCelsius,
		&i.MaximumTemperatureInCelsius,
		&i.Notes,
		&i.ExplicitInstructions,
		&i.ConditionExpression,
		&i.Optional,
		&i.StartTimerAutomatically,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.BelongsToRecipe,
	)
	return &i, err
}

const getServiceSettingConfigurationByID = `-- name: GetServiceSettingConfigurationByID :one

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.id = $1
`

type GetServiceSettingConfigurationByIDRow struct {
	ID                 string
	Value              string
	Notes              string
	ID_2               string
	Name               string
	Type               SettingType
	Description        string
	DefaultValue       sql.NullString
	Enumeration        string
	AdminsOnly         bool
	CreatedAt          time.Time
	LastUpdatedAt      sql.NullTime
	ArchivedAt         sql.NullTime
	BelongsToUser      string
	BelongsToHousehold string
	CreatedAt_2        time.Time
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt_2       sql.NullTime
}

func (q *Queries) GetServiceSettingConfigurationByID(ctx context.Context, db DBTX, id string) (*GetServiceSettingConfigurationByIDRow, error) {
	row := db.QueryRowContext(ctx, getServiceSettingConfigurationByID, id)
	var i GetServiceSettingConfigurationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.Enumeration,
		&i.AdminsOnly,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToUser,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	ID                           string
	FirstName                    string
	LastName                     string
	Username                     string
	EmailAddress                 string
	EmailAddressVerifiedAt       sql.NullTime
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedAt        sql.NullTime
	TwoFactorSecret              string
	TwoFactorSecretVerifiedAt    sql.NullTime
	ServiceRole                  string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	Birthday                     sql.NullTime
	LastAcceptedTermsOfService   sql.NullTime
	LastAcceptedPrivacyPolicy    sql.NullTime
	CreatedAt                    time.Time
	LastUpdatedAt                sql.NullTime
	ArchivedAt                   sql.NullTime
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.EmailAddress,
		&i.EmailAddressVerifiedAt,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedAt,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidIngredientByID = `-- name: GetValidIngredientByID :one

SELECT
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius::float,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius::float,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at
    FROM valid_ingredients
    WHERE valid_ingredients.archived_at IS NULL
`

type GetValidIngredientByIDRow struct {
	ID                                                      string
	Name                                                    string
	Description                                             string
	Warning                                                 string
	ContainsEgg                                             bool
	ContainsDairy                                           bool
	ContainsPeanut                                          bool
	ContainsTreeNut                                         bool
	ContainsSoy                                             bool
	ContainsWheat                                           bool
	ContainsShellfish                                       bool
	ContainsSesame                                          bool
	ContainsFish                                            bool
	ContainsGluten                                          bool
	AnimalFlesh                                             bool
	Volumetric                                              bool
	IsLiquid                                                sql.NullBool
	IconPath                                                string
	AnimalDerived                                           bool
	PluralName                                              string
	RestrictToPreparations                                  bool
	ValidIngredientsMinimumIdealStorageTemperatureInCelsius float64
	ValidIngredientsMaximumIdealStorageTemperatureInCelsius float64
	StorageInstructions                                     string
	Slug                                                    string
	ContainsAlcohol                                         bool
	ShoppingSuggestions                                     string
	IsStarch                                                bool
	IsProtein                                               bool
	IsGrain                                                 bool
	IsFruit                                                 bool
	IsSalt                                                  bool
	IsFat                                                   bool
	IsAcid                                                  bool
	IsHeat                                                  bool
	CreatedAt                                               time.Time
	LastUpdatedAt                                           sql.NullTime
	ArchivedAt                                              sql.NullTime
}

func (q *Queries) GetValidIngredientByID(ctx context.Context, db DBTX) (*GetValidIngredientByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientByID)
	var i GetValidIngredientByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.ValidIngredientsMinimumIdealStorageTemperatureInCelsius,
		&i.ValidIngredientsMaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidMeasurementUnitByID = `-- name: GetValidMeasurementUnitByID :one

SELECT valid_measurement_units.id,
       valid_measurement_units.name,
       valid_measurement_units.description,
       valid_measurement_units.volumetric,
       valid_measurement_units.icon_path,
       valid_measurement_units.universal,
       valid_measurement_units.metric,
       valid_measurement_units.imperial,
       valid_measurement_units.slug,
       valid_measurement_units.plural_name,
       valid_measurement_units.created_at,
       valid_measurement_units.last_updated_at,
       valid_measurement_units.archived_at
  FROM valid_measurement_units
 WHERE valid_measurement_units.archived_at IS NULL
`

type GetValidMeasurementUnitByIDRow struct {
	ID            string
	Name          string
	Description   string
	Volumetric    sql.NullBool
	IconPath      string
	Universal     bool
	Metric        bool
	Imperial      bool
	Slug          string
	PluralName    string
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
}

func (q *Queries) GetValidMeasurementUnitByID(ctx context.Context, db DBTX) (*GetValidMeasurementUnitByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidMeasurementUnitByID)
	var i GetValidMeasurementUnitByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidPreparationByID = `-- name: GetValidPreparationByID :one

SELECT valid_preparations.id,
       valid_preparations.name,
       valid_preparations.description,
       valid_preparations.icon_path,
       valid_preparations.yields_nothing,
       valid_preparations.restrict_to_ingredients,
       valid_preparations.minimum_ingredient_count,
       valid_preparations.maximum_ingredient_count,
       valid_preparations.minimum_instrument_count,
       valid_preparations.maximum_instrument_count,
       valid_preparations.temperature_required,
       valid_preparations.time_estimate_required,
       valid_preparations.condition_expression_required,
       valid_preparations.consumes_vessel,
       valid_preparations.only_for_vessels,
       valid_preparations.minimum_vessel_count,
       valid_preparations.maximum_vessel_count,
       valid_preparations.slug,
       valid_preparations.past_tense,
       valid_preparations.created_at,
       valid_preparations.last_updated_at,
       valid_preparations.archived_at
  FROM valid_preparations
 WHERE valid_preparations.archived_at IS NULL
`

type GetValidPreparationByIDRow struct {
	ID                          string
	Name                        string
	Description                 string
	IconPath                    string
	YieldsNothing               bool
	RestrictToIngredients       bool
	MinimumIngredientCount      int32
	MaximumIngredientCount      sql.NullInt32
	MinimumInstrumentCount      int32
	MaximumInstrumentCount      sql.NullInt32
	TemperatureRequired         bool
	TimeEstimateRequired        bool
	ConditionExpressionRequired bool
	ConsumesVessel              bool
	OnlyForVessels              bool
	MinimumVesselCount          int32
	MaximumVesselCount          sql.NullInt32
	Slug                        string
	PastTense                   string
	CreatedAt                   time.Time
	LastUpdatedAt               sql.NullTime
	ArchivedAt                  sql.NullTime
}

func (q *Queries) GetValidPreparationByID(ctx context.Context, db DBTX) (*GetValidPreparationByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidPreparationByID)
	var i GetValidPreparationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}
