// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_by_id.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getRecipeByID = `-- name: GetRecipeByID :one

SELECT
	recipes.id,
	recipes.name,
	recipes.slug,
	recipes.source,
	recipes.description,
	recipes.inspired_by_recipe_id,
	recipes.min_estimated_portions,
	recipes.max_estimated_portions,
	recipes.portion_name,
	recipes.plural_portion_name,
	recipes.seal_of_approval,
	recipes.eligible_for_meals,
	recipes.yields_component_type,
	recipes.created_at,
	recipes.last_updated_at,
	recipes.archived_at,
	recipes.created_by_user,
	recipe_steps.id,
	recipe_steps.index,
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
	recipe_steps.minimum_estimated_time_in_seconds,
	recipe_steps.maximum_estimated_time_in_seconds,
	recipe_steps.minimum_temperature_in_celsius,
	recipe_steps.maximum_temperature_in_celsius,
	recipe_steps.notes,
	recipe_steps.explicit_instructions,
	recipe_steps.condition_expression,
	recipe_steps.optional,
	recipe_steps.start_timer_automatically,
	recipe_steps.created_at,
	recipe_steps.last_updated_at,
	recipe_steps.archived_at,
	recipe_steps.belongs_to_recipe
FROM recipes
	FULL OUTER JOIN recipe_steps ON recipes.id=recipe_steps.belongs_to_recipe
	FULL OUTER JOIN valid_preparations ON recipe_steps.preparation_id=valid_preparations.id
WHERE recipes.archived_at IS NULL
	AND recipes.id = $1
ORDER BY recipe_steps.index
`

type GetRecipeByIDRow struct {
	LastUpdatedAt_2               sql.NullTime
	CreatedAt                     sql.NullTime
	ArchivedAt_3                  sql.NullTime
	LastUpdatedAt_3               sql.NullTime
	CreatedAt_3                   sql.NullTime
	ArchivedAt_2                  sql.NullTime
	CreatedAt_2                   sql.NullTime
	ArchivedAt                    sql.NullTime
	LastUpdatedAt                 sql.NullTime
	MaximumTemperatureInCelsius   sql.NullString
	MinimumTemperatureInCelsius   sql.NullString
	BelongsToRecipe               sql.NullString
	YieldsComponentType           NullComponentType
	PluralPortionName             sql.NullString
	PortionName                   sql.NullString
	MaxEstimatedPortions          sql.NullString
	CreatedByUser                 sql.NullString
	ID_2                          sql.NullString
	Source                        sql.NullString
	ID_3                          sql.NullString
	Name_2                        sql.NullString
	Description_2                 sql.NullString
	IconPath                      sql.NullString
	Description                   sql.NullString
	ConditionExpression           sql.NullString
	ExplicitInstructions          sql.NullString
	Slug                          sql.NullString
	Notes                         sql.NullString
	Name                          sql.NullString
	InspiredByRecipeID            sql.NullString
	ID                            sql.NullString
	MinEstimatedPortions          sql.NullString
	PastTense                     sql.NullString
	Slug_2                        sql.NullString
	MinimumEstimatedTimeInSeconds sql.NullInt64
	MaximumEstimatedTimeInSeconds sql.NullInt64
	MinimumInstrumentCount        sql.NullInt32
	MaximumInstrumentCount        sql.NullInt32
	MaximumIngredientCount        sql.NullInt32
	Index                         sql.NullInt32
	MinimumVesselCount            sql.NullInt32
	MinimumIngredientCount        sql.NullInt32
	MaximumVesselCount            sql.NullInt32
	OnlyForVessels                sql.NullBool
	SealOfApproval                sql.NullBool
	StartTimerAutomatically       sql.NullBool
	ConsumesVessel                sql.NullBool
	RestrictToIngredients         sql.NullBool
	Optional                      sql.NullBool
	TemperatureRequired           sql.NullBool
	YieldsNothing                 sql.NullBool
	TimeEstimateRequired          sql.NullBool
	ConditionExpressionRequired   sql.NullBool
	EligibleForMeals              sql.NullBool
}

func (q *Queries) GetRecipeByID(ctx context.Context, db DBTX, id string) (*GetRecipeByIDRow, error) {
	row := db.QueryRowContext(ctx, getRecipeByID, id)
	var i GetRecipeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Source,
		&i.Description,
		&i.InspiredByRecipeID,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.PortionName,
		&i.PluralPortionName,
		&i.SealOfApproval,
		&i.EligibleForMeals,
		&i.YieldsComponentType,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.ID_2,
		&i.Index,
		&i.ID_3,
		&i.Name_2,
		&i.Description_2,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug_2,
		&i.PastTense,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
		&i.MinimumEstimatedTimeInSeconds,
		&i.MaximumEstimatedTimeInSeconds,
		&i.MinimumTemperatureInCelsius,
		&i.MaximumTemperatureInCelsius,
		&i.Notes,
		&i.ExplicitInstructions,
		&i.ConditionExpression,
		&i.Optional,
		&i.StartTimerAutomatically,
		&i.CreatedAt_3,
		&i.LastUpdatedAt_3,
		&i.ArchivedAt_3,
		&i.BelongsToRecipe,
	)
	return &i, err
}

const getServiceSettingConfigurationByID = `-- name: GetServiceSettingConfigurationByID :one

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.id = $1
`

type GetServiceSettingConfigurationByIDRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationByID(ctx context.Context, db DBTX, id string) (*GetServiceSettingConfigurationByIDRow, error) {
	row := db.QueryRowContext(ctx, getServiceSettingConfigurationByID, id)
	var i GetServiceSettingConfigurationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.Enumeration,
		&i.AdminsOnly,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToUser,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const getUserByID = `-- name: GetUserByID :one

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at
FROM users
WHERE users.archived_at IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	CreatedAt                    time.Time
	Birthday                     sql.NullTime
	ArchivedAt                   sql.NullTime
	PasswordLastChangedAt        sql.NullTime
	LastUpdatedAt                sql.NullTime
	EmailAddressVerifiedAt       sql.NullTime
	LastAcceptedPrivacyPolicy    sql.NullTime
	LastAcceptedTermsOfService   sql.NullTime
	TwoFactorSecretVerifiedAt    sql.NullTime
	UserAccountStatusExplanation string
	FirstName                    string
	ServiceRole                  string
	UserAccountStatus            string
	LastName                     string
	ID                           string
	HashedPassword               string
	TwoFactorSecret              string
	EmailAddress                 string
	Username                     string
	AvatarSrc                    sql.NullString
	RequiresPasswordChange       bool
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRowContext(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Username,
		&i.EmailAddress,
		&i.EmailAddressVerifiedAt,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedAt,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedAt,
		&i.ServiceRole,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.Birthday,
		&i.LastAcceptedTermsOfService,
		&i.LastAcceptedPrivacyPolicy,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidIngredientByID = `-- name: GetValidIngredientByID :one

SELECT
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at
    FROM valid_ingredients
    WHERE valid_ingredients.archived_at IS NULL
`

type GetValidIngredientByIDRow struct {
	CreatedAt                               time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	Warning                                 string
	Description                             string
	Name                                    string
	ShoppingSuggestions                     string
	Slug                                    string
	StorageInstructions                     string
	PluralName                              string
	ID                                      string
	IconPath                                string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	IsLiquid                                sql.NullBool
	AnimalDerived                           bool
	ContainsTreeNut                         bool
	AnimalFlesh                             bool
	ContainsGluten                          bool
	ContainsFish                            bool
	RestrictToPreparations                  bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsWheat                           bool
	ContainsSoy                             bool
	ContainsAlcohol                         bool
	Volumetric                              bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredientByID(ctx context.Context, db DBTX) (*GetValidIngredientByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidIngredientByID)
	var i GetValidIngredientByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidMeasurementUnitByID = `-- name: GetValidMeasurementUnitByID :one

SELECT valid_measurement_units.id,
       valid_measurement_units.name,
       valid_measurement_units.description,
       valid_measurement_units.volumetric,
       valid_measurement_units.icon_path,
       valid_measurement_units.universal,
       valid_measurement_units.metric,
       valid_measurement_units.imperial,
       valid_measurement_units.slug,
       valid_measurement_units.plural_name,
       valid_measurement_units.created_at,
       valid_measurement_units.last_updated_at,
       valid_measurement_units.archived_at
  FROM valid_measurement_units
 WHERE valid_measurement_units.archived_at IS NULL
`

type GetValidMeasurementUnitByIDRow struct {
	CreatedAt     time.Time
	ArchivedAt    sql.NullTime
	LastUpdatedAt sql.NullTime
	PluralName    string
	Name          string
	Description   string
	ID            string
	IconPath      string
	Slug          string
	Volumetric    sql.NullBool
	Imperial      bool
	Metric        bool
	Universal     bool
}

func (q *Queries) GetValidMeasurementUnitByID(ctx context.Context, db DBTX) (*GetValidMeasurementUnitByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidMeasurementUnitByID)
	var i GetValidMeasurementUnitByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidPreparationByID = `-- name: GetValidPreparationByID :one

SELECT valid_preparations.id,
       valid_preparations.name,
       valid_preparations.description,
       valid_preparations.icon_path,
       valid_preparations.yields_nothing,
       valid_preparations.restrict_to_ingredients,
       valid_preparations.minimum_ingredient_count,
       valid_preparations.maximum_ingredient_count,
       valid_preparations.minimum_instrument_count,
       valid_preparations.maximum_instrument_count,
       valid_preparations.temperature_required,
       valid_preparations.time_estimate_required,
       valid_preparations.condition_expression_required,
       valid_preparations.consumes_vessel,
       valid_preparations.only_for_vessels,
       valid_preparations.minimum_vessel_count,
       valid_preparations.maximum_vessel_count,
       valid_preparations.slug,
       valid_preparations.past_tense,
       valid_preparations.created_at,
       valid_preparations.last_updated_at,
       valid_preparations.archived_at
  FROM valid_preparations
 WHERE valid_preparations.archived_at IS NULL
`

type GetValidPreparationByIDRow struct {
	CreatedAt                   time.Time
	LastUpdatedAt               sql.NullTime
	ArchivedAt                  sql.NullTime
	Name                        string
	Description                 string
	IconPath                    string
	ID                          string
	Slug                        string
	PastTense                   string
	MaximumInstrumentCount      sql.NullInt32
	MaximumIngredientCount      sql.NullInt32
	MaximumVesselCount          sql.NullInt32
	MinimumVesselCount          int32
	MinimumInstrumentCount      int32
	MinimumIngredientCount      int32
	RestrictToIngredients       bool
	OnlyForVessels              bool
	ConsumesVessel              bool
	ConditionExpressionRequired bool
	TimeEstimateRequired        bool
	TemperatureRequired         bool
	YieldsNothing               bool
}

func (q *Queries) GetValidPreparationByID(ctx context.Context, db DBTX) (*GetValidPreparationByIDRow, error) {
	row := db.QueryRowContext(ctx, getValidPreparationByID)
	var i GetValidPreparationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}
