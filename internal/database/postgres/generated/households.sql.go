// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: households.sql

package generated

import (
	"context"
	"database/sql"
)

const AddUserToHouseholdDuringCreation = `-- name: AddUserToHouseholdDuringCreation :exec
INSERT INTO household_user_memberships (id,belongs_to_user,belongs_to_household,household_roles)
	VALUES ($1,$2,$3,$4)
`

type AddUserToHouseholdDuringCreationParams struct {
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	HouseholdRoles     string
}

func (q *Queries) AddUserToHouseholdDuringCreation(ctx context.Context, arg *AddUserToHouseholdDuringCreationParams) error {
	_, err := q.db.ExecContext(ctx, AddUserToHouseholdDuringCreation,
		arg.ID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
		arg.HouseholdRoles,
	)
	return err
}

const ArchiveHousehold = `-- name: ArchiveHousehold :exec
UPDATE households SET last_updated_on = extract(epoch FROM NOW()), archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_user = $1 AND id = $2
`

type ArchiveHouseholdParams struct {
	BelongsToUser string
	ID            string
}

func (q *Queries) ArchiveHousehold(ctx context.Context, arg *ArchiveHouseholdParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveHousehold, arg.BelongsToUser, arg.ID)
	return err
}

const CreateHousehold = `-- name: CreateHousehold :exec
INSERT INTO households (id,name,billing_status,contact_email,contact_phone,belongs_to_user) VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateHouseholdParams struct {
	ID            string
	Name          string
	BillingStatus string
	ContactEmail  string
	ContactPhone  string
	BelongsToUser string
}

func (q *Queries) CreateHousehold(ctx context.Context, arg *CreateHouseholdParams) error {
	_, err := q.db.ExecContext(ctx, CreateHousehold,
		arg.ID,
		arg.Name,
		arg.BillingStatus,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.BelongsToUser,
	)
	return err
}

const GetAllHouseholdsCount = `-- name: GetAllHouseholdsCount :one
SELECT COUNT(households.id) FROM households WHERE households.archived_on IS NULL
`

func (q *Queries) GetAllHouseholdsCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetAllHouseholdsCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetHousehold = `-- name: GetHousehold :many
SELECT
		households.id,
		households.name,
		households.billing_status,
		households.contact_email,
		households.contact_phone,
		households.payment_processor_customer_id,
		households.subscription_plan_id,
		households.created_on,
		households.last_updated_on,
		households.archived_on,
		households.belongs_to_user,
		users.id,
		users.username,
		users.email_address,
		users.avatar_src,
		users.requires_password_change,
		users.password_last_changed_on,
		users.two_factor_secret_verified_on,
		users.service_roles,
		users.user_account_status,
		users.user_account_status_explanation,
		users.birth_day,
		users.birth_month,
		users.created_on,
		users.last_updated_on,
		users.archived_on,
		household_user_memberships.id,
		household_user_memberships.belongs_to_user,
		household_user_memberships.belongs_to_household,
		household_user_memberships.household_roles,
		household_user_memberships.default_household,
		household_user_memberships.created_on,
		household_user_memberships.last_updated_on,
		household_user_memberships.archived_on
	FROM household_user_memberships
	JOIN households ON household_user_memberships.belongs_to_household = households.id
	JOIN users ON household_user_memberships.belongs_to_user = users.id
	WHERE households.archived_on IS NULL
	AND household_user_memberships.archived_on IS NULL
	AND households.id = $1
`

type GetHouseholdRow struct {
	ID                           string
	Name                         string
	BillingStatus                string
	ContactEmail                 string
	ContactPhone                 string
	PaymentProcessorCustomerID   string
	SubscriptionPlanID           sql.NullString
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
	BelongsToUser                string
	ID_2                         string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn_2                  int64
	LastUpdatedOn_2              sql.NullInt64
	ArchivedOn_2                 sql.NullInt64
	ID_3                         string
	BelongsToUser_2              string
	BelongsToHousehold           string
	HouseholdRoles               string
	DefaultHousehold             bool
	CreatedOn_3                  int64
	LastUpdatedOn_3              sql.NullInt64
	ArchivedOn_3                 sql.NullInt64
}

func (q *Queries) GetHousehold(ctx context.Context, id string) ([]*GetHouseholdRow, error) {
	rows, err := q.db.QueryContext(ctx, GetHousehold, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetHouseholdRow
	for rows.Next() {
		var i GetHouseholdRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingStatus,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.PaymentProcessorCustomerID,
			&i.SubscriptionPlanID,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.BelongsToUser,
			&i.ID_2,
			&i.Username,
			&i.EmailAddress,
			&i.AvatarSrc,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedOn,
			&i.TwoFactorSecretVerifiedOn,
			&i.ServiceRoles,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.BirthDay,
			&i.BirthMonth,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.ID_3,
			&i.BelongsToUser_2,
			&i.BelongsToHousehold,
			&i.HouseholdRoles,
			&i.DefaultHousehold,
			&i.CreatedOn_3,
			&i.LastUpdatedOn_3,
			&i.ArchivedOn_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetHouseholdByID = `-- name: GetHouseholdByID :many
SELECT
		households.id,
		households.name,
		households.billing_status,
		households.contact_email,
		households.contact_phone,
		households.payment_processor_customer_id,
		households.subscription_plan_id,
		households.created_on,
		households.last_updated_on,
		households.archived_on,
		households.belongs_to_user,
        users.id,
        users.username,
        users.email_address,
        users.avatar_src,
        users.requires_password_change,
        users.password_last_changed_on,
        users.two_factor_secret_verified_on,
        users.service_roles,
        users.user_account_status,
        users.user_account_status_explanation,
        users.birth_day,
        users.birth_month,
        users.created_on,
        users.last_updated_on,
        users.archived_on,
		household_user_memberships.id,
		household_user_memberships.belongs_to_user,
		household_user_memberships.belongs_to_household,
		household_user_memberships.household_roles,
		household_user_memberships.default_household,
		household_user_memberships.created_on,
		household_user_memberships.last_updated_on,
		household_user_memberships.archived_on
	FROM households
	JOIN household_user_memberships ON household_user_memberships.belongs_to_household = households.id
	JOIN users ON household_user_memberships.belongs_to_user = users.id
	WHERE households.archived_on IS NULL
	AND households.id = $1
`

type GetHouseholdByIDRow struct {
	ID                           string
	Name                         string
	BillingStatus                string
	ContactEmail                 string
	ContactPhone                 string
	PaymentProcessorCustomerID   string
	SubscriptionPlanID           sql.NullString
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
	BelongsToUser                string
	ID_2                         string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn_2                  int64
	LastUpdatedOn_2              sql.NullInt64
	ArchivedOn_2                 sql.NullInt64
	ID_3                         string
	BelongsToUser_2              string
	BelongsToHousehold           string
	HouseholdRoles               string
	DefaultHousehold             bool
	CreatedOn_3                  int64
	LastUpdatedOn_3              sql.NullInt64
	ArchivedOn_3                 sql.NullInt64
}

func (q *Queries) GetHouseholdByID(ctx context.Context, id string) ([]*GetHouseholdByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, GetHouseholdByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetHouseholdByIDRow
	for rows.Next() {
		var i GetHouseholdByIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingStatus,
			&i.ContactEmail,
			&i.ContactPhone,
			&i.PaymentProcessorCustomerID,
			&i.SubscriptionPlanID,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.BelongsToUser,
			&i.ID_2,
			&i.Username,
			&i.EmailAddress,
			&i.AvatarSrc,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedOn,
			&i.TwoFactorSecretVerifiedOn,
			&i.ServiceRoles,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.BirthDay,
			&i.BirthMonth,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.ID_3,
			&i.BelongsToUser_2,
			&i.BelongsToHousehold,
			&i.HouseholdRoles,
			&i.DefaultHousehold,
			&i.CreatedOn_3,
			&i.LastUpdatedOn_3,
			&i.ArchivedOn_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateHousehold = `-- name: UpdateHousehold :exec
UPDATE households SET name = $1, contact_email = $2, contact_phone = $3, last_updated_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_user = $4 AND id = $5
`

type UpdateHouseholdParams struct {
	Name          string
	ContactEmail  string
	ContactPhone  string
	BelongsToUser string
	ID            string
}

func (q *Queries) UpdateHousehold(ctx context.Context, arg *UpdateHouseholdParams) error {
	_, err := q.db.ExecContext(ctx, UpdateHousehold,
		arg.Name,
		arg.ContactEmail,
		arg.ContactPhone,
		arg.BelongsToUser,
		arg.ID,
	)
	return err
}
