// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: password_reset_tokens.sql

package generated

import (
	"context"
)

const CreatePasswordResetToken = `-- name: CreatePasswordResetToken :exec
INSERT INTO password_reset_tokens (id,token,expires_at,belongs_to_user) VALUES ($1,$2,extract(epoch from (NOW() + (30 * interval '1 minutes'))),$3)
`

type CreatePasswordResetTokenParams struct {
	ID            string
	Token         string
	BelongsToUser string
}

func (q *Queries) CreatePasswordResetToken(ctx context.Context, arg *CreatePasswordResetTokenParams) error {
	_, err := q.db.ExecContext(ctx, CreatePasswordResetToken, arg.ID, arg.Token, arg.BelongsToUser)
	return err
}

const GetPasswordResetToken = `-- name: GetPasswordResetToken :one
SELECT
	password_reset_tokens.id,
	password_reset_tokens.token,
	password_reset_tokens.expires_at,
	password_reset_tokens.created_on,
	password_reset_tokens.last_updated_on,
	password_reset_tokens.redeemed_on,
	password_reset_tokens.belongs_to_user
FROM password_reset_tokens
WHERE password_reset_tokens.redeemed_on IS NULL
AND extract(epoch from NOW()) < password_reset_tokens.expires_at
AND password_reset_tokens.token = $1
`

func (q *Queries) GetPasswordResetToken(ctx context.Context, token string) (*PasswordResetTokens, error) {
	row := q.db.QueryRowContext(ctx, GetPasswordResetToken, token)
	var i PasswordResetTokens
	err := row.Scan(
		&i.ID,
		&i.Token,
		&i.ExpiresAt,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.RedeemedOn,
		&i.BelongsToUser,
	)
	return &i, err
}

const RedeemPasswordResetToken = `-- name: RedeemPasswordResetToken :exec
UPDATE password_reset_tokens SET redeemed_on = extract(epoch FROM NOW()) WHERE redeemed_on IS NULL AND id = $1
`

func (q *Queries) RedeemPasswordResetToken(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, RedeemPasswordResetToken, id)
	return err
}
