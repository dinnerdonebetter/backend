// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: update.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const UpdateHousehold = `-- name: UpdateHousehold :exec

UPDATE households
SET
	name = $1,
	contact_phone = $2,
	address_line_1 = $3,
	address_line_2 = $4,
	city = $5,
	state = $6,
	zip_code = $7,
	country = $8,
	latitude = $9,
    longitude = $10,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $11
	AND id = $12
`

type UpdateHouseholdParams struct {
	Name          string         `db:"name"`
	ContactPhone  string         `db:"contact_phone"`
	AddressLine1  string         `db:"address_line_1"`
	AddressLine2  string         `db:"address_line_2"`
	City          string         `db:"city"`
	State         string         `db:"state"`
	ZipCode       string         `db:"zip_code"`
	Country       string         `db:"country"`
	BelongsToUser string         `db:"belongs_to_user"`
	ID            string         `db:"id"`
	Latitude      sql.NullString `db:"latitude"`
	Longitude     sql.NullString `db:"longitude"`
}

func (q *Queries) UpdateHousehold(ctx context.Context, db DBTX, arg *UpdateHouseholdParams) error {
	_, err := db.ExecContext(ctx, UpdateHousehold,
		arg.Name,
		arg.ContactPhone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.BelongsToUser,
		arg.ID,
	)
	return err
}

const UpdateHouseholdInstrumentOwnership = `-- name: UpdateHouseholdInstrumentOwnership :exec

UPDATE household_instrument_ownerships
SET
	notes = $1,
	quantity = $2,
	valid_instrument_id = $3,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $4
	AND household_instrument_ownerships.belongs_to_household = $5
`

type UpdateHouseholdInstrumentOwnershipParams struct {
	Notes              string `db:"notes"`
	ValidInstrumentID  string `db:"valid_instrument_id"`
	ID                 string `db:"id"`
	BelongsToHousehold string `db:"belongs_to_household"`
	Quantity           int32  `db:"quantity"`
}

func (q *Queries) UpdateHouseholdInstrumentOwnership(ctx context.Context, db DBTX, arg *UpdateHouseholdInstrumentOwnershipParams) error {
	_, err := db.ExecContext(ctx, UpdateHouseholdInstrumentOwnership,
		arg.Notes,
		arg.Quantity,
		arg.ValidInstrumentID,
		arg.ID,
		arg.BelongsToHousehold,
	)
	return err
}

const UpdateMealPlan = `-- name: UpdateMealPlan :exec

UPDATE meal_plans SET notes = $1, status = $2, voting_deadline = $3, last_updated_at = NOW() WHERE archived_at IS NULL AND belongs_to_household = $4 AND id = $5
`

type UpdateMealPlanParams struct {
	Notes              string         `db:"notes"`
	Status             MealPlanStatus `db:"status"`
	VotingDeadline     time.Time      `db:"voting_deadline"`
	BelongsToHousehold string         `db:"belongs_to_household"`
	ID                 string         `db:"id"`
}

func (q *Queries) UpdateMealPlan(ctx context.Context, db DBTX, arg *UpdateMealPlanParams) error {
	_, err := db.ExecContext(ctx, UpdateMealPlan,
		arg.Notes,
		arg.Status,
		arg.VotingDeadline,
		arg.BelongsToHousehold,
		arg.ID,
	)
	return err
}

const UpdateMealPlanEvent = `-- name: UpdateMealPlanEvent :exec

UPDATE meal_plan_events
SET notes = $1,
	starts_at = $2,
	ends_at = $3,
	meal_name = $4,
	belongs_to_meal_plan = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateMealPlanEventParams struct {
	Notes             string    `db:"notes"`
	StartsAt          time.Time `db:"starts_at"`
	EndsAt            time.Time `db:"ends_at"`
	MealName          MealName  `db:"meal_name"`
	BelongsToMealPlan string    `db:"belongs_to_meal_plan"`
	ID                string    `db:"id"`
}

func (q *Queries) UpdateMealPlanEvent(ctx context.Context, db DBTX, arg *UpdateMealPlanEventParams) error {
	_, err := db.ExecContext(ctx, UpdateMealPlanEvent,
		arg.Notes,
		arg.StartsAt,
		arg.EndsAt,
		arg.MealName,
		arg.BelongsToMealPlan,
		arg.ID,
	)
	return err
}

const UpdateMealPlanGroceryListItem = `-- name: UpdateMealPlanGroceryListItem :exec

UPDATE meal_plan_grocery_list_items
SET
	belongs_to_meal_plan = $1,
	valid_ingredient = $2,
	valid_measurement_unit = $3,
	minimum_quantity_needed = $4,
	maximum_quantity_needed = $5,
	quantity_purchased = $6,
	purchased_measurement_unit = $7,
	purchased_upc = $8,
	purchase_price = $9,
	status_explanation = $10,
	status = $11,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $12
`

type UpdateMealPlanGroceryListItemParams struct {
	BelongsToMealPlan        string                `db:"belongs_to_meal_plan"`
	ValidIngredient          string                `db:"valid_ingredient"`
	ValidMeasurementUnit     string                `db:"valid_measurement_unit"`
	MinimumQuantityNeeded    string                `db:"minimum_quantity_needed"`
	StatusExplanation        string                `db:"status_explanation"`
	Status                   GroceryListItemStatus `db:"status"`
	ID                       string                `db:"id"`
	MaximumQuantityNeeded    sql.NullString        `db:"maximum_quantity_needed"`
	QuantityPurchased        sql.NullString        `db:"quantity_purchased"`
	PurchasedMeasurementUnit sql.NullString        `db:"purchased_measurement_unit"`
	PurchasedUpc             sql.NullString        `db:"purchased_upc"`
	PurchasePrice            sql.NullString        `db:"purchase_price"`
}

func (q *Queries) UpdateMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *UpdateMealPlanGroceryListItemParams) error {
	_, err := db.ExecContext(ctx, UpdateMealPlanGroceryListItem,
		arg.BelongsToMealPlan,
		arg.ValidIngredient,
		arg.ValidMeasurementUnit,
		arg.MinimumQuantityNeeded,
		arg.MaximumQuantityNeeded,
		arg.QuantityPurchased,
		arg.PurchasedMeasurementUnit,
		arg.PurchasedUpc,
		arg.PurchasePrice,
		arg.StatusExplanation,
		arg.Status,
		arg.ID,
	)
	return err
}

const UpdateMealPlanOption = `-- name: UpdateMealPlanOption :exec

UPDATE meal_plan_options
SET
	assigned_cook = $1,
	assigned_dishwasher = $2,
	meal_id = $3,
	notes = $4,
	meal_scale = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_meal_plan_event = $6
	AND id = $7
`

type UpdateMealPlanOptionParams struct {
	MealID                 string         `db:"meal_id"`
	Notes                  string         `db:"notes"`
	MealScale              string         `db:"meal_scale"`
	ID                     string         `db:"id"`
	AssignedCook           sql.NullString `db:"assigned_cook"`
	AssignedDishwasher     sql.NullString `db:"assigned_dishwasher"`
	BelongsToMealPlanEvent sql.NullString `db:"belongs_to_meal_plan_event"`
}

func (q *Queries) UpdateMealPlanOption(ctx context.Context, db DBTX, arg *UpdateMealPlanOptionParams) error {
	_, err := db.ExecContext(ctx, UpdateMealPlanOption,
		arg.AssignedCook,
		arg.AssignedDishwasher,
		arg.MealID,
		arg.Notes,
		arg.MealScale,
		arg.BelongsToMealPlanEvent,
		arg.ID,
	)
	return err
}

const UpdateMealPlanOptionVote = `-- name: UpdateMealPlanOptionVote :exec

UPDATE meal_plan_option_votes SET rank = $1, abstain = $2, notes = $3, by_user = $4, last_updated_at = NOW() WHERE archived_at IS NULL AND belongs_to_meal_plan_option = $5 AND id = $6
`

type UpdateMealPlanOptionVoteParams struct {
	Notes                   string `db:"notes"`
	ByUser                  string `db:"by_user"`
	BelongsToMealPlanOption string `db:"belongs_to_meal_plan_option"`
	ID                      string `db:"id"`
	Rank                    int32  `db:"rank"`
	Abstain                 bool   `db:"abstain"`
}

func (q *Queries) UpdateMealPlanOptionVote(ctx context.Context, db DBTX, arg *UpdateMealPlanOptionVoteParams) error {
	_, err := db.ExecContext(ctx, UpdateMealPlanOptionVote,
		arg.Rank,
		arg.Abstain,
		arg.Notes,
		arg.ByUser,
		arg.BelongsToMealPlanOption,
		arg.ID,
	)
	return err
}

const UpdateRecipe = `-- name: UpdateRecipe :exec

UPDATE recipes SET
    name = $1,
    slug = $2,
    source = $3,
    description = $4,
    inspired_by_recipe_id = $5,
	min_estimated_portions = $6,
	max_estimated_portions = $7,
    portion_name = $8,
    plural_portion_name = $9,
    seal_of_approval = $10,
    eligible_for_meals = $11,
	yields_component_type = $12,
    last_updated_at = NOW()
WHERE archived_at IS NULL
  AND created_by_user = $13
  AND id = $14
`

type UpdateRecipeParams struct {
	YieldsComponentType  ComponentType  `db:"yields_component_type"`
	Slug                 string         `db:"slug"`
	Source               string         `db:"source"`
	Description          string         `db:"description"`
	ID                   string         `db:"id"`
	MinEstimatedPortions string         `db:"min_estimated_portions"`
	Name                 string         `db:"name"`
	PortionName          string         `db:"portion_name"`
	PluralPortionName    string         `db:"plural_portion_name"`
	CreatedByUser        string         `db:"created_by_user"`
	MaxEstimatedPortions sql.NullString `db:"max_estimated_portions"`
	InspiredByRecipeID   sql.NullString `db:"inspired_by_recipe_id"`
	EligibleForMeals     bool           `db:"eligible_for_meals"`
	SealOfApproval       bool           `db:"seal_of_approval"`
}

func (q *Queries) UpdateRecipe(ctx context.Context, db DBTX, arg *UpdateRecipeParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipe,
		arg.Name,
		arg.Slug,
		arg.Source,
		arg.Description,
		arg.InspiredByRecipeID,
		arg.MinEstimatedPortions,
		arg.MaxEstimatedPortions,
		arg.PortionName,
		arg.PluralPortionName,
		arg.SealOfApproval,
		arg.EligibleForMeals,
		arg.YieldsComponentType,
		arg.CreatedByUser,
		arg.ID,
	)
	return err
}

const UpdateRecipeMedia = `-- name: UpdateRecipeMedia :exec

UPDATE recipe_media
SET
	belongs_to_recipe = $1,
	belongs_to_recipe_step = $2,
	mime_type = $3,
	internal_path = $4,
	external_path = $5,
	"index" = $6,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateRecipeMediaParams struct {
	MimeType            string         `db:"mime_type"`
	InternalPath        string         `db:"internal_path"`
	ExternalPath        string         `db:"external_path"`
	BelongsToRecipe     sql.NullString `db:"belongs_to_recipe"`
	BelongsToRecipeStep sql.NullString `db:"belongs_to_recipe_step"`
	Index               int32          `db:"index"`
}

func (q *Queries) UpdateRecipeMedia(ctx context.Context, db DBTX, arg *UpdateRecipeMediaParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeMedia,
		arg.BelongsToRecipe,
		arg.BelongsToRecipeStep,
		arg.MimeType,
		arg.InternalPath,
		arg.ExternalPath,
		arg.Index,
	)
	return err
}

const UpdateRecipePrepTask = `-- name: UpdateRecipePrepTask :exec

UPDATE recipe_prep_tasks SET
	 name = $1,
	 description = $2,
	 notes = $3,
	 optional = $4,
	 explicit_storage_instructions = $5,
	 minimum_time_buffer_before_recipe_in_seconds = $6,
	 maximum_time_buffer_before_recipe_in_seconds = $7,
	 storage_type = $8,
	 minimum_storage_temperature_in_celsius = $9,
	 maximum_storage_temperature_in_celsius = $10,
	 belongs_to_recipe = $11,
	 last_updated_at = NOW()
WHERE archived_at IS NULL AND id = $12
`

type UpdateRecipePrepTaskParams struct {
	Name                                   string                   `db:"name"`
	Description                            string                   `db:"description"`
	Notes                                  string                   `db:"notes"`
	ExplicitStorageInstructions            string                   `db:"explicit_storage_instructions"`
	BelongsToRecipe                        string                   `db:"belongs_to_recipe"`
	ID                                     string                   `db:"id"`
	StorageType                            NullStorageContainerType `db:"storage_type"`
	MinimumStorageTemperatureInCelsius     sql.NullString           `db:"minimum_storage_temperature_in_celsius"`
	MaximumStorageTemperatureInCelsius     sql.NullString           `db:"maximum_storage_temperature_in_celsius"`
	MaximumTimeBufferBeforeRecipeInSeconds sql.NullInt32            `db:"maximum_time_buffer_before_recipe_in_seconds"`
	MinimumTimeBufferBeforeRecipeInSeconds int32                    `db:"minimum_time_buffer_before_recipe_in_seconds"`
	Optional                               bool                     `db:"optional"`
}

func (q *Queries) UpdateRecipePrepTask(ctx context.Context, db DBTX, arg *UpdateRecipePrepTaskParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipePrepTask,
		arg.Name,
		arg.Description,
		arg.Notes,
		arg.Optional,
		arg.ExplicitStorageInstructions,
		arg.MinimumTimeBufferBeforeRecipeInSeconds,
		arg.MaximumTimeBufferBeforeRecipeInSeconds,
		arg.StorageType,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.BelongsToRecipe,
		arg.ID,
	)
	return err
}

const UpdateRecipeRating = `-- name: UpdateRecipeRating :exec

UPDATE recipe_ratings
SET
	recipe_id = $1,
    taste = $2,
    difficulty = $3,
    cleanup = $4,
    instructions = $5,
    overall = $6,
    notes = $7,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $8
`

type UpdateRecipeRatingParams struct {
	RecipeID     string         `db:"recipe_id"`
	Notes        string         `db:"notes"`
	ID           string         `db:"id"`
	Taste        sql.NullString `db:"taste"`
	Difficulty   sql.NullString `db:"difficulty"`
	Cleanup      sql.NullString `db:"cleanup"`
	Instructions sql.NullString `db:"instructions"`
	Overall      sql.NullString `db:"overall"`
}

func (q *Queries) UpdateRecipeRating(ctx context.Context, db DBTX, arg *UpdateRecipeRatingParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeRating,
		arg.RecipeID,
		arg.Taste,
		arg.Difficulty,
		arg.Cleanup,
		arg.Instructions,
		arg.Overall,
		arg.Notes,
		arg.ID,
	)
	return err
}

const UpdateRecipeStep = `-- name: UpdateRecipeStep :exec

UPDATE recipe_steps SET
	index = $1,
	preparation_id = $2,
	minimum_estimated_time_in_seconds = $3,
	maximum_estimated_time_in_seconds = $4,
	minimum_temperature_in_celsius = $5,
	maximum_temperature_in_celsius = $6,
	notes = $7,
	explicit_instructions = $8,
	condition_expression = $9,
	optional = $10,
	start_timer_automatically = $11,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe = $12
	AND id = $13
`

type UpdateRecipeStepParams struct {
	ConditionExpression           string         `db:"condition_expression"`
	PreparationID                 string         `db:"preparation_id"`
	ID                            string         `db:"id"`
	BelongsToRecipe               string         `db:"belongs_to_recipe"`
	Notes                         string         `db:"notes"`
	ExplicitInstructions          string         `db:"explicit_instructions"`
	MinimumTemperatureInCelsius   sql.NullString `db:"minimum_temperature_in_celsius"`
	MaximumTemperatureInCelsius   sql.NullString `db:"maximum_temperature_in_celsius"`
	MaximumEstimatedTimeInSeconds sql.NullInt64  `db:"maximum_estimated_time_in_seconds"`
	MinimumEstimatedTimeInSeconds sql.NullInt64  `db:"minimum_estimated_time_in_seconds"`
	Index                         int32          `db:"index"`
	Optional                      bool           `db:"optional"`
	StartTimerAutomatically       bool           `db:"start_timer_automatically"`
}

func (q *Queries) UpdateRecipeStep(ctx context.Context, db DBTX, arg *UpdateRecipeStepParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStep,
		arg.Index,
		arg.PreparationID,
		arg.MinimumEstimatedTimeInSeconds,
		arg.MaximumEstimatedTimeInSeconds,
		arg.MinimumTemperatureInCelsius,
		arg.MaximumTemperatureInCelsius,
		arg.Notes,
		arg.ExplicitInstructions,
		arg.ConditionExpression,
		arg.Optional,
		arg.StartTimerAutomatically,
		arg.BelongsToRecipe,
		arg.ID,
	)
	return err
}

const UpdateRecipeStepCompletionCondition = `-- name: UpdateRecipeStepCompletionCondition :exec

UPDATE recipe_step_completion_conditions
SET
	optional = $1,
	notes = $2,
	belongs_to_recipe_step = $3,
	ingredient_state = $4,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $5
`

type UpdateRecipeStepCompletionConditionParams struct {
	Notes               string `db:"notes"`
	BelongsToRecipeStep string `db:"belongs_to_recipe_step"`
	IngredientState     string `db:"ingredient_state"`
	ID                  string `db:"id"`
	Optional            bool   `db:"optional"`
}

func (q *Queries) UpdateRecipeStepCompletionCondition(ctx context.Context, db DBTX, arg *UpdateRecipeStepCompletionConditionParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStepCompletionCondition,
		arg.Optional,
		arg.Notes,
		arg.BelongsToRecipeStep,
		arg.IngredientState,
		arg.ID,
	)
	return err
}

const UpdateRecipeStepIngredient = `-- name: UpdateRecipeStepIngredient :exec

UPDATE recipe_step_ingredients SET
	ingredient_id = $1,
	name = $2,
	optional = $3,
	measurement_unit = $4,
	minimum_quantity_value = $5,
	maximum_quantity_value = $6,
	quantity_notes = $7,
	recipe_step_product_id = $8,
	ingredient_notes = $9,
	option_index = $10,
	to_taste = $11,
	product_percentage_to_use = $12,
    vessel_index = $13,
    recipe_step_product_recipe_id = $14,
	last_updated_at = NOW()
WHERE archived_at IS NULL AND belongs_to_recipe_step = $15
	AND id = $16
`

type UpdateRecipeStepIngredientParams struct {
	IngredientNotes           string         `db:"ingredient_notes"`
	Name                      string         `db:"name"`
	ID                        string         `db:"id"`
	BelongsToRecipeStep       string         `db:"belongs_to_recipe_step"`
	MinimumQuantityValue      string         `db:"minimum_quantity_value"`
	QuantityNotes             string         `db:"quantity_notes"`
	IngredientID              sql.NullString `db:"ingredient_id"`
	MaximumQuantityValue      sql.NullString `db:"maximum_quantity_value"`
	RecipeStepProductID       sql.NullString `db:"recipe_step_product_id"`
	ProductPercentageToUse    sql.NullString `db:"product_percentage_to_use"`
	RecipeStepProductRecipeID sql.NullString `db:"recipe_step_product_recipe_id"`
	MeasurementUnit           sql.NullString `db:"measurement_unit"`
	VesselIndex               sql.NullInt32  `db:"vessel_index"`
	OptionIndex               int32          `db:"option_index"`
	ToTaste                   bool           `db:"to_taste"`
	Optional                  bool           `db:"optional"`
}

func (q *Queries) UpdateRecipeStepIngredient(ctx context.Context, db DBTX, arg *UpdateRecipeStepIngredientParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStepIngredient,
		arg.IngredientID,
		arg.Name,
		arg.Optional,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.RecipeStepProductID,
		arg.IngredientNotes,
		arg.OptionIndex,
		arg.ToTaste,
		arg.ProductPercentageToUse,
		arg.VesselIndex,
		arg.RecipeStepProductRecipeID,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}

const UpdateRecipeStepInstrument = `-- name: UpdateRecipeStepInstrument :exec

UPDATE recipe_step_instruments SET
	instrument_id = $1,
	recipe_step_product_id = $2,
	name = $3,
	notes = $4,
	preference_rank = $5,
	optional = $6,
	option_index = $7,
	minimum_quantity = $8,
	maximum_quantity = $9,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $10
	AND id = $11
`

type UpdateRecipeStepInstrumentParams struct {
	Name                string         `db:"name"`
	Notes               string         `db:"notes"`
	BelongsToRecipeStep string         `db:"belongs_to_recipe_step"`
	ID                  string         `db:"id"`
	InstrumentID        sql.NullString `db:"instrument_id"`
	RecipeStepProductID sql.NullString `db:"recipe_step_product_id"`
	MaximumQuantity     sql.NullInt32  `db:"maximum_quantity"`
	PreferenceRank      int32          `db:"preference_rank"`
	OptionIndex         int32          `db:"option_index"`
	MinimumQuantity     int32          `db:"minimum_quantity"`
	Optional            bool           `db:"optional"`
}

func (q *Queries) UpdateRecipeStepInstrument(ctx context.Context, db DBTX, arg *UpdateRecipeStepInstrumentParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStepInstrument,
		arg.InstrumentID,
		arg.RecipeStepProductID,
		arg.Name,
		arg.Notes,
		arg.PreferenceRank,
		arg.Optional,
		arg.OptionIndex,
		arg.MinimumQuantity,
		arg.MaximumQuantity,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}

const UpdateRecipeStepProduct = `-- name: UpdateRecipeStepProduct :exec

UPDATE recipe_step_products
SET
	"name" = $1,
	"type" = $2,
	measurement_unit = $3,
	minimum_quantity_value = $4,
	maximum_quantity_value = $5,
	quantity_notes = $6,
	compostable = $7,
	maximum_storage_duration_in_seconds = $8,
	minimum_storage_temperature_in_celsius = $9,
	maximum_storage_temperature_in_celsius = $10,
	storage_instructions = $11,
	is_liquid = $12,
	is_waste = $13,
    "index" = $14,
    contained_in_vessel_index = $15,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $16
	AND id = $17
`

type UpdateRecipeStepProductParams struct {
	Name                               string                `db:"name"`
	Type                               RecipeStepProductType `db:"type"`
	ID                                 string                `db:"id"`
	BelongsToRecipeStep                string                `db:"belongs_to_recipe_step"`
	StorageInstructions                string                `db:"storage_instructions"`
	QuantityNotes                      string                `db:"quantity_notes"`
	MinimumStorageTemperatureInCelsius sql.NullString        `db:"minimum_storage_temperature_in_celsius"`
	MaximumStorageTemperatureInCelsius sql.NullString        `db:"maximum_storage_temperature_in_celsius"`
	MaximumQuantityValue               sql.NullString        `db:"maximum_quantity_value"`
	MinimumQuantityValue               sql.NullString        `db:"minimum_quantity_value"`
	MeasurementUnit                    sql.NullString        `db:"measurement_unit"`
	MaximumStorageDurationInSeconds    sql.NullInt32         `db:"maximum_storage_duration_in_seconds"`
	ContainedInVesselIndex             sql.NullInt32         `db:"contained_in_vessel_index"`
	Index                              int32                 `db:"index"`
	Compostable                        bool                  `db:"compostable"`
	IsLiquid                           bool                  `db:"is_liquid"`
	IsWaste                            bool                  `db:"is_waste"`
}

func (q *Queries) UpdateRecipeStepProduct(ctx context.Context, db DBTX, arg *UpdateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStepProduct,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}

const UpdateRecipeStepVessel = `-- name: UpdateRecipeStepVessel :exec

UPDATE recipe_step_vessels SET
	name = $1,
	notes = $2,
	belongs_to_recipe_step = $3,
	recipe_step_product_id = $4,
	valid_vessel_id = $5,
	vessel_predicate = $6,
	minimum_quantity = $7,
    maximum_quantity = $8,
    unavailable_after_step = $9,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $10
	AND id = $11
`

type UpdateRecipeStepVesselParams struct {
	Name                  string         `db:"name"`
	Notes                 string         `db:"notes"`
	BelongsToRecipeStep   string         `db:"belongs_to_recipe_step"`
	VesselPredicate       string         `db:"vessel_predicate"`
	BelongsToRecipeStep_2 string         `db:"belongs_to_recipe_step_2"`
	ID                    string         `db:"id"`
	RecipeStepProductID   sql.NullString `db:"recipe_step_product_id"`
	ValidVesselID         sql.NullString `db:"valid_vessel_id"`
	MaximumQuantity       sql.NullInt32  `db:"maximum_quantity"`
	MinimumQuantity       int32          `db:"minimum_quantity"`
	UnavailableAfterStep  bool           `db:"unavailable_after_step"`
}

func (q *Queries) UpdateRecipeStepVessel(ctx context.Context, db DBTX, arg *UpdateRecipeStepVesselParams) error {
	_, err := db.ExecContext(ctx, UpdateRecipeStepVessel,
		arg.Name,
		arg.Notes,
		arg.BelongsToRecipeStep,
		arg.RecipeStepProductID,
		arg.ValidVesselID,
		arg.VesselPredicate,
		arg.MinimumQuantity,
		arg.MaximumQuantity,
		arg.UnavailableAfterStep,
		arg.BelongsToRecipeStep_2,
		arg.ID,
	)
	return err
}

const UpdateServiceSettingConfiguration = `-- name: UpdateServiceSettingConfiguration :exec

UPDATE service_setting_configurations
SET
    value = $1,
    notes = $2,
    service_setting_id = $3,
    belongs_to_user = $4,
    belongs_to_household = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateServiceSettingConfigurationParams struct {
	Value              string `db:"value"`
	Notes              string `db:"notes"`
	ServiceSettingID   string `db:"service_setting_id"`
	BelongsToUser      string `db:"belongs_to_user"`
	BelongsToHousehold string `db:"belongs_to_household"`
	ID                 string `db:"id"`
}

func (q *Queries) UpdateServiceSettingConfiguration(ctx context.Context, db DBTX, arg *UpdateServiceSettingConfigurationParams) error {
	_, err := db.ExecContext(ctx, UpdateServiceSettingConfiguration,
		arg.Value,
		arg.Notes,
		arg.ServiceSettingID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
		arg.ID,
	)
	return err
}

const UpdateUser = `-- name: UpdateUser :exec

UPDATE users SET
	username = $1,
	first_name = $2,
	last_name = $3,
	hashed_password = $4,
	avatar_src = $5,
	birthday = $6,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $7
`

type UpdateUserParams struct {
	Birthday       sql.NullTime   `db:"birthday"`
	Username       string         `db:"username"`
	FirstName      string         `db:"first_name"`
	LastName       string         `db:"last_name"`
	HashedPassword string         `db:"hashed_password"`
	ID             string         `db:"id"`
	AvatarSrc      sql.NullString `db:"avatar_src"`
}

func (q *Queries) UpdateUser(ctx context.Context, db DBTX, arg *UpdateUserParams) error {
	_, err := db.ExecContext(ctx, UpdateUser,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.HashedPassword,
		arg.AvatarSrc,
		arg.Birthday,
		arg.ID,
	)
	return err
}

const UpdateUserIngredientPreference = `-- name: UpdateUserIngredientPreference :exec

UPDATE user_ingredient_preferences
SET
	ingredient = $1,
	rating = $2,
	notes = $3,
	allergy = $4,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $5
	AND belongs_to_user = $6
`

type UpdateUserIngredientPreferenceParams struct {
	Ingredient    string `db:"ingredient"`
	Notes         string `db:"notes"`
	ID            string `db:"id"`
	BelongsToUser string `db:"belongs_to_user"`
	Rating        int16  `db:"rating"`
	Allergy       bool   `db:"allergy"`
}

func (q *Queries) UpdateUserIngredientPreference(ctx context.Context, db DBTX, arg *UpdateUserIngredientPreferenceParams) error {
	_, err := db.ExecContext(ctx, UpdateUserIngredientPreference,
		arg.Ingredient,
		arg.Rating,
		arg.Notes,
		arg.Allergy,
		arg.ID,
		arg.BelongsToUser,
	)
	return err
}

const UpdateValidIngredient = `-- name: UpdateValidIngredient :exec

UPDATE valid_ingredients SET
	name = $1,
	description = $2,
	warning = $3,
	contains_egg = $4,
	contains_dairy = $5,
	contains_peanut = $6,
	contains_tree_nut = $7,
	contains_soy = $8,
	contains_wheat = $9,
	contains_shellfish = $10,
	contains_sesame = $11,
	contains_fish = $12,
	contains_gluten = $13,
	animal_flesh = $14,
	volumetric = $15,
	is_liquid = $16,
	icon_path = $17,
	animal_derived = $18,
	plural_name = $19,
	restrict_to_preparations = $20,
	minimum_ideal_storage_temperature_in_celsius = $21,
	maximum_ideal_storage_temperature_in_celsius = $22,
	storage_instructions = $23,
	slug = $24,
	contains_alcohol = $25,
	shopping_suggestions = $26,
    is_starch = $27,
    is_protein = $28,
    is_grain = $29,
    is_fruit = $30,
    is_salt = $31,
    is_fat = $32,
    is_acid = $33,
    is_heat = $34,
	last_updated_at = NOW()
WHERE archived_at IS NULL AND id = $35
`

type UpdateValidIngredientParams struct {
	Description                             string         `db:"description"`
	Warning                                 string         `db:"warning"`
	ID                                      string         `db:"id"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	Slug                                    string         `db:"slug"`
	StorageInstructions                     string         `db:"storage_instructions"`
	Name                                    string         `db:"name"`
	PluralName                              string         `db:"plural_name"`
	IconPath                                string         `db:"icon_path"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	Volumetric                              bool           `db:"volumetric"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	AnimalDerived                           bool           `db:"animal_derived"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsEgg                             bool           `db:"contains_egg"`
}

func (q *Queries) UpdateValidIngredient(ctx context.Context, db DBTX, arg *UpdateValidIngredientParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredient,
		arg.Name,
		arg.Description,
		arg.Warning,
		arg.ContainsEgg,
		arg.ContainsDairy,
		arg.ContainsPeanut,
		arg.ContainsTreeNut,
		arg.ContainsSoy,
		arg.ContainsWheat,
		arg.ContainsShellfish,
		arg.ContainsSesame,
		arg.ContainsFish,
		arg.ContainsGluten,
		arg.AnimalFlesh,
		arg.Volumetric,
		arg.IsLiquid,
		arg.IconPath,
		arg.AnimalDerived,
		arg.PluralName,
		arg.RestrictToPreparations,
		arg.MinimumIdealStorageTemperatureInCelsius,
		arg.MaximumIdealStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.Slug,
		arg.ContainsAlcohol,
		arg.ShoppingSuggestions,
		arg.IsStarch,
		arg.IsProtein,
		arg.IsGrain,
		arg.IsFruit,
		arg.IsSalt,
		arg.IsFat,
		arg.IsAcid,
		arg.IsHeat,
		arg.ID,
	)
	return err
}

const UpdateValidIngredientGroup = `-- name: UpdateValidIngredientGroup :exec

UPDATE valid_ingredient_groups SET
	name = $1,
	description = $2,
	slug = $3,
	last_updated_at = NOW()
WHERE archived_at IS NULL AND id = $4
`

type UpdateValidIngredientGroupParams struct {
	Name        string `db:"name"`
	Description string `db:"description"`
	Slug        string `db:"slug"`
	ID          string `db:"id"`
}

func (q *Queries) UpdateValidIngredientGroup(ctx context.Context, db DBTX, arg *UpdateValidIngredientGroupParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredientGroup,
		arg.Name,
		arg.Description,
		arg.Slug,
		arg.ID,
	)
	return err
}

const UpdateValidIngredientMeasurementUnit = `-- name: UpdateValidIngredientMeasurementUnit :exec

UPDATE valid_ingredient_measurement_units
SET
	notes = $1,
	valid_measurement_unit_id = $2,
	valid_ingredient_id = $3,
	minimum_allowable_quantity = $4,
	maximum_allowable_quantity = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateValidIngredientMeasurementUnitParams struct {
	Notes                    string         `db:"notes"`
	ValidMeasurementUnitID   string         `db:"valid_measurement_unit_id"`
	ValidIngredientID        string         `db:"valid_ingredient_id"`
	MinimumAllowableQuantity string         `db:"minimum_allowable_quantity"`
	ID                       string         `db:"id"`
	MaximumAllowableQuantity sql.NullString `db:"maximum_allowable_quantity"`
}

func (q *Queries) UpdateValidIngredientMeasurementUnit(ctx context.Context, db DBTX, arg *UpdateValidIngredientMeasurementUnitParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredientMeasurementUnit,
		arg.Notes,
		arg.ValidMeasurementUnitID,
		arg.ValidIngredientID,
		arg.MinimumAllowableQuantity,
		arg.MaximumAllowableQuantity,
		arg.ID,
	)
	return err
}

const UpdateValidIngredientPreparation = `-- name: UpdateValidIngredientPreparation :exec

UPDATE valid_ingredient_preparations SET notes = $1, valid_preparation_id = $2, valid_ingredient_id = $3, last_updated_at = NOW() WHERE archived_at IS NULL AND id = $4
`

type UpdateValidIngredientPreparationParams struct {
	Notes              string `db:"notes"`
	ValidPreparationID string `db:"valid_preparation_id"`
	ValidIngredientID  string `db:"valid_ingredient_id"`
	ID                 string `db:"id"`
}

func (q *Queries) UpdateValidIngredientPreparation(ctx context.Context, db DBTX, arg *UpdateValidIngredientPreparationParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredientPreparation,
		arg.Notes,
		arg.ValidPreparationID,
		arg.ValidIngredientID,
		arg.ID,
	)
	return err
}

const UpdateValidIngredientState = `-- name: UpdateValidIngredientState :exec

UPDATE valid_ingredient_states
SET
	name = $1,
	description = $2,
	icon_path = $3,
	slug = $4,
	past_tense = $5,
	attribute_type = $6,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $7
`

type UpdateValidIngredientStateParams struct {
	Name          string                  `db:"name"`
	Description   string                  `db:"description"`
	IconPath      string                  `db:"icon_path"`
	Slug          string                  `db:"slug"`
	PastTense     string                  `db:"past_tense"`
	AttributeType IngredientAttributeType `db:"attribute_type"`
	ID            string                  `db:"id"`
}

func (q *Queries) UpdateValidIngredientState(ctx context.Context, db DBTX, arg *UpdateValidIngredientStateParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredientState,
		arg.Name,
		arg.Description,
		arg.IconPath,
		arg.Slug,
		arg.PastTense,
		arg.AttributeType,
		arg.ID,
	)
	return err
}

const UpdateValidIngredientStateIngredient = `-- name: UpdateValidIngredientStateIngredient :exec

UPDATE valid_ingredient_state_ingredients SET notes = $1, valid_ingredient_state = $2, valid_ingredient = $3, last_updated_at = NOW() WHERE archived_at IS NULL AND id = $4
`

type UpdateValidIngredientStateIngredientParams struct {
	Notes                string `db:"notes"`
	ValidIngredientState string `db:"valid_ingredient_state"`
	ValidIngredient      string `db:"valid_ingredient"`
	ID                   string `db:"id"`
}

func (q *Queries) UpdateValidIngredientStateIngredient(ctx context.Context, db DBTX, arg *UpdateValidIngredientStateIngredientParams) error {
	_, err := db.ExecContext(ctx, UpdateValidIngredientStateIngredient,
		arg.Notes,
		arg.ValidIngredientState,
		arg.ValidIngredient,
		arg.ID,
	)
	return err
}

const UpdateValidInstrument = `-- name: UpdateValidInstrument :exec

UPDATE valid_instruments
SET
	name = $1,
	plural_name = $2,
	description = $3,
	icon_path = $4,
	usable_for_storage = $5,
	display_in_summary_lists = $6,
	include_in_generated_instructions = $7,
	slug = $8,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $9
`

type UpdateValidInstrumentParams struct {
	Name                           string `db:"name"`
	PluralName                     string `db:"plural_name"`
	Description                    string `db:"description"`
	IconPath                       string `db:"icon_path"`
	Slug                           string `db:"slug"`
	ID                             string `db:"id"`
	UsableForStorage               bool   `db:"usable_for_storage"`
	DisplayInSummaryLists          bool   `db:"display_in_summary_lists"`
	IncludeInGeneratedInstructions bool   `db:"include_in_generated_instructions"`
}

func (q *Queries) UpdateValidInstrument(ctx context.Context, db DBTX, arg *UpdateValidInstrumentParams) error {
	_, err := db.ExecContext(ctx, UpdateValidInstrument,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Slug,
		arg.ID,
	)
	return err
}

const UpdateValidMeasurementConversion = `-- name: UpdateValidMeasurementConversion :exec

UPDATE valid_measurement_conversions
SET
	from_unit = $1,
	to_unit = $2,
	only_for_ingredient = $3,
	modifier = $4,
	notes = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateValidMeasurementConversionParams struct {
	FromUnit          string         `db:"from_unit"`
	ToUnit            string         `db:"to_unit"`
	Modifier          string         `db:"modifier"`
	Notes             string         `db:"notes"`
	ID                string         `db:"id"`
	OnlyForIngredient sql.NullString `db:"only_for_ingredient"`
}

func (q *Queries) UpdateValidMeasurementConversion(ctx context.Context, db DBTX, arg *UpdateValidMeasurementConversionParams) error {
	_, err := db.ExecContext(ctx, UpdateValidMeasurementConversion,
		arg.FromUnit,
		arg.ToUnit,
		arg.OnlyForIngredient,
		arg.Modifier,
		arg.Notes,
		arg.ID,
	)
	return err
}

const UpdateValidMeasurementUnit = `-- name: UpdateValidMeasurementUnit :exec

UPDATE valid_measurement_units SET
	name = $1,
	description = $2,
	volumetric = $3,
	icon_path = $4,
	universal = $5,
	metric = $6,
	imperial = $7,
	slug = $8,
	plural_name = $9,
	last_updated_at = NOW()
WHERE archived_at IS NULL AND id = $10
`

type UpdateValidMeasurementUnitParams struct {
	Name        string       `db:"name"`
	Description string       `db:"description"`
	IconPath    string       `db:"icon_path"`
	Slug        string       `db:"slug"`
	PluralName  string       `db:"plural_name"`
	ID          string       `db:"id"`
	Volumetric  sql.NullBool `db:"volumetric"`
	Universal   bool         `db:"universal"`
	Metric      bool         `db:"metric"`
	Imperial    bool         `db:"imperial"`
}

func (q *Queries) UpdateValidMeasurementUnit(ctx context.Context, db DBTX, arg *UpdateValidMeasurementUnitParams) error {
	_, err := db.ExecContext(ctx, UpdateValidMeasurementUnit,
		arg.Name,
		arg.Description,
		arg.Volumetric,
		arg.IconPath,
		arg.Universal,
		arg.Metric,
		arg.Imperial,
		arg.Slug,
		arg.PluralName,
		arg.ID,
	)
	return err
}

const UpdateValidPreparation = `-- name: UpdateValidPreparation :exec

UPDATE valid_preparations
SET
	name = $1,
	description = $2,
	icon_path = $3,
	yields_nothing = $4,
	restrict_to_ingredients = $5,
	minimum_ingredient_count = $6,
	maximum_ingredient_count = $7,
	minimum_instrument_count = $8,
	maximum_instrument_count = $9,
	temperature_required = $10,
	time_estimate_required = $11,
	condition_expression_required = $12,
    consumes_vessel = $13,
    only_for_vessels = $14,
    minimum_vessel_count = $15,
    maximum_vessel_count = $16,
	slug = $17,
	past_tense = $18,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $19
`

type UpdateValidPreparationParams struct {
	Description                 string        `db:"description"`
	IconPath                    string        `db:"icon_path"`
	ID                          string        `db:"id"`
	Name                        string        `db:"name"`
	PastTense                   string        `db:"past_tense"`
	Slug                        string        `db:"slug"`
	MaximumIngredientCount      sql.NullInt32 `db:"maximum_ingredient_count"`
	MaximumInstrumentCount      sql.NullInt32 `db:"maximum_instrument_count"`
	MaximumVesselCount          sql.NullInt32 `db:"maximum_vessel_count"`
	MinimumVesselCount          int32         `db:"minimum_vessel_count"`
	MinimumIngredientCount      int32         `db:"minimum_ingredient_count"`
	MinimumInstrumentCount      int32         `db:"minimum_instrument_count"`
	RestrictToIngredients       bool          `db:"restrict_to_ingredients"`
	OnlyForVessels              bool          `db:"only_for_vessels"`
	ConsumesVessel              bool          `db:"consumes_vessel"`
	ConditionExpressionRequired bool          `db:"condition_expression_required"`
	TimeEstimateRequired        bool          `db:"time_estimate_required"`
	TemperatureRequired         bool          `db:"temperature_required"`
	YieldsNothing               bool          `db:"yields_nothing"`
}

func (q *Queries) UpdateValidPreparation(ctx context.Context, db DBTX, arg *UpdateValidPreparationParams) error {
	_, err := db.ExecContext(ctx, UpdateValidPreparation,
		arg.Name,
		arg.Description,
		arg.IconPath,
		arg.YieldsNothing,
		arg.RestrictToIngredients,
		arg.MinimumIngredientCount,
		arg.MaximumIngredientCount,
		arg.MinimumInstrumentCount,
		arg.MaximumInstrumentCount,
		arg.TemperatureRequired,
		arg.TimeEstimateRequired,
		arg.ConditionExpressionRequired,
		arg.ConsumesVessel,
		arg.OnlyForVessels,
		arg.MinimumVesselCount,
		arg.MaximumVesselCount,
		arg.Slug,
		arg.PastTense,
		arg.ID,
	)
	return err
}

const UpdateValidPreparationInstrument = `-- name: UpdateValidPreparationInstrument :exec

UPDATE valid_preparation_instruments SET notes = $1, valid_preparation_id = $2, valid_instrument_id = $3, last_updated_at = NOW() WHERE archived_at IS NULL AND id = $4
`

type UpdateValidPreparationInstrumentParams struct {
	Notes              string `db:"notes"`
	ValidPreparationID string `db:"valid_preparation_id"`
	ValidInstrumentID  string `db:"valid_instrument_id"`
	ID                 string `db:"id"`
}

func (q *Queries) UpdateValidPreparationInstrument(ctx context.Context, db DBTX, arg *UpdateValidPreparationInstrumentParams) error {
	_, err := db.ExecContext(ctx, UpdateValidPreparationInstrument,
		arg.Notes,
		arg.ValidPreparationID,
		arg.ValidInstrumentID,
		arg.ID,
	)
	return err
}

const UpdateValidPreparationVessel = `-- name: UpdateValidPreparationVessel :exec

UPDATE valid_preparation_vessels SET notes = $1, valid_preparation_id = $2, valid_vessel_id = $3, last_updated_at = NOW() WHERE archived_at IS NULL AND id = $4
`

type UpdateValidPreparationVesselParams struct {
	Notes              string `db:"notes"`
	ValidPreparationID string `db:"valid_preparation_id"`
	ValidVesselID      string `db:"valid_vessel_id"`
	ID                 string `db:"id"`
}

func (q *Queries) UpdateValidPreparationVessel(ctx context.Context, db DBTX, arg *UpdateValidPreparationVesselParams) error {
	_, err := db.ExecContext(ctx, UpdateValidPreparationVessel,
		arg.Notes,
		arg.ValidPreparationID,
		arg.ValidVesselID,
		arg.ID,
	)
	return err
}

const UpdateValidVessel = `-- name: UpdateValidVessel :exec

UPDATE valid_vessels
SET
    name = $1,
    plural_name = $2,
    description = $3,
    icon_path = $4,
    usable_for_storage = $5,
    slug = $6,
    display_in_summary_lists = $7,
    include_in_generated_instructions = $8,
    capacity = $9,
    capacity_unit = $10,
    width_in_millimeters = $11,
    length_in_millimeters = $12,
    height_in_millimeters = $13,
    shape = $14,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $15
`

type UpdateValidVesselParams struct {
	Capacity                       string         `db:"capacity"`
	PluralName                     string         `db:"plural_name"`
	Description                    string         `db:"description"`
	IconPath                       string         `db:"icon_path"`
	ID                             string         `db:"id"`
	Slug                           string         `db:"slug"`
	Shape                          VesselShape    `db:"shape"`
	Name                           string         `db:"name"`
	CapacityUnit                   sql.NullString `db:"capacity_unit"`
	WidthInMillimeters             sql.NullString `db:"width_in_millimeters"`
	LengthInMillimeters            sql.NullString `db:"length_in_millimeters"`
	HeightInMillimeters            sql.NullString `db:"height_in_millimeters"`
	IncludeInGeneratedInstructions bool           `db:"include_in_generated_instructions"`
	DisplayInSummaryLists          bool           `db:"display_in_summary_lists"`
	UsableForStorage               bool           `db:"usable_for_storage"`
}

func (q *Queries) UpdateValidVessel(ctx context.Context, db DBTX, arg *UpdateValidVesselParams) error {
	_, err := db.ExecContext(ctx, UpdateValidVessel,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.Slug,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Capacity,
		arg.CapacityUnit,
		arg.WidthInMillimeters,
		arg.LengthInMillimeters,
		arg.HeightInMillimeters,
		arg.Shape,
		arg.ID,
	)
	return err
}
