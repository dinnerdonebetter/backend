// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: audit_logs.sql

package generated

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const createAuditLog = `-- name: CreateAuditLog :exec

INSERT INTO audit_log (
	id,
	resource_type,
	relevant_id,
	event_type,
	changes,
	belongs_to_user,
	belongs_to_household
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7
)
`

type CreateAuditLogParams struct {
	ID                 string
	ResourceType       string
	RelevantID         string
	EventType          AuditLogEventType
	Changes            json.RawMessage
	BelongsToUser      string
	BelongsToHousehold sql.NullString
}

func (q *Queries) CreateAuditLog(ctx context.Context, db DBTX, arg *CreateAuditLogParams) error {
	_, err := db.ExecContext(ctx, createAuditLog,
		arg.ID,
		arg.ResourceType,
		arg.RelevantID,
		arg.EventType,
		arg.Changes,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
	)
	return err
}

const getAuditLog = `-- name: GetAuditLog :one

SELECT
	audit_log.id as audit_log_id,
	audit_log.resource_type as audit_log_resource_type,
	audit_log.relevant_id as audit_log_relevant_id,
	audit_log.event_type as audit_log_event_type,
	audit_log.changes as audit_log_changes,
	audit_log.belongs_to_user as audit_log_belongs_to_user,
	audit_log.belongs_to_household as audit_log_belongs_to_household,
	audit_log.created_at as audit_log_created_at
FROM audit_log
WHERE audit_log.id = $1
`

type GetAuditLogRow struct {
	AuditLogCreatedAt          time.Time
	AuditLogID                 string
	AuditLogResourceType       string
	AuditLogRelevantID         string
	AuditLogEventType          AuditLogEventType
	AuditLogBelongsToUser      string
	AuditLogChanges            json.RawMessage
	AuditLogBelongsToHousehold sql.NullString
}

func (q *Queries) GetAuditLog(ctx context.Context, db DBTX, id string) (*GetAuditLogRow, error) {
	row := db.QueryRowContext(ctx, getAuditLog, id)
	var i GetAuditLogRow
	err := row.Scan(
		&i.AuditLogID,
		&i.AuditLogResourceType,
		&i.AuditLogRelevantID,
		&i.AuditLogEventType,
		&i.AuditLogChanges,
		&i.AuditLogBelongsToUser,
		&i.AuditLogBelongsToHousehold,
		&i.AuditLogCreatedAt,
	)
	return &i, err
}

const getAuditLogsForHousehold = `-- name: GetAuditLogsForHousehold :many

SELECT
	audit_log.id,
	audit_log.resource_type,
	audit_log.relevant_id,
	audit_log.event_type,
	audit_log.changes,
	audit_log.belongs_to_user,
	audit_log.belongs_to_household,
	audit_log.created_at,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND audit_log.belongs_to_household = $3
	) AS filtered_count,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE
			audit_log.belongs_to_household = $3
	) AS total_count
FROM audit_log
WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND audit_log.belongs_to_household = $3
LIMIT $5
OFFSET $4
`

type GetAuditLogsForHouseholdParams struct {
	CreatedAfter       sql.NullTime
	CreatedBefore      sql.NullTime
	BelongsToHousehold sql.NullString
	QueryOffset        sql.NullInt32
	QueryLimit         sql.NullInt32
}

type GetAuditLogsForHouseholdRow struct {
	CreatedAt          time.Time
	ID                 string
	ResourceType       string
	RelevantID         string
	EventType          AuditLogEventType
	BelongsToUser      string
	Changes            json.RawMessage
	BelongsToHousehold sql.NullString
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetAuditLogsForHousehold(ctx context.Context, db DBTX, arg *GetAuditLogsForHouseholdParams) ([]*GetAuditLogsForHouseholdRow, error) {
	rows, err := db.QueryContext(ctx, getAuditLogsForHousehold,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.BelongsToHousehold,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAuditLogsForHouseholdRow{}
	for rows.Next() {
		var i GetAuditLogsForHouseholdRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.RelevantID,
			&i.EventType,
			&i.Changes,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsForHouseholdAndResourceType = `-- name: GetAuditLogsForHouseholdAndResourceType :many

SELECT
	audit_log.id,
	audit_log.resource_type,
	audit_log.relevant_id,
	audit_log.event_type,
	audit_log.changes,
	audit_log.belongs_to_user,
	audit_log.belongs_to_household,
	audit_log.created_at,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND audit_log.belongs_to_household = $3
			AND audit_log.resource_type = $4
	) AS filtered_count,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE
			audit_log.belongs_to_household = $3
			AND audit_log.resource_type = $4
	) AS total_count
FROM audit_log
WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND audit_log.belongs_to_household = $3
	AND audit_log.resource_type = $4
LIMIT $6
OFFSET $5
`

type GetAuditLogsForHouseholdAndResourceTypeParams struct {
	CreatedAfter       sql.NullTime
	CreatedBefore      sql.NullTime
	ResourceType       string
	BelongsToHousehold sql.NullString
	QueryOffset        sql.NullInt32
	QueryLimit         sql.NullInt32
}

type GetAuditLogsForHouseholdAndResourceTypeRow struct {
	CreatedAt          time.Time
	ID                 string
	ResourceType       string
	RelevantID         string
	EventType          AuditLogEventType
	BelongsToUser      string
	Changes            json.RawMessage
	BelongsToHousehold sql.NullString
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetAuditLogsForHouseholdAndResourceType(ctx context.Context, db DBTX, arg *GetAuditLogsForHouseholdAndResourceTypeParams) ([]*GetAuditLogsForHouseholdAndResourceTypeRow, error) {
	rows, err := db.QueryContext(ctx, getAuditLogsForHouseholdAndResourceType,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.BelongsToHousehold,
		arg.ResourceType,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAuditLogsForHouseholdAndResourceTypeRow{}
	for rows.Next() {
		var i GetAuditLogsForHouseholdAndResourceTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.RelevantID,
			&i.EventType,
			&i.Changes,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsForUser = `-- name: GetAuditLogsForUser :many

SELECT
	audit_log.id,
	audit_log.resource_type,
	audit_log.relevant_id,
	audit_log.event_type,
	audit_log.changes,
	audit_log.belongs_to_user,
	audit_log.belongs_to_household,
	audit_log.created_at,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND audit_log.belongs_to_user = $3
	) AS filtered_count,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE
			audit_log.belongs_to_user = $3
	) AS total_count
FROM audit_log
WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND audit_log.belongs_to_user = $3
LIMIT $5
OFFSET $4
`

type GetAuditLogsForUserParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	BelongsToUser string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetAuditLogsForUserRow struct {
	CreatedAt          time.Time
	ID                 string
	ResourceType       string
	RelevantID         string
	EventType          AuditLogEventType
	BelongsToUser      string
	Changes            json.RawMessage
	BelongsToHousehold sql.NullString
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetAuditLogsForUser(ctx context.Context, db DBTX, arg *GetAuditLogsForUserParams) ([]*GetAuditLogsForUserRow, error) {
	rows, err := db.QueryContext(ctx, getAuditLogsForUser,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.BelongsToUser,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAuditLogsForUserRow{}
	for rows.Next() {
		var i GetAuditLogsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.RelevantID,
			&i.EventType,
			&i.Changes,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuditLogsForUserAndResourceType = `-- name: GetAuditLogsForUserAndResourceType :many

SELECT
	audit_log.id,
	audit_log.resource_type,
	audit_log.relevant_id,
	audit_log.event_type,
	audit_log.changes,
	audit_log.belongs_to_user,
	audit_log.belongs_to_household,
	audit_log.created_at,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
			AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
			AND audit_log.belongs_to_user = $3
			AND audit_log.resource_type = $4
	) AS filtered_count,
	(
		SELECT COUNT(audit_log.id)
		FROM audit_log
		WHERE
			audit_log.belongs_to_user = $3
			AND audit_log.resource_type = $4
	) AS total_count
FROM audit_log
WHERE audit_log.created_at > COALESCE($1, (SELECT NOW() - '999 years'::INTERVAL))
	AND audit_log.created_at < COALESCE($2, (SELECT NOW() + '999 years'::INTERVAL))
	AND audit_log.belongs_to_user = $3
	AND audit_log.resource_type = $4
LIMIT $6
OFFSET $5
`

type GetAuditLogsForUserAndResourceTypeParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	BelongsToUser string
	ResourceType  string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetAuditLogsForUserAndResourceTypeRow struct {
	CreatedAt          time.Time
	ID                 string
	ResourceType       string
	RelevantID         string
	EventType          AuditLogEventType
	BelongsToUser      string
	Changes            json.RawMessage
	BelongsToHousehold sql.NullString
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetAuditLogsForUserAndResourceType(ctx context.Context, db DBTX, arg *GetAuditLogsForUserAndResourceTypeParams) ([]*GetAuditLogsForUserAndResourceTypeRow, error) {
	rows, err := db.QueryContext(ctx, getAuditLogsForUserAndResourceType,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.BelongsToUser,
		arg.ResourceType,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAuditLogsForUserAndResourceTypeRow{}
	for rows.Next() {
		var i GetAuditLogsForUserAndResourceTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.ResourceType,
			&i.RelevantID,
			&i.EventType,
			&i.Changes,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
