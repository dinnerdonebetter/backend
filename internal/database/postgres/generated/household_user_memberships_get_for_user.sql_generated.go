// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: household_user_memberships_get_for_user.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const GetHouseholdUserMembershipsForUser = `-- name: GetHouseholdUserMembershipsForUser :many
SELECT
	household_user_memberships.id,
	household_user_memberships.belongs_to_user,
	household_user_memberships.belongs_to_household,
	household_user_memberships.household_roles,
	household_user_memberships.default_household,
	household_user_memberships.created_at,
	household_user_memberships.last_updated_at,
	household_user_memberships.archived_at
FROM household_user_memberships
	JOIN households ON households.id = household_user_memberships.belongs_to_household
WHERE household_user_memberships.archived_at IS NULL
	AND household_user_memberships.belongs_to_user = $1
`

type GetHouseholdUserMembershipsForUserRow struct {
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	HouseholdRoles     string
	DefaultHousehold   bool
	CreatedAt          time.Time
	LastUpdatedAt      sql.NullTime
	ArchivedAt         sql.NullTime
}

func (q *Queries) GetHouseholdUserMembershipsForUser(ctx context.Context, belongsToUser string) ([]*GetHouseholdUserMembershipsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, GetHouseholdUserMembershipsForUser, belongsToUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHouseholdUserMembershipsForUserRow{}
	for rows.Next() {
		var i GetHouseholdUserMembershipsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.HouseholdRoles,
			&i.DefaultHousehold,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
