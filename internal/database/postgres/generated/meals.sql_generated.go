// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: meals.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveMeal = `-- name: ArchiveMeal :exec

UPDATE meals SET archived_at = NOW() WHERE archived_at IS NULL AND created_by_user = $1 AND id = $2
`

type ArchiveMealParams struct {
	CreatedByUser string
	ID            string
}

func (q *Queries) ArchiveMeal(ctx context.Context, db DBTX, arg *ArchiveMealParams) error {
	_, err := db.ExecContext(ctx, archiveMeal, arg.CreatedByUser, arg.ID)
	return err
}

const checkMealExistence = `-- name: CheckMealExistence :one

SELECT EXISTS ( SELECT meals.id FROM meals WHERE meals.archived_at IS NULL AND meals.id = $1 )
`

func (q *Queries) CheckMealExistence(ctx context.Context, db DBTX, id string) (bool, error) {
	row := db.QueryRowContext(ctx, checkMealExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createMeal = `-- name: CreateMeal :exec

INSERT INTO meals (id,"name",description,min_estimated_portions,max_estimated_portions,eligible_for_meal_plans,created_by_user) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type CreateMealParams struct {
	ID                   string
	Name                 string
	Description          string
	MinEstimatedPortions string
	CreatedByUser        string
	MaxEstimatedPortions sql.NullString
	EligibleForMealPlans bool
}

func (q *Queries) CreateMeal(ctx context.Context, db DBTX, arg *CreateMealParams) error {
	_, err := db.ExecContext(ctx, createMeal,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.MinEstimatedPortions,
		arg.MaxEstimatedPortions,
		arg.EligibleForMealPlans,
		arg.CreatedByUser,
	)
	return err
}

const getMeal = `-- name: GetMeal :one

SELECT
    meals.id,
    meals.name,
    meals.description,
    meals.min_estimated_portions,
    meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
    meals.created_at,
    meals.last_updated_at,
    meals.archived_at,
    meals.created_by_user,
    meal_components.recipe_id as component_recipe_id,
    meal_components.recipe_scale as component_recipe_scale,
    meal_components.meal_component_type as component_meal_component_type
FROM meals
    JOIN meal_components ON meal_components.meal_id=meals.id
WHERE meals.archived_at IS NULL
  AND meal_components.archived_at IS NULL
  AND meals.id = $1
`

type GetMealRow struct {
	CreatedAt                  time.Time
	ArchivedAt                 sql.NullTime
	LastUpdatedAt              sql.NullTime
	MinEstimatedPortions       string
	ID                         string
	Description                string
	Name                       string
	CreatedByUser              string
	ComponentRecipeID          string
	ComponentRecipeScale       string
	ComponentMealComponentType ComponentType
	MaxEstimatedPortions       sql.NullString
	EligibleForMealPlans       bool
}

func (q *Queries) GetMeal(ctx context.Context, db DBTX, id string) (*GetMealRow, error) {
	row := db.QueryRowContext(ctx, getMeal, id)
	var i GetMealRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.ComponentRecipeID,
		&i.ComponentRecipeScale,
		&i.ComponentMealComponentType,
	)
	return &i, err
}

const getMeals = `-- name: GetMeals :many
SELECT
    meals.id,
    meals.name,
    meals.description,
    meals.min_estimated_portions,
    meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
    meals.created_at,
    meals.last_updated_at,
    meals.archived_at,
    meals.created_by_user,
    meal_components.recipe_id as component_recipe_id,
    meal_components.recipe_scale as component_recipe_scale,
    meal_components.meal_component_type as component_meal_component_type,
    (
        SELECT
            COUNT(meals.id)
        FROM
            meals
        WHERE
            meals.archived_at IS NULL
            AND meals.id = $1
            AND meals.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
            AND meals.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
            AND (meals.last_updated_at IS NULL OR meals.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years')))
            AND (meals.last_updated_at IS NULL OR meals.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(meals.id)
        FROM
            meals
        WHERE
            meals.archived_at IS NULL
    ) as total_count
FROM meals
    JOIN meal_components ON meal_components.meal_id=meals.id
WHERE meals.archived_at IS NULL
    AND meals.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
    AND meals.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
    AND (meals.last_updated_at IS NULL OR meals.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years')))
    AND (meals.last_updated_at IS NULL OR meals.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years')))
    AND meal_components.archived_at IS NULL
    AND meals.id = $1
`

type GetMealsParams struct {
	MealID        string
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
}

type GetMealsRow struct {
	CreatedAt                  time.Time
	ArchivedAt                 sql.NullTime
	LastUpdatedAt              sql.NullTime
	MinEstimatedPortions       string
	ID                         string
	Description                string
	Name                       string
	CreatedByUser              string
	ComponentRecipeID          string
	ComponentRecipeScale       string
	ComponentMealComponentType ComponentType
	MaxEstimatedPortions       sql.NullString
	FilteredCount              int64
	TotalCount                 int64
	EligibleForMealPlans       bool
}

func (q *Queries) GetMeals(ctx context.Context, db DBTX, arg *GetMealsParams) ([]*GetMealsRow, error) {
	rows, err := db.QueryContext(ctx, getMeals,
		arg.MealID,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMealsRow{}
	for rows.Next() {
		var i GetMealsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.MinEstimatedPortions,
			&i.MaxEstimatedPortions,
			&i.EligibleForMealPlans,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.CreatedByUser,
			&i.ComponentRecipeID,
			&i.ComponentRecipeScale,
			&i.ComponentMealComponentType,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsNeedingIndexing = `-- name: GetMealsNeedingIndexing :many

SELECT meals.id
    FROM meals
    WHERE (meals.archived_at IS NULL)
    AND (
        (meals.last_indexed_at IS NULL)
        OR meals.last_indexed_at
            < now() - '24 hours'::INTERVAL
    )
`

func (q *Queries) GetMealsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getMealsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMealLastIndexedAt = `-- name: UpdateMealLastIndexedAt :exec

UPDATE meals SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateMealLastIndexedAt(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, updateMealLastIndexedAt, id)
	return err
}
