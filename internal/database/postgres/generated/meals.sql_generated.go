// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: meals.sql

package generated

import (
	"context"
	"database/sql"
)

const archiveMeal = `-- name: ArchiveMeal :exec

UPDATE meals SET archived_at = NOW() WHERE archived_at IS NULL AND created_by_user = $1 AND id = $2
`

type ArchiveMealParams struct {
	CreatedByUser string
	ID            string
}

func (q *Queries) ArchiveMeal(ctx context.Context, db DBTX, arg *ArchiveMealParams) error {
	_, err := db.ExecContext(ctx, archiveMeal, arg.CreatedByUser, arg.ID)
	return err
}

const checkMealExistence = `-- name: CheckMealExistence :one

SELECT EXISTS ( SELECT meals.id FROM meals WHERE meals.archived_at IS NULL AND meals.id = $1 )
`

func (q *Queries) CheckMealExistence(ctx context.Context, db DBTX, id string) (bool, error) {
	row := db.QueryRowContext(ctx, checkMealExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createMeal = `-- name: CreateMeal :exec

INSERT INTO meals (id,"name",description,min_estimated_portions,max_estimated_portions,eligible_for_meal_plans,created_by_user) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type CreateMealParams struct {
	ID                   string
	Name                 string
	Description          string
	MinEstimatedPortions string
	CreatedByUser        string
	MaxEstimatedPortions sql.NullString
	EligibleForMealPlans bool
}

func (q *Queries) CreateMeal(ctx context.Context, db DBTX, arg *CreateMealParams) error {
	_, err := db.ExecContext(ctx, createMeal,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.MinEstimatedPortions,
		arg.MaxEstimatedPortions,
		arg.EligibleForMealPlans,
		arg.CreatedByUser,
	)
	return err
}

const getMeal = `-- name: GetMeal :one

SELECT
	meals.id,
	meals.name,
	meals.description,
	meals.min_estimated_portions,
    meals.max_estimated_portions,
    meals.eligible_for_meal_plans,
	meals.created_at,
	meals.last_updated_at,
	meals.archived_at,
	meals.created_by_user,
	meal_components.recipe_id,
	meal_components.recipe_scale,
	meal_components.meal_component_type
FROM meals
	FULL OUTER JOIN meal_components ON meal_components.meal_id=meals.id
WHERE meals.archived_at IS NULL
	AND meal_components.archived_at IS NULL
	AND meals.id = $1
`

type GetMealRow struct {
	CreatedAt            sql.NullTime
	ArchivedAt           sql.NullTime
	LastUpdatedAt        sql.NullTime
	MinEstimatedPortions sql.NullString
	MaxEstimatedPortions sql.NullString
	ID                   sql.NullString
	Description          sql.NullString
	Name                 sql.NullString
	CreatedByUser        sql.NullString
	RecipeID             sql.NullString
	RecipeScale          sql.NullString
	MealComponentType    NullComponentType
	EligibleForMealPlans sql.NullBool
}

func (q *Queries) GetMeal(ctx context.Context, db DBTX, id string) (*GetMealRow, error) {
	row := db.QueryRowContext(ctx, getMeal, id)
	var i GetMealRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.MinEstimatedPortions,
		&i.MaxEstimatedPortions,
		&i.EligibleForMealPlans,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.CreatedByUser,
		&i.RecipeID,
		&i.RecipeScale,
		&i.MealComponentType,
	)
	return &i, err
}

const getMealsNeedingIndexing = `-- name: GetMealsNeedingIndexing :many

SELECT meals.id
  FROM meals
 WHERE (meals.archived_at IS NULL)
       AND (
			(meals.last_indexed_at IS NULL)
			OR meals.last_indexed_at
				< now() - '24 hours'::INTERVAL
		)
`

func (q *Queries) GetMealsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getMealsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMealLastIndexedAt = `-- name: UpdateMealLastIndexedAt :exec

UPDATE meals SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateMealLastIndexedAt(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, updateMealLastIndexedAt, id)
	return err
}
