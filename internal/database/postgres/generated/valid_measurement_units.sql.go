// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: valid_measurement_units.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveValidMeasurementUnit = `-- name: ArchiveValidMeasurementUnit :exec
UPDATE valid_measurement_units SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND id = $1
`

func (q *Queries) ArchiveValidMeasurementUnit(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, ArchiveValidMeasurementUnit, id)
	return err
}

const CreateValidMeasurementUnit = `-- name: CreateValidMeasurementUnit :exec
INSERT INTO valid_measurement_units (id,name,description,volumetric,icon_path) VALUES ($1,$2,$3,$4,$5)
`

type CreateValidMeasurementUnitParams struct {
	ID          string
	Name        string
	Description string
	Volumetric  sql.NullBool
	IconPath    string
}

func (q *Queries) CreateValidMeasurementUnit(ctx context.Context, arg *CreateValidMeasurementUnitParams) error {
	_, err := q.db.ExecContext(ctx, CreateValidMeasurementUnit,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Volumetric,
		arg.IconPath,
	)
	return err
}

const GetRandomValidMeasurementUnit = `-- name: GetRandomValidMeasurementUnit :one
SELECT
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on
FROM valid_measurement_units
WHERE valid_measurement_units.archived_on IS NULL
ORDER BY random() LIMIT 1
`

type GetRandomValidMeasurementUnitRow struct {
	ID            string
	Name          string
	Description   string
	Volumetric    sql.NullBool
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) GetRandomValidMeasurementUnit(ctx context.Context) (*GetRandomValidMeasurementUnitRow, error) {
	row := q.db.QueryRowContext(ctx, GetRandomValidMeasurementUnit)
	var i GetRandomValidMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetTotalValidMeasurementUnitCount = `-- name: GetTotalValidMeasurementUnitCount :one
SELECT COUNT(valid_measurement_units.id) FROM valid_measurement_units WHERE valid_measurement_units.archived_on IS NULL
`

func (q *Queries) GetTotalValidMeasurementUnitCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalValidMeasurementUnitCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetValidMeasurementUnit = `-- name: GetValidMeasurementUnit :one
SELECT
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on
FROM valid_measurement_units
WHERE valid_measurement_units.archived_on IS NULL
  AND valid_measurement_units.id = $1
`

type GetValidMeasurementUnitRow struct {
	ID            string
	Name          string
	Description   string
	Volumetric    sql.NullBool
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) GetValidMeasurementUnit(ctx context.Context, id string) (*GetValidMeasurementUnitRow, error) {
	row := q.db.QueryRowContext(ctx, GetValidMeasurementUnit, id)
	var i GetValidMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const SearchForValidMeasurementUnits = `-- name: SearchForValidMeasurementUnits :many
SELECT
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on
FROM valid_measurement_units
WHERE valid_measurement_units.name ILIKE $1
AND valid_measurement_units.archived_on IS NULL
LIMIT 50
`

type SearchForValidMeasurementUnitsRow struct {
	ID            string
	Name          string
	Description   string
	Volumetric    sql.NullBool
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) SearchForValidMeasurementUnits(ctx context.Context, name string) ([]*SearchForValidMeasurementUnitsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchForValidMeasurementUnits, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchForValidMeasurementUnitsRow
	for rows.Next() {
		var i SearchForValidMeasurementUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateValidMeasurementUnit = `-- name: UpdateValidMeasurementUnit :exec
UPDATE valid_measurement_units
SET
    name = $1,
    description = $2,
    volumetric = $3,
    icon_path = $4,
    last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL AND id = $5
`

type UpdateValidMeasurementUnitParams struct {
	Name        string
	Description string
	Volumetric  sql.NullBool
	IconPath    string
	ID          string
}

func (q *Queries) UpdateValidMeasurementUnit(ctx context.Context, arg *UpdateValidMeasurementUnitParams) error {
	_, err := q.db.ExecContext(ctx, UpdateValidMeasurementUnit,
		arg.Name,
		arg.Description,
		arg.Volumetric,
		arg.IconPath,
		arg.ID,
	)
	return err
}

const ValidMeasurementUnitExists = `-- name: ValidMeasurementUnitExists :one
SELECT EXISTS ( SELECT valid_measurement_units.id FROM valid_measurement_units WHERE valid_measurement_units.archived_on IS NULL AND valid_measurement_units.id = $1 )
`

func (q *Queries) ValidMeasurementUnitExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, ValidMeasurementUnitExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
