// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: meal_plan_option_votes.sql

package generated

import (
	"context"
)

const ArchiveMealPlanOptionVote = `-- name: ArchiveMealPlanOptionVote :exec
UPDATE meal_plan_option_votes SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_meal_plan_option = $1 AND id = $2
`

type ArchiveMealPlanOptionVoteParams struct {
	BelongsToMealPlanOption string
	ID                      string
}

func (q *Queries) ArchiveMealPlanOptionVote(ctx context.Context, arg *ArchiveMealPlanOptionVoteParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveMealPlanOptionVote, arg.BelongsToMealPlanOption, arg.ID)
	return err
}

const GetMealPlanOptionVote = `-- name: GetMealPlanOptionVote :one
SELECT meal_plan_option_votes.id, meal_plan_option_votes.rank, meal_plan_option_votes.abstain, meal_plan_option_votes.notes, meal_plan_option_votes.by_user, meal_plan_option_votes.created_on, meal_plan_option_votes.last_updated_on, meal_plan_option_votes.archived_on, meal_plan_option_votes.belongs_to_meal_plan_option FROM meal_plan_option_votes JOIN meal_plan_options ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id JOIN meal_plans ON meal_plan_options.belongs_to_meal_plan=meal_plans.id WHERE meal_plan_option_votes.archived_on IS NULL AND meal_plan_option_votes.belongs_to_meal_plan_option = $1 AND meal_plan_option_votes.id = $2 AND meal_plan_options.archived_on IS NULL AND meal_plan_options.belongs_to_meal_plan = $3 AND meal_plan_options.id = $4 AND meal_plans.archived_on IS NULL AND meal_plans.id = $5
`

type GetMealPlanOptionVoteParams struct {
	BelongsToMealPlanOption string
	ID                      string
	BelongsToMealPlan       string
	ID_2                    string
	ID_3                    string
}

func (q *Queries) GetMealPlanOptionVote(ctx context.Context, arg *GetMealPlanOptionVoteParams) (*MealPlanOptionVotes, error) {
	row := q.db.QueryRowContext(ctx, GetMealPlanOptionVote,
		arg.BelongsToMealPlanOption,
		arg.ID,
		arg.BelongsToMealPlan,
		arg.ID_2,
		arg.ID_3,
	)
	var i MealPlanOptionVotes
	err := row.Scan(
		&i.ID,
		&i.Rank,
		&i.Abstain,
		&i.Notes,
		&i.ByUser,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
		&i.BelongsToMealPlanOption,
	)
	return &i, err
}

const GetTotalMealPlanOptionVotesCount = `-- name: GetTotalMealPlanOptionVotesCount :one
SELECT COUNT(meal_plan_option_votes.id) FROM meal_plan_option_votes WHERE meal_plan_option_votes.archived_on IS NULL
`

func (q *Queries) GetTotalMealPlanOptionVotesCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalMealPlanOptionVotesCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const MealPlanOptionVoteCreation = `-- name: MealPlanOptionVoteCreation :exec
INSERT INTO meal_plan_option_votes (id,rank,abstain,notes,by_user,belongs_to_meal_plan_option) VALUES ($1,$2,$3,$4,$5,$6)
`

type MealPlanOptionVoteCreationParams struct {
	ID                      string
	Rank                    int32
	Abstain                 bool
	Notes                   string
	ByUser                  string
	BelongsToMealPlanOption string
}

func (q *Queries) MealPlanOptionVoteCreation(ctx context.Context, arg *MealPlanOptionVoteCreationParams) error {
	_, err := q.db.ExecContext(ctx, MealPlanOptionVoteCreation,
		arg.ID,
		arg.Rank,
		arg.Abstain,
		arg.Notes,
		arg.ByUser,
		arg.BelongsToMealPlanOption,
	)
	return err
}

const MealPlanOptionVoteExists = `-- name: MealPlanOptionVoteExists :one
SELECT EXISTS ( SELECT meal_plan_option_votes.id FROM meal_plan_option_votes JOIN meal_plan_options ON meal_plan_option_votes.belongs_to_meal_plan_option=meal_plan_options.id JOIN meal_plans ON meal_plan_options.belongs_to_meal_plan=meal_plans.id WHERE meal_plan_option_votes.archived_on IS NULL AND meal_plan_option_votes.belongs_to_meal_plan_option = $1 AND meal_plan_option_votes.id = $2 AND meal_plan_options.archived_on IS NULL AND meal_plan_options.belongs_to_meal_plan = $3 AND meal_plan_options.id = $4 AND meal_plans.archived_on IS NULL AND meal_plans.id = $5 )
`

type MealPlanOptionVoteExistsParams struct {
	BelongsToMealPlanOption string
	ID                      string
	BelongsToMealPlan       string
	ID_2                    string
	ID_3                    string
}

func (q *Queries) MealPlanOptionVoteExists(ctx context.Context, arg *MealPlanOptionVoteExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, MealPlanOptionVoteExists,
		arg.BelongsToMealPlanOption,
		arg.ID,
		arg.BelongsToMealPlan,
		arg.ID_2,
		arg.ID_3,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const UpdateMealPlanOptionVote = `-- name: UpdateMealPlanOptionVote :exec
UPDATE meal_plan_option_votes SET rank = $1, abstain = $2, notes = $3, by_user = $4, last_updated_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_meal_plan_option = $5 AND id = $6
`

type UpdateMealPlanOptionVoteParams struct {
	Rank                    int32
	Abstain                 bool
	Notes                   string
	ByUser                  string
	BelongsToMealPlanOption string
	ID                      string
}

func (q *Queries) UpdateMealPlanOptionVote(ctx context.Context, arg *UpdateMealPlanOptionVoteParams) error {
	_, err := q.db.ExecContext(ctx, UpdateMealPlanOptionVote,
		arg.Rank,
		arg.Abstain,
		arg.Notes,
		arg.ByUser,
		arg.BelongsToMealPlanOption,
		arg.ID,
	)
	return err
}
