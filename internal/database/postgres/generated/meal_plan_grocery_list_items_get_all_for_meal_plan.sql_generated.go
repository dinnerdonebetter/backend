// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: meal_plan_grocery_list_items_get_all_for_meal_plan.sql

package generated

import (
	"context"
	"database/sql"
)

const GetMealPlanGroceryListItemsForMealPlan = `-- name: GetMealPlanGroceryListItemsForMealPlan :many
SELECT
    meal_plan_grocery_list_items.id,
    meal_plan_grocery_list_items.belongs_to_meal_plan,
    meal_plan_grocery_list_items.valid_ingredient,
    meal_plan_grocery_list_items.valid_measurement_unit,
    meal_plan_grocery_list_items.minimum_quantity_needed,
    meal_plan_grocery_list_items.maximum_quantity_needed,
    meal_plan_grocery_list_items.quantity_purchased,
    meal_plan_grocery_list_items.purchased_measurement_unit,
    meal_plan_grocery_list_items.purchased_upc,
    meal_plan_grocery_list_items.purchase_price,
    meal_plan_grocery_list_items.status_explanation,
    meal_plan_grocery_list_items.status,
    meal_plan_grocery_list_items.created_at,
    meal_plan_grocery_list_items.last_updated_at,
    meal_plan_grocery_list_items.completed_at
FROM meal_plan_grocery_list_items
    FULL OUTER JOIN meal_plans ON meal_plan_grocery_list_items.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_grocery_list_items.completed_at IS NULL
  AND meal_plan_grocery_list_items.belongs_to_meal_plan = $1
  AND meal_plans.archived_at IS NULL
  AND meal_plans.id = $1
GROUP BY meal_plan_grocery_list_items.id
ORDER BY meal_plan_grocery_list_items.id
`

type GetMealPlanGroceryListItemsForMealPlanRow struct {
	CompletedAt              sql.NullTime              `db:"completed_at"`
	LastUpdatedAt            sql.NullTime              `db:"last_updated_at"`
	CreatedAt                sql.NullTime              `db:"created_at"`
	PurchasedMeasurementUnit sql.NullString            `db:"purchased_measurement_unit"`
	MinimumQuantityNeeded    sql.NullString            `db:"minimum_quantity_needed"`
	MaximumQuantityNeeded    sql.NullString            `db:"maximum_quantity_needed"`
	QuantityPurchased        sql.NullString            `db:"quantity_purchased"`
	ValidMeasurementUnit     sql.NullString            `db:"valid_measurement_unit"`
	PurchasedUpc             sql.NullString            `db:"purchased_upc"`
	PurchasePrice            sql.NullString            `db:"purchase_price"`
	StatusExplanation        sql.NullString            `db:"status_explanation"`
	Status                   NullGroceryListItemStatus `db:"status"`
	ValidIngredient          sql.NullString            `db:"valid_ingredient"`
	BelongsToMealPlan        sql.NullString            `db:"belongs_to_meal_plan"`
	ID                       sql.NullString            `db:"id"`
}

func (q *Queries) GetMealPlanGroceryListItemsForMealPlan(ctx context.Context, belongsToMealPlan string) ([]*GetMealPlanGroceryListItemsForMealPlanRow, error) {
	rows, err := q.query(ctx, q.getMealPlanGroceryListItemsForMealPlanStmt, GetMealPlanGroceryListItemsForMealPlan, belongsToMealPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMealPlanGroceryListItemsForMealPlanRow{}
	for rows.Next() {
		var i GetMealPlanGroceryListItemsForMealPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToMealPlan,
			&i.ValidIngredient,
			&i.ValidMeasurementUnit,
			&i.MinimumQuantityNeeded,
			&i.MaximumQuantityNeeded,
			&i.QuantityPurchased,
			&i.PurchasedMeasurementUnit,
			&i.PurchasedUpc,
			&i.PurchasePrice,
			&i.StatusExplanation,
			&i.Status,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
