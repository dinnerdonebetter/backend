// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_many.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getHouseholdInstrumentOwnerships = `-- name: GetHouseholdInstrumentOwnerships :many

SELECT
  household_instrument_ownerships.id,
  household_instrument_ownerships.notes,
  household_instrument_ownerships.quantity,
  valid_instruments.id,
  valid_instruments.name,
  valid_instruments.plural_name,
  valid_instruments.description,
  valid_instruments.icon_path,
  valid_instruments.usable_for_storage,
  valid_instruments.display_in_summary_lists,
  valid_instruments.include_in_generated_instructions,
  valid_instruments.slug,
  valid_instruments.created_at,
  valid_instruments.last_updated_at,
  valid_instruments.archived_at,
  household_instrument_ownerships.belongs_to_household,
  household_instrument_ownerships.created_at,
  household_instrument_ownerships.last_updated_at,
  household_instrument_ownerships.archived_at,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
      AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
      AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
      )
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
  ) as total_count
FROM
  household_instrument_ownerships
  JOIN valid_instruments ON valid_instruments.id = household_instrument_ownerships.valid_instrument_id
WHERE household_instrument_ownerships.belongs_to_household = $1
  AND household_instrument_ownerships.archived_at IS NULL
  AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
  AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
  )
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  household_instrument_ownerships.id,
  valid_instruments.id
ORDER BY
  household_instrument_ownerships.id
OFFSET $6
LIMIT $7
`

type GetHouseholdInstrumentOwnershipsParams struct {
	BelongsToHousehold string
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	LastUpdatedAt      sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	Offset             int32
	Limit              int32
}

type GetHouseholdInstrumentOwnershipsRow struct {
	CreatedAt                      time.Time
	CreatedAt_2                    time.Time
	ArchivedAt_2                   sql.NullTime
	LastUpdatedAt_2                sql.NullTime
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	BelongsToHousehold             string
	ID_2                           string
	Notes                          string
	IconPath                       string
	ID                             string
	Slug                           string
	Description                    string
	PluralName                     string
	Name                           string
	FilteredCount                  int64
	TotalCount                     int64
	Quantity                       int32
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) GetHouseholdInstrumentOwnerships(ctx context.Context, db DBTX, arg *GetHouseholdInstrumentOwnershipsParams) ([]*GetHouseholdInstrumentOwnershipsRow, error) {
	rows, err := db.QueryContext(ctx, getHouseholdInstrumentOwnerships,
		arg.BelongsToHousehold,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHouseholdInstrumentOwnershipsRow{}
	for rows.Next() {
		var i GetHouseholdInstrumentOwnershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Quantity,
			&i.ID_2,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeRatings = `-- name: GetRecipeRatings :many

SELECT
	recipe_ratings.id,
    recipe_ratings.recipe_id,
    recipe_ratings.taste,
    recipe_ratings.difficulty,
    recipe_ratings.cleanup,
    recipe_ratings.instructions,
    recipe_ratings.overall,
    recipe_ratings.notes,
    recipe_ratings.by_user,
    recipe_ratings.created_at,
    recipe_ratings.last_updated_at,
    recipe_ratings.archived_at,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	 AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	) as total_count
FROM
	recipe_ratings
WHERE
	recipe_ratings.archived_at IS NULL
	AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_ratings.id
ORDER BY
	recipe_ratings.id
	LIMIT $5
`

type GetRecipeRatingsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Limit           int32
}

type GetRecipeRatingsRow struct {
	CreatedAt     time.Time
	ArchivedAt    sql.NullTime
	LastUpdatedAt sql.NullTime
	Notes         string
	RecipeID      string
	ID            string
	ByUser        string
	Difficulty    sql.NullString
	Overall       sql.NullString
	Instructions  sql.NullString
	Cleanup       sql.NullString
	Taste         sql.NullString
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetRecipeRatings(ctx context.Context, db DBTX, arg *GetRecipeRatingsParams) ([]*GetRecipeRatingsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeRatings,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeRatingsRow{}
	for rows.Next() {
		var i GetRecipeRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.Taste,
			&i.Difficulty,
			&i.Cleanup,
			&i.Instructions,
			&i.Overall,
			&i.Notes,
			&i.ByUser,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeStepCompletionConditions = `-- name: GetRecipeStepCompletionConditions :many

SELECT
	recipe_step_completion_condition_ingredients.id,
	recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition,
	recipe_step_completion_condition_ingredients.recipe_step_ingredient,
	recipe_step_completion_conditions.id,
	recipe_step_completion_conditions.belongs_to_recipe_step,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	recipe_step_completion_conditions.optional,
	recipe_step_completion_conditions.notes,
	recipe_step_completion_conditions.created_at,
	recipe_step_completion_conditions.last_updated_at,
	recipe_step_completion_conditions.archived_at,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	      AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	) as total_count
FROM recipe_step_completion_condition_ingredients
	JOIN recipe_step_completion_conditions ON recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition = recipe_step_completion_conditions.id
	JOIN recipe_steps ON recipe_step_completion_conditions.belongs_to_recipe_step = recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe = recipes.id
	JOIN valid_ingredient_states ON recipe_step_completion_conditions.ingredient_state = valid_ingredient_states.id
WHERE
	recipe_step_completion_conditions.archived_at IS NULL
	AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_step_completion_conditions.id,
	valid_ingredient_states.id,
	recipe_step_completion_condition_ingredients.id
ORDER BY
	recipe_step_completion_conditions.id
	LIMIT $5
	OFFSET $6
`

type GetRecipeStepCompletionConditionsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Limit           int32
	Offset          int32
}

type GetRecipeStepCompletionConditionsRow struct {
	CreatedAt                              time.Time
	CreatedAt_2                            time.Time
	ArchivedAt_2                           sql.NullTime
	LastUpdatedAt_2                        sql.NullTime
	ArchivedAt                             sql.NullTime
	LastUpdatedAt                          sql.NullTime
	PastTense                              string
	ID_3                                   string
	IconPath                               string
	Slug                                   string
	ID                                     string
	AttributeType                          IngredientAttributeType
	Name                                   string
	Description                            string
	BelongsToRecipeStep                    string
	BelongsToRecipeStepCompletionCondition string
	Notes                                  string
	ID_2                                   string
	RecipeStepIngredient                   string
	FilteredCount                          int64
	TotalCount                             int64
	Optional                               bool
}

func (q *Queries) GetRecipeStepCompletionConditions(ctx context.Context, db DBTX, arg *GetRecipeStepCompletionConditionsParams) ([]*GetRecipeStepCompletionConditionsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepCompletionConditions,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepCompletionConditionsRow{}
	for rows.Next() {
		var i GetRecipeStepCompletionConditionsRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToRecipeStepCompletionCondition,
			&i.RecipeStepIngredient,
			&i.ID_2,
			&i.BelongsToRecipeStep,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.Slug,
			&i.PastTense,
			&i.AttributeType,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.Optional,
			&i.Notes,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
          AND users.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND users.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $5
    ) as filtered_count,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
    ) as total_count
FROM users
WHERE
    users.archived_at IS NULL
  AND users.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
  AND users.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
    )
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
    )
OFFSET $5
LIMIT $6
`

type GetUsersParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetUsersRow struct {
	CreatedAt                    time.Time
	Birthday                     sql.NullTime
	PasswordLastChangedAt        sql.NullTime
	TwoFactorSecretVerifiedAt    sql.NullTime
	ArchivedAt                   sql.NullTime
	EmailAddressVerifiedAt       sql.NullTime
	LastUpdatedAt                sql.NullTime
	LastAcceptedPrivacyPolicy    sql.NullTime
	LastAcceptedTermsOfService   sql.NullTime
	HashedPassword               string
	TwoFactorSecret              string
	ServiceRole                  string
	Username                     string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	ID                           string
	EmailAddress                 string
	LastName                     string
	FirstName                    string
	AvatarSrc                    sql.NullString
	FilteredCount                int64
	TotalCount                   int64
	RequiresPasswordChange       bool
}

func (q *Queries) GetUsers(ctx context.Context, db DBTX, arg *GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := db.QueryContext(ctx, getUsers,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.EmailAddress,
			&i.EmailAddressVerifiedAt,
			&i.AvatarSrc,
			&i.HashedPassword,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedAt,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientGroups = `-- name: GetValidIngredientGroups :many

SELECT
    valid_ingredient_groups.id,
    valid_ingredient_groups.name,
    valid_ingredient_groups.description,
    valid_ingredient_groups.slug,
    valid_ingredient_groups.created_at,
    valid_ingredient_groups.last_updated_at,
    valid_ingredient_groups.archived_at,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
          AND valid_ingredient_groups.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_groups.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $5
    ) AS filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
    ) AS total_count
FROM valid_ingredient_groups
WHERE
	valid_ingredient_groups.archived_at IS NULL
	AND valid_ingredient_groups.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND valid_ingredient_groups.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	)
	OFFSET $5
    LIMIT $6
`

type GetValidIngredientGroupsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientGroupsRow struct {
	ID            string
	Name          string
	Description   string
	Slug          string
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetValidIngredientGroups(ctx context.Context, db DBTX, arg *GetValidIngredientGroupsParams) ([]*GetValidIngredientGroupsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientGroups,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientGroupsRow{}
	for rows.Next() {
		var i GetValidIngredientGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientMeasurementUnits = `-- name: GetValidIngredientMeasurementUnits :many

SELECT
	valid_ingredient_measurement_units.id as valid_ingredient_measurement_unit_id,
	valid_ingredient_measurement_units.notes as valid_ingredient_measurement_unit_notes,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	valid_ingredients.id as valid_ingredient_id,
	valid_ingredients.name as valid_ingredient_name,
	valid_ingredients.description as valid_ingredient_description,
	valid_ingredients.warning as valid_ingredient_warning,
	valid_ingredients.contains_egg as valid_ingredient_contains_egg,
	valid_ingredients.contains_dairy as valid_ingredient_contains_dairy,
	valid_ingredients.contains_peanut as valid_ingredient_contains_peanut,
	valid_ingredients.contains_tree_nut as valid_ingredient_contains_tree_nut,
	valid_ingredients.contains_soy as valid_ingredient_contains_soy,
	valid_ingredients.contains_wheat as valid_ingredient_contains_wheat,
	valid_ingredients.contains_shellfish as valid_ingredient_contains_shellfish,
	valid_ingredients.contains_sesame as valid_ingredient_contains_sesame,
	valid_ingredients.contains_fish as valid_ingredient_contains_fish,
	valid_ingredients.contains_gluten as valid_ingredient_contains_gluten,
	valid_ingredients.animal_flesh as valid_ingredient_animal_flesh,
	valid_ingredients.volumetric as valid_ingredient_volumetric,
	valid_ingredients.is_liquid as valid_ingredient_is_liquid,
	valid_ingredients.icon_path as valid_ingredient_icon_path,
	valid_ingredients.animal_derived as valid_ingredient_animal_derived,
	valid_ingredients.plural_name as valid_ingredient_plural_name,
	valid_ingredients.restrict_to_preparations as valid_ingredient_restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius as valid_ingredient_minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius as valid_ingredient_maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions as valid_ingredient_storage_instructions,
	valid_ingredients.slug as valid_ingredient_slug,
	valid_ingredients.contains_alcohol as valid_ingredient_contains_alcohol,
	valid_ingredients.shopping_suggestions as valid_ingredient_shopping_suggestions,
    valid_ingredients.is_starch as valid_ingredient_is_starch,
    valid_ingredients.is_protein as valid_ingredient_is_protein,
    valid_ingredients.is_grain as valid_ingredient_is_grain,
    valid_ingredients.is_fruit as valid_ingredient_is_fruit,
    valid_ingredients.is_salt as valid_ingredient_is_salt,
    valid_ingredients.is_fat as valid_ingredient_is_fat,
    valid_ingredients.is_acid as valid_ingredient_is_acid,
    valid_ingredients.is_heat as valid_ingredient_is_heat,
	valid_ingredients.created_at as valid_ingredient_created_at,
	valid_ingredients.last_updated_at as valid_ingredient_last_updated_at,
	valid_ingredients.archived_at as valid_ingredient_archived_at,
	valid_ingredient_measurement_units.minimum_allowable_quantity as valid_ingredient_measurement_unit_minimum_allowable_quantity,
	valid_ingredient_measurement_units.maximum_allowable_quantity as valid_ingredient_measurement_unit_maximum_allowable_quantity,
	valid_ingredient_measurement_units.created_at as valid_ingredient_measurement_unit_created_at,
	valid_ingredient_measurement_units.last_updated_at as valid_ingredient_measurement_unit_last_updated_at,
	valid_ingredient_measurement_units.archived_at as valid_ingredient_measurement_unit_archived_at,
    (
        SELECT
            COUNT(valid_ingredient_measurement_units.id)
        FROM
            valid_ingredient_measurement_units
        WHERE
            valid_ingredient_measurement_units.archived_at IS NULL
          AND valid_ingredient_measurement_units.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_measurement_units.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (valid_ingredient_measurement_units.last_updated_at IS NULL OR valid_ingredient_measurement_units.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
          AND (valid_ingredient_measurement_units.last_updated_at IS NULL OR valid_ingredient_measurement_units.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_measurement_units.id)
        FROM
            valid_ingredient_measurement_units
        WHERE
            valid_ingredient_measurement_units.archived_at IS NULL
    ) as total_count
FROM valid_ingredient_measurement_units
	JOIN valid_measurement_units ON valid_ingredient_measurement_units.valid_measurement_unit_id = valid_measurement_units.id
	JOIN valid_ingredients ON valid_ingredient_measurement_units.valid_ingredient_id = valid_ingredients.id
WHERE valid_ingredient_measurement_units.archived_at IS NULL
    AND valid_measurement_units.archived_at IS NULL
    AND valid_ingredients.archived_at IS NULL
    AND valid_ingredient_measurement_units.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
    AND valid_ingredient_measurement_units.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
    AND (valid_ingredient_measurement_units.last_updated_at IS NULL OR valid_ingredient_measurement_units.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
    AND (valid_ingredient_measurement_units.last_updated_at IS NULL OR valid_ingredient_measurement_units.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
OFFSET $5
LIMIT $6
`

type GetValidIngredientMeasurementUnitsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientMeasurementUnitsRow struct {
	ValidIngredientCreatedAt                               time.Time
	ValidIngredientMeasurementUnitCreatedAt                time.Time
	ValidMeasurementUnitCreatedAt                          time.Time
	ValidIngredientMeasurementUnitArchivedAt               sql.NullTime
	ValidIngredientLastUpdatedAt                           sql.NullTime
	ValidIngredientArchivedAt                              sql.NullTime
	ValidIngredientMeasurementUnitLastUpdatedAt            sql.NullTime
	ValidMeasurementUnitArchivedAt                         sql.NullTime
	ValidMeasurementUnitLastUpdatedAt                      sql.NullTime
	ValidIngredientName                                    string
	ValidIngredientMeasurementUnitMinimumAllowableQuantity string
	ValidMeasurementUnitPluralName                         string
	ValidIngredientIconPath                                string
	ValidIngredientMeasurementUnitID                       string
	ValidMeasurementUnitIconPath                           string
	ValidIngredientID                                      string
	ValidIngredientPluralName                              string
	ValidIngredientDescription                             string
	ValidIngredientWarning                                 string
	ValidIngredientStorageInstructions                     string
	ValidMeasurementUnitDescription                        string
	ValidIngredientSlug                                    string
	ValidMeasurementUnitSlug                               string
	ValidMeasurementUnitName                               string
	ValidMeasurementUnitID                                 string
	ValidIngredientMeasurementUnitNotes                    string
	ValidIngredientShoppingSuggestions                     string
	ValidIngredientMeasurementUnitMaximumAllowableQuantity sql.NullString
	ValidIngredientMaximumIdealStorageTemperatureInCelsius sql.NullString
	ValidIngredientMinimumIdealStorageTemperatureInCelsius sql.NullString
	TotalCount                                             int64
	FilteredCount                                          int64
	ValidMeasurementUnitVolumetric                         sql.NullBool
	ValidIngredientIsLiquid                                sql.NullBool
	ValidIngredientAnimalFlesh                             bool
	ValidIngredientRestrictToPreparations                  bool
	ValidIngredientAnimalDerived                           bool
	ValidIngredientVolumetric                              bool
	ValidIngredientContainsGluten                          bool
	ValidIngredientContainsFish                            bool
	ValidIngredientContainsAlcohol                         bool
	ValidIngredientContainsSesame                          bool
	ValidIngredientIsStarch                                bool
	ValidIngredientIsProtein                               bool
	ValidIngredientIsGrain                                 bool
	ValidIngredientIsFruit                                 bool
	ValidIngredientIsSalt                                  bool
	ValidIngredientIsFat                                   bool
	ValidIngredientIsAcid                                  bool
	ValidIngredientIsHeat                                  bool
	ValidIngredientContainsShellfish                       bool
	ValidIngredientContainsWheat                           bool
	ValidIngredientContainsSoy                             bool
	ValidIngredientContainsTreeNut                         bool
	ValidIngredientContainsPeanut                          bool
	ValidIngredientContainsDairy                           bool
	ValidIngredientContainsEgg                             bool
	ValidMeasurementUnitImperial                           bool
	ValidMeasurementUnitMetric                             bool
	ValidMeasurementUnitUniversal                          bool
}

func (q *Queries) GetValidIngredientMeasurementUnits(ctx context.Context, db DBTX, arg *GetValidIngredientMeasurementUnitsParams) ([]*GetValidIngredientMeasurementUnitsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientMeasurementUnits,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientMeasurementUnitsRow{}
	for rows.Next() {
		var i GetValidIngredientMeasurementUnitsRow
		if err := rows.Scan(
			&i.ValidIngredientMeasurementUnitID,
			&i.ValidIngredientMeasurementUnitNotes,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.ValidIngredientID,
			&i.ValidIngredientName,
			&i.ValidIngredientDescription,
			&i.ValidIngredientWarning,
			&i.ValidIngredientContainsEgg,
			&i.ValidIngredientContainsDairy,
			&i.ValidIngredientContainsPeanut,
			&i.ValidIngredientContainsTreeNut,
			&i.ValidIngredientContainsSoy,
			&i.ValidIngredientContainsWheat,
			&i.ValidIngredientContainsShellfish,
			&i.ValidIngredientContainsSesame,
			&i.ValidIngredientContainsFish,
			&i.ValidIngredientContainsGluten,
			&i.ValidIngredientAnimalFlesh,
			&i.ValidIngredientVolumetric,
			&i.ValidIngredientIsLiquid,
			&i.ValidIngredientIconPath,
			&i.ValidIngredientAnimalDerived,
			&i.ValidIngredientPluralName,
			&i.ValidIngredientRestrictToPreparations,
			&i.ValidIngredientMinimumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientMaximumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientStorageInstructions,
			&i.ValidIngredientSlug,
			&i.ValidIngredientContainsAlcohol,
			&i.ValidIngredientShoppingSuggestions,
			&i.ValidIngredientIsStarch,
			&i.ValidIngredientIsProtein,
			&i.ValidIngredientIsGrain,
			&i.ValidIngredientIsFruit,
			&i.ValidIngredientIsSalt,
			&i.ValidIngredientIsFat,
			&i.ValidIngredientIsAcid,
			&i.ValidIngredientIsHeat,
			&i.ValidIngredientCreatedAt,
			&i.ValidIngredientLastUpdatedAt,
			&i.ValidIngredientArchivedAt,
			&i.ValidIngredientMeasurementUnitMinimumAllowableQuantity,
			&i.ValidIngredientMeasurementUnitMaximumAllowableQuantity,
			&i.ValidIngredientMeasurementUnitCreatedAt,
			&i.ValidIngredientMeasurementUnitLastUpdatedAt,
			&i.ValidIngredientMeasurementUnitArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientPreparations = `-- name: GetValidIngredientPreparations :many

SELECT
    valid_ingredient_preparations.id as valid_ingredient_preparation_id,
    valid_ingredient_preparations.notes as valid_ingredient_preparation_notes,
    valid_preparations.id as valid_preparation_id,
    valid_preparations.name as valid_preparation_name,
    valid_preparations.description as valid_preparation_description,
    valid_preparations.icon_path as valid_preparation_icon_path,
    valid_preparations.yields_nothing as valid_preparation_yields_nothing,
    valid_preparations.restrict_to_ingredients as valid_preparation_restrict_to_ingredients,
    valid_preparations.minimum_ingredient_count as valid_preparation_minimum_ingredient_count,
    valid_preparations.maximum_ingredient_count as valid_preparation_maximum_ingredient_count,
    valid_preparations.minimum_instrument_count as valid_preparation_minimum_instrument_count,
    valid_preparations.maximum_instrument_count as valid_preparation_maximum_instrument_count,
    valid_preparations.temperature_required as valid_preparation_temperature_required,
    valid_preparations.time_estimate_required as valid_preparation_time_estimate_required,
    valid_preparations.condition_expression_required as valid_preparation_condition_expression_required,
    valid_preparations.consumes_vessel as valid_preparation_consumes_vessel,
    valid_preparations.only_for_vessels as valid_preparation_only_for_vessels,
    valid_preparations.minimum_vessel_count as valid_preparation_minimum_vessel_count,
    valid_preparations.maximum_vessel_count as valid_preparation_maximum_vessel_count,
    valid_preparations.slug as valid_preparation_slug,
    valid_preparations.past_tense as valid_preparation_past_tense,
    valid_preparations.created_at as valid_preparation_created_at,
    valid_preparations.last_updated_at as valid_preparation_last_updated_at,
    valid_preparations.archived_at as valid_preparation_archived_at,
    valid_ingredients.id as valid_ingredient_id,
    valid_ingredients.name as valid_ingredient_name,
    valid_ingredients.description as valid_ingredient_description,
    valid_ingredients.warning as valid_ingredient_warning,
    valid_ingredients.contains_egg as valid_ingredient_contains_egg,
    valid_ingredients.contains_dairy as valid_ingredient_contains_dairy,
    valid_ingredients.contains_peanut as valid_ingredient_contains_peanut,
    valid_ingredients.contains_tree_nut as valid_ingredient_contains_tree_nut,
    valid_ingredients.contains_soy as valid_ingredient_contains_soy,
    valid_ingredients.contains_wheat as valid_ingredient_contains_wheat,
    valid_ingredients.contains_shellfish as valid_ingredient_contains_shellfish,
    valid_ingredients.contains_sesame as valid_ingredient_contains_sesame,
    valid_ingredients.contains_fish as valid_ingredient_contains_fish,
    valid_ingredients.contains_gluten as valid_ingredient_contains_gluten,
    valid_ingredients.animal_flesh as valid_ingredient_animal_flesh,
    valid_ingredients.volumetric as valid_ingredient_volumetric,
    valid_ingredients.is_liquid as valid_ingredient_is_liquid,
    valid_ingredients.icon_path as valid_ingredient_icon_path,
    valid_ingredients.animal_derived as valid_ingredient_animal_derived,
    valid_ingredients.plural_name as valid_ingredient_plural_name,
    valid_ingredients.restrict_to_preparations as valid_ingredient_restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius as valid_ingredient_minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius as valid_ingredient_maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions as valid_ingredient_storage_instructions,
    valid_ingredients.slug as valid_ingredient_slug,
    valid_ingredients.contains_alcohol as valid_ingredient_contains_alcohol,
    valid_ingredients.shopping_suggestions as valid_ingredient_shopping_suggestions,
    valid_ingredients.is_starch as valid_ingredient_is_starch,
    valid_ingredients.is_protein as valid_ingredient_is_protein,
    valid_ingredients.is_grain as valid_ingredient_is_grain,
    valid_ingredients.is_fruit as valid_ingredient_is_fruit,
    valid_ingredients.is_salt as valid_ingredient_is_salt,
    valid_ingredients.is_fat as valid_ingredient_is_fat,
    valid_ingredients.is_acid as valid_ingredient_is_acid,
    valid_ingredients.is_heat as valid_ingredient_is_heat,
    valid_ingredients.created_at as valid_ingredient_created_at,
    valid_ingredients.last_updated_at as valid_ingredient_last_updated_at,
    valid_ingredients.archived_at as valid_ingredient_archived_at,
    valid_ingredient_preparations.created_at as valid_ingredient_preparation_created_at,
    valid_ingredient_preparations.last_updated_at as valid_ingredient_preparation_last_updated_at,
    valid_ingredient_preparations.archived_at as valid_ingredient_preparation_archived_at,
    (
        SELECT
            COUNT(valid_ingredient_preparations.id)
        FROM
            valid_ingredient_preparations
        WHERE
            valid_ingredient_preparations.archived_at IS NULL
          AND valid_ingredient_preparations.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_preparations.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (valid_ingredient_preparations.last_updated_at IS NULL OR valid_ingredient_preparations.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
          AND (valid_ingredient_preparations.last_updated_at IS NULL OR valid_ingredient_preparations.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_preparations.id)
        FROM
            valid_ingredient_preparations
        WHERE
            valid_ingredient_preparations.archived_at IS NULL
    ) as total_count
FROM
    valid_ingredient_preparations
        JOIN valid_ingredients ON valid_ingredient_preparations.valid_ingredient_id = valid_ingredients.id
        JOIN valid_preparations ON valid_ingredient_preparations.valid_preparation_id = valid_preparations.id
WHERE
    valid_ingredient_preparations.archived_at IS NULL
  AND valid_ingredient_preparations.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
  AND valid_ingredient_preparations.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
  AND (valid_ingredient_preparations.last_updated_at IS NULL OR valid_ingredient_preparations.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
  AND (valid_ingredient_preparations.last_updated_at IS NULL OR valid_ingredient_preparations.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
OFFSET $5
    LIMIT $6
`

type GetValidIngredientPreparationsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientPreparationsRow struct {
	ValidPreparationCreatedAt                              time.Time
	ValidIngredientPreparationCreatedAt                    time.Time
	ValidIngredientCreatedAt                               time.Time
	ValidIngredientPreparationArchivedAt                   sql.NullTime
	ValidIngredientLastUpdatedAt                           sql.NullTime
	ValidPreparationArchivedAt                             sql.NullTime
	ValidPreparationLastUpdatedAt                          sql.NullTime
	ValidIngredientArchivedAt                              sql.NullTime
	ValidIngredientPreparationLastUpdatedAt                sql.NullTime
	ValidIngredientIconPath                                string
	ValidPreparationPastTense                              string
	ValidIngredientPreparationID                           string
	ValidIngredientPluralName                              string
	ValidIngredientPreparationNotes                        string
	ValidPreparationName                                   string
	ValidPreparationID                                     string
	ValidIngredientWarning                                 string
	ValidIngredientStorageInstructions                     string
	ValidIngredientSlug                                    string
	ValidPreparationSlug                                   string
	ValidIngredientDescription                             string
	ValidIngredientShoppingSuggestions                     string
	ValidPreparationIconPath                               string
	ValidPreparationDescription                            string
	ValidIngredientID                                      string
	ValidIngredientName                                    string
	ValidIngredientMinimumIdealStorageTemperatureInCelsius sql.NullString
	ValidIngredientMaximumIdealStorageTemperatureInCelsius sql.NullString
	TotalCount                                             int64
	FilteredCount                                          int64
	ValidPreparationMaximumIngredientCount                 sql.NullInt32
	ValidPreparationMaximumVesselCount                     sql.NullInt32
	ValidPreparationMaximumInstrumentCount                 sql.NullInt32
	ValidPreparationMinimumVesselCount                     int32
	ValidPreparationMinimumInstrumentCount                 int32
	ValidPreparationMinimumIngredientCount                 int32
	ValidIngredientIsLiquid                                sql.NullBool
	ValidPreparationConsumesVessel                         bool
	ValidIngredientAnimalFlesh                             bool
	ValidIngredientVolumetric                              bool
	ValidIngredientContainsGluten                          bool
	ValidIngredientContainsFish                            bool
	ValidIngredientAnimalDerived                           bool
	ValidIngredientContainsSesame                          bool
	ValidIngredientRestrictToPreparations                  bool
	ValidIngredientContainsShellfish                       bool
	ValidIngredientContainsWheat                           bool
	ValidIngredientContainsSoy                             bool
	ValidIngredientContainsTreeNut                         bool
	ValidIngredientContainsAlcohol                         bool
	ValidIngredientContainsPeanut                          bool
	ValidIngredientIsStarch                                bool
	ValidIngredientIsProtein                               bool
	ValidIngredientIsGrain                                 bool
	ValidIngredientIsFruit                                 bool
	ValidIngredientIsSalt                                  bool
	ValidIngredientIsFat                                   bool
	ValidIngredientIsAcid                                  bool
	ValidIngredientIsHeat                                  bool
	ValidIngredientContainsDairy                           bool
	ValidIngredientContainsEgg                             bool
	ValidPreparationOnlyForVessels                         bool
	ValidPreparationConditionExpressionRequired            bool
	ValidPreparationTimeEstimateRequired                   bool
	ValidPreparationTemperatureRequired                    bool
	ValidPreparationRestrictToIngredients                  bool
	ValidPreparationYieldsNothing                          bool
}

func (q *Queries) GetValidIngredientPreparations(ctx context.Context, db DBTX, arg *GetValidIngredientPreparationsParams) ([]*GetValidIngredientPreparationsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientPreparations,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientPreparationsRow{}
	for rows.Next() {
		var i GetValidIngredientPreparationsRow
		if err := rows.Scan(
			&i.ValidIngredientPreparationID,
			&i.ValidIngredientPreparationNotes,
			&i.ValidPreparationID,
			&i.ValidPreparationName,
			&i.ValidPreparationDescription,
			&i.ValidPreparationIconPath,
			&i.ValidPreparationYieldsNothing,
			&i.ValidPreparationRestrictToIngredients,
			&i.ValidPreparationMinimumIngredientCount,
			&i.ValidPreparationMaximumIngredientCount,
			&i.ValidPreparationMinimumInstrumentCount,
			&i.ValidPreparationMaximumInstrumentCount,
			&i.ValidPreparationTemperatureRequired,
			&i.ValidPreparationTimeEstimateRequired,
			&i.ValidPreparationConditionExpressionRequired,
			&i.ValidPreparationConsumesVessel,
			&i.ValidPreparationOnlyForVessels,
			&i.ValidPreparationMinimumVesselCount,
			&i.ValidPreparationMaximumVesselCount,
			&i.ValidPreparationSlug,
			&i.ValidPreparationPastTense,
			&i.ValidPreparationCreatedAt,
			&i.ValidPreparationLastUpdatedAt,
			&i.ValidPreparationArchivedAt,
			&i.ValidIngredientID,
			&i.ValidIngredientName,
			&i.ValidIngredientDescription,
			&i.ValidIngredientWarning,
			&i.ValidIngredientContainsEgg,
			&i.ValidIngredientContainsDairy,
			&i.ValidIngredientContainsPeanut,
			&i.ValidIngredientContainsTreeNut,
			&i.ValidIngredientContainsSoy,
			&i.ValidIngredientContainsWheat,
			&i.ValidIngredientContainsShellfish,
			&i.ValidIngredientContainsSesame,
			&i.ValidIngredientContainsFish,
			&i.ValidIngredientContainsGluten,
			&i.ValidIngredientAnimalFlesh,
			&i.ValidIngredientVolumetric,
			&i.ValidIngredientIsLiquid,
			&i.ValidIngredientIconPath,
			&i.ValidIngredientAnimalDerived,
			&i.ValidIngredientPluralName,
			&i.ValidIngredientRestrictToPreparations,
			&i.ValidIngredientMinimumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientMaximumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientStorageInstructions,
			&i.ValidIngredientSlug,
			&i.ValidIngredientContainsAlcohol,
			&i.ValidIngredientShoppingSuggestions,
			&i.ValidIngredientIsStarch,
			&i.ValidIngredientIsProtein,
			&i.ValidIngredientIsGrain,
			&i.ValidIngredientIsFruit,
			&i.ValidIngredientIsSalt,
			&i.ValidIngredientIsFat,
			&i.ValidIngredientIsAcid,
			&i.ValidIngredientIsHeat,
			&i.ValidIngredientCreatedAt,
			&i.ValidIngredientLastUpdatedAt,
			&i.ValidIngredientArchivedAt,
			&i.ValidIngredientPreparationCreatedAt,
			&i.ValidIngredientPreparationLastUpdatedAt,
			&i.ValidIngredientPreparationArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientStateIngredients = `-- name: GetValidIngredientStateIngredients :many

SELECT
	valid_ingredient_state_ingredients.id as valid_ingredient_state_ingredient_id,
	valid_ingredient_state_ingredients.notes as valid_ingredient_state_ingredient_notes,
	valid_ingredient_states.id as valid_ingredient_state_id,
	valid_ingredient_states.name as valid_ingredient_state_name,
    valid_ingredient_states.description as valid_ingredient_state_description,
	valid_ingredient_states.icon_path as valid_ingredient_state_icon_path,
	valid_ingredient_states.slug as valid_ingredient_state_slug,
	valid_ingredient_states.past_tense as valid_ingredient_state_past_tense,
	valid_ingredient_states.attribute_type as valid_ingredient_state_attribute_type,
	valid_ingredient_states.created_at as valid_ingredient_state_created_at,
	valid_ingredient_states.last_updated_at as valid_ingredient_state_last_updated_at,
	valid_ingredient_states.archived_at as valid_ingredient_state_archived_at,
	valid_ingredients.id as valid_ingredient_id,
	valid_ingredients.name as valid_ingredient_name,
	valid_ingredients.description as valid_ingredient_description,
	valid_ingredients.warning as valid_ingredient_warning,
	valid_ingredients.contains_egg as valid_ingredient_contains_egg,
	valid_ingredients.contains_dairy as valid_ingredient_contains_dairy,
	valid_ingredients.contains_peanut as valid_ingredient_contains_peanut,
	valid_ingredients.contains_tree_nut as valid_ingredient_contains_tree_nut,
	valid_ingredients.contains_soy as valid_ingredient_contains_soy,
	valid_ingredients.contains_wheat as valid_ingredient_contains_wheat,
	valid_ingredients.contains_shellfish as valid_ingredient_contains_shellfish,
	valid_ingredients.contains_sesame as valid_ingredient_contains_sesame,
	valid_ingredients.contains_fish as valid_ingredient_contains_fish,
	valid_ingredients.contains_gluten as valid_ingredient_contains_gluten,
	valid_ingredients.animal_flesh as valid_ingredient_animal_flesh,
	valid_ingredients.volumetric as valid_ingredient_volumetric,
	valid_ingredients.is_liquid as valid_ingredient_is_liquid,
	valid_ingredients.icon_path as valid_ingredient_icon_path,
	valid_ingredients.animal_derived as valid_ingredient_animal_derived,
	valid_ingredients.plural_name as valid_ingredient_plural_name,
	valid_ingredients.restrict_to_preparations as valid_ingredient_restrict_to_preparations,
	valid_ingredients.minimum_ideal_storage_temperature_in_celsius as valid_ingredient_minimum_ideal_storage_temperature_in_celsius,
	valid_ingredients.maximum_ideal_storage_temperature_in_celsius as valid_ingredient_maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions as valid_ingredient_storage_instructions,
	valid_ingredients.slug as valid_ingredient_slug,
	valid_ingredients.contains_alcohol as valid_ingredient_contains_alcohol,
	valid_ingredients.shopping_suggestions as valid_ingredient_shopping_suggestions,
    valid_ingredients.is_starch as valid_ingredient_is_starch,
    valid_ingredients.is_protein as valid_ingredient_is_protein,
    valid_ingredients.is_grain as valid_ingredient_is_grain,
    valid_ingredients.is_fruit as valid_ingredient_is_fruit,
    valid_ingredients.is_salt as valid_ingredient_is_salt,
    valid_ingredients.is_fat as valid_ingredient_is_fat,
    valid_ingredients.is_acid as valid_ingredient_is_acid,
    valid_ingredients.is_heat as valid_ingredient_is_heat,
	valid_ingredients.created_at as valid_ingredient_created_at,
	valid_ingredients.last_updated_at as valid_ingredient_last_updated_at,
	valid_ingredients.archived_at as valid_ingredient_archived_at,
	valid_ingredient_state_ingredients.created_at as valid_ingredient_state_ingredient_created_at,
	valid_ingredient_state_ingredients.last_updated_at as valid_ingredient_state_ingredient_last_updated_at,
	valid_ingredient_state_ingredients.archived_at as valid_ingredient_state_ingredient_archived_at,
    (
        SELECT
            COUNT(valid_ingredient_state_ingredients.id)
        FROM
            valid_ingredient_state_ingredients
        WHERE
            valid_ingredient_state_ingredients.archived_at IS NULL
          AND valid_ingredient_state_ingredients.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_state_ingredients.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (valid_ingredient_state_ingredients.last_updated_at IS NULL OR valid_ingredient_state_ingredients.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
          AND (valid_ingredient_state_ingredients.last_updated_at IS NULL OR valid_ingredient_state_ingredients.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_state_ingredients.id)
        FROM
            valid_ingredient_state_ingredients
        WHERE
            valid_ingredient_state_ingredients.archived_at IS NULL
    ) as total_count
FROM valid_ingredient_state_ingredients
	JOIN valid_ingredients ON valid_ingredient_state_ingredients.valid_ingredient = valid_ingredients.id
	JOIN valid_ingredient_states ON valid_ingredient_state_ingredients.valid_ingredient_state = valid_ingredient_states.id
WHERE valid_ingredient_state_ingredients.archived_at IS NULL
  AND valid_ingredient_state_ingredients.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
  AND valid_ingredient_state_ingredients.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
  AND (valid_ingredient_state_ingredients.last_updated_at IS NULL OR valid_ingredient_state_ingredients.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
  AND (valid_ingredient_state_ingredients.last_updated_at IS NULL OR valid_ingredient_state_ingredients.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
OFFSET $5
LIMIT $6
`

type GetValidIngredientStateIngredientsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientStateIngredientsRow struct {
	ValidIngredientStateCreatedAt                          time.Time
	ValidIngredientCreatedAt                               time.Time
	ValidIngredientStateIngredientCreatedAt                time.Time
	ValidIngredientStateIngredientArchivedAt               sql.NullTime
	ValidIngredientStateLastUpdatedAt                      sql.NullTime
	ValidIngredientStateArchivedAt                         sql.NullTime
	ValidIngredientLastUpdatedAt                           sql.NullTime
	ValidIngredientArchivedAt                              sql.NullTime
	ValidIngredientStateIngredientLastUpdatedAt            sql.NullTime
	ValidIngredientStateIconPath                           string
	ValidIngredientStateSlug                               string
	ValidIngredientStateAttributeType                      IngredientAttributeType
	ValidIngredientID                                      string
	ValidIngredientName                                    string
	ValidIngredientDescription                             string
	ValidIngredientWarning                                 string
	ValidIngredientIconPath                                string
	ValidIngredientPluralName                              string
	ValidIngredientStorageInstructions                     string
	ValidIngredientSlug                                    string
	ValidIngredientStatePastTense                          string
	ValidIngredientShoppingSuggestions                     string
	ValidIngredientStateDescription                        string
	ValidIngredientStateName                               string
	ValidIngredientStateID                                 string
	ValidIngredientStateIngredientNotes                    string
	ValidIngredientStateIngredientID                       string
	ValidIngredientMinimumIdealStorageTemperatureInCelsius sql.NullString
	ValidIngredientMaximumIdealStorageTemperatureInCelsius sql.NullString
	FilteredCount                                          int64
	TotalCount                                             int64
	ValidIngredientIsLiquid                                sql.NullBool
	ValidIngredientContainsFish                            bool
	ValidIngredientRestrictToPreparations                  bool
	ValidIngredientAnimalDerived                           bool
	ValidIngredientVolumetric                              bool
	ValidIngredientAnimalFlesh                             bool
	ValidIngredientContainsAlcohol                         bool
	ValidIngredientContainsGluten                          bool
	ValidIngredientIsStarch                                bool
	ValidIngredientIsProtein                               bool
	ValidIngredientIsGrain                                 bool
	ValidIngredientIsFruit                                 bool
	ValidIngredientIsSalt                                  bool
	ValidIngredientIsFat                                   bool
	ValidIngredientIsAcid                                  bool
	ValidIngredientIsHeat                                  bool
	ValidIngredientContainsSesame                          bool
	ValidIngredientContainsShellfish                       bool
	ValidIngredientContainsWheat                           bool
	ValidIngredientContainsSoy                             bool
	ValidIngredientContainsTreeNut                         bool
	ValidIngredientContainsPeanut                          bool
	ValidIngredientContainsDairy                           bool
	ValidIngredientContainsEgg                             bool
}

func (q *Queries) GetValidIngredientStateIngredients(ctx context.Context, db DBTX, arg *GetValidIngredientStateIngredientsParams) ([]*GetValidIngredientStateIngredientsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientStateIngredients,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientStateIngredientsRow{}
	for rows.Next() {
		var i GetValidIngredientStateIngredientsRow
		if err := rows.Scan(
			&i.ValidIngredientStateIngredientID,
			&i.ValidIngredientStateIngredientNotes,
			&i.ValidIngredientStateID,
			&i.ValidIngredientStateName,
			&i.ValidIngredientStateDescription,
			&i.ValidIngredientStateIconPath,
			&i.ValidIngredientStateSlug,
			&i.ValidIngredientStatePastTense,
			&i.ValidIngredientStateAttributeType,
			&i.ValidIngredientStateCreatedAt,
			&i.ValidIngredientStateLastUpdatedAt,
			&i.ValidIngredientStateArchivedAt,
			&i.ValidIngredientID,
			&i.ValidIngredientName,
			&i.ValidIngredientDescription,
			&i.ValidIngredientWarning,
			&i.ValidIngredientContainsEgg,
			&i.ValidIngredientContainsDairy,
			&i.ValidIngredientContainsPeanut,
			&i.ValidIngredientContainsTreeNut,
			&i.ValidIngredientContainsSoy,
			&i.ValidIngredientContainsWheat,
			&i.ValidIngredientContainsShellfish,
			&i.ValidIngredientContainsSesame,
			&i.ValidIngredientContainsFish,
			&i.ValidIngredientContainsGluten,
			&i.ValidIngredientAnimalFlesh,
			&i.ValidIngredientVolumetric,
			&i.ValidIngredientIsLiquid,
			&i.ValidIngredientIconPath,
			&i.ValidIngredientAnimalDerived,
			&i.ValidIngredientPluralName,
			&i.ValidIngredientRestrictToPreparations,
			&i.ValidIngredientMinimumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientMaximumIdealStorageTemperatureInCelsius,
			&i.ValidIngredientStorageInstructions,
			&i.ValidIngredientSlug,
			&i.ValidIngredientContainsAlcohol,
			&i.ValidIngredientShoppingSuggestions,
			&i.ValidIngredientIsStarch,
			&i.ValidIngredientIsProtein,
			&i.ValidIngredientIsGrain,
			&i.ValidIngredientIsFruit,
			&i.ValidIngredientIsSalt,
			&i.ValidIngredientIsFat,
			&i.ValidIngredientIsAcid,
			&i.ValidIngredientIsHeat,
			&i.ValidIngredientCreatedAt,
			&i.ValidIngredientLastUpdatedAt,
			&i.ValidIngredientArchivedAt,
			&i.ValidIngredientStateIngredientCreatedAt,
			&i.ValidIngredientStateIngredientLastUpdatedAt,
			&i.ValidIngredientStateIngredientArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientStates = `-- name: GetValidIngredientStates :many

SELECT
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
    (
        SELECT COUNT(valid_ingredient_states.id)
        FROM valid_ingredient_states
        WHERE valid_ingredient_states.archived_at IS NULL
        AND valid_ingredient_states.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
        AND valid_ingredient_states.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
        AND (valid_ingredient_states.last_updated_at IS NULL OR valid_ingredient_states.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
        AND (valid_ingredient_states.last_updated_at IS NULL OR valid_ingredient_states.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_states.id)
        FROM
            valid_ingredient_states
        WHERE
            valid_ingredient_states.archived_at IS NULL
    ) as total_count
FROM valid_ingredient_states
WHERE valid_ingredient_states.archived_at IS NULL
    AND valid_ingredient_states.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
    AND valid_ingredient_states.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
    AND (valid_ingredient_states.last_updated_at IS NULL OR valid_ingredient_states.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
    AND (valid_ingredient_states.last_updated_at IS NULL OR valid_ingredient_states.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
LIMIT $6
OFFSET $5
`

type GetValidIngredientStatesParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientStatesRow struct {
	ID            string
	Name          string
	Description   string
	IconPath      string
	Slug          string
	PastTense     string
	AttributeType IngredientAttributeType
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetValidIngredientStates(ctx context.Context, db DBTX, arg *GetValidIngredientStatesParams) ([]*GetValidIngredientStatesRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientStates,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientStatesRow{}
	for rows.Next() {
		var i GetValidIngredientStatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.Slug,
			&i.PastTense,
			&i.AttributeType,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredients = `-- name: GetValidIngredients :many

SELECT
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at,
    (
        SELECT
            COUNT(valid_ingredients.id)
        FROM
            valid_ingredients
        WHERE
            valid_ingredients.archived_at IS NULL
          AND valid_ingredients.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_ingredients.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (valid_ingredients.last_updated_at IS NULL OR valid_ingredients.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
          AND (valid_ingredients.last_updated_at IS NULL OR valid_ingredients.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_ingredients.id)
        FROM
            valid_ingredients
        WHERE
            valid_ingredients.archived_at IS NULL
    ) as total_count
FROM
  valid_ingredients
WHERE
  valid_ingredients.archived_at IS NULL
  AND valid_ingredients.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
  AND valid_ingredients.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
  AND (valid_ingredients.last_updated_at IS NULL OR valid_ingredients.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
  AND (valid_ingredients.last_updated_at IS NULL OR valid_ingredients.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
  valid_ingredients.id
ORDER BY
  valid_ingredients.id
LIMIT $6
OFFSET $5
`

type GetValidIngredientsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidIngredientsRow struct {
	CreatedAt                               time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	IconPath                                string
	Name                                    string
	Description                             string
	Warning                                 string
	PluralName                              string
	ID                                      string
	ShoppingSuggestions                     string
	Slug                                    string
	StorageInstructions                     string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	FilteredCount                           int64
	TotalCount                              int64
	IsLiquid                                sql.NullBool
	RestrictToPreparations                  bool
	IsProtein                               bool
	Volumetric                              bool
	AnimalFlesh                             bool
	ContainsGluten                          bool
	ContainsFish                            bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsAlcohol                         bool
	ContainsWheat                           bool
	IsStarch                                bool
	AnimalDerived                           bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredients(ctx context.Context, db DBTX, arg *GetValidIngredientsParams) ([]*GetValidIngredientsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredients,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientsRow{}
	for rows.Next() {
		var i GetValidIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidInstruments = `-- name: GetValidInstruments :many

SELECT
    valid_instruments.id,
    valid_instruments.name,
    valid_instruments.plural_name,
    valid_instruments.description,
    valid_instruments.icon_path,
    valid_instruments.usable_for_storage,
    valid_instruments.display_in_summary_lists,
    valid_instruments.include_in_generated_instructions,
    valid_instruments.slug,
    valid_instruments.created_at,
    valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	 AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	) as total_count
FROM
	valid_instruments
WHERE
	valid_instruments.archived_at IS NULL
	AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	valid_instruments.id
ORDER BY
	valid_instruments.id
    OFFSET $5
	LIMIT $6
`

type GetValidInstrumentsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidInstrumentsRow struct {
	CreatedAt                      time.Time
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	Description                    string
	IconPath                       string
	Slug                           string
	ID                             string
	PluralName                     string
	Name                           string
	FilteredCount                  int64
	TotalCount                     int64
	UsableForStorage               bool
	DisplayInSummaryLists          bool
	IncludeInGeneratedInstructions bool
}

func (q *Queries) GetValidInstruments(ctx context.Context, db DBTX, arg *GetValidInstrumentsParams) ([]*GetValidInstrumentsRow, error) {
	rows, err := db.QueryContext(ctx, getValidInstruments,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidInstrumentsRow{}
	for rows.Next() {
		var i GetValidInstrumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidMeasurementUnits = `-- name: GetValidMeasurementUnits :many

SELECT
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.universal,
    valid_measurement_units.metric,
    valid_measurement_units.imperial,
    valid_measurement_units.slug,
    valid_measurement_units.plural_name,
    valid_measurement_units.created_at,
    valid_measurement_units.last_updated_at,
    valid_measurement_units.archived_at,
    (
        SELECT
            COUNT(valid_measurement_units.id)
        FROM
            valid_measurement_units
        WHERE
            valid_measurement_units.archived_at IS NULL
            AND valid_measurement_units.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
            AND valid_measurement_units.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
            AND (
                valid_measurement_units.last_updated_at IS NULL
                OR valid_measurement_units.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
            AND (
                valid_measurement_units.last_updated_at IS NULL
                OR valid_measurement_units.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_measurement_units.id)
        FROM
            valid_measurement_units
        WHERE
            valid_measurement_units.archived_at IS NULL
    ) as total_count
FROM
    valid_measurement_units
WHERE
    valid_measurement_units.archived_at IS NULL
    AND valid_measurement_units.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
    AND valid_measurement_units.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
    AND (
        valid_measurement_units.last_updated_at IS NULL
        OR valid_measurement_units.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
    )
    AND (
        valid_measurement_units.last_updated_at IS NULL
        OR valid_measurement_units.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
    )
GROUP BY
    valid_measurement_units.id
ORDER BY
    valid_measurement_units.id
OFFSET $5
LIMIT $6
`

type GetValidMeasurementUnitsParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidMeasurementUnitsRow struct {
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	Name          string
	Description   string
	ID            string
	IconPath      string
	Slug          string
	PluralName    string
	TotalCount    int64
	FilteredCount int64
	Volumetric    sql.NullBool
	Imperial      bool
	Metric        bool
	Universal     bool
}

func (q *Queries) GetValidMeasurementUnits(ctx context.Context, db DBTX, arg *GetValidMeasurementUnitsParams) ([]*GetValidMeasurementUnitsRow, error) {
	rows, err := db.QueryContext(ctx, getValidMeasurementUnits,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidMeasurementUnitsRow{}
	for rows.Next() {
		var i GetValidMeasurementUnitsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.Universal,
			&i.Metric,
			&i.Imperial,
			&i.Slug,
			&i.PluralName,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidPreparationInstruments = `-- name: GetValidPreparationInstruments :many

SELECT
    valid_preparation_instruments.id as valid_preparation_instrument_id,
    valid_preparation_instruments.notes as valid_preparation_instrument_notes,
    valid_preparations.id as valid_preparation_id,
    valid_preparations.name as valid_preparation_name,
    valid_preparations.description as valid_preparation_description,
    valid_preparations.icon_path as valid_preparation_icon_path,
    valid_preparations.yields_nothing as valid_preparation_yields_nothing,
    valid_preparations.restrict_to_ingredients as valid_preparation_restrict_to_ingredients,
    valid_preparations.minimum_ingredient_count as valid_preparation_minimum_ingredient_count,
    valid_preparations.maximum_ingredient_count as valid_preparation_maximum_ingredient_count,
    valid_preparations.minimum_instrument_count as valid_preparation_minimum_instrument_count,
    valid_preparations.maximum_instrument_count as valid_preparation_maximum_instrument_count,
    valid_preparations.temperature_required as valid_preparation_temperature_required,
    valid_preparations.time_estimate_required as valid_preparation_time_estimate_required,
    valid_preparations.condition_expression_required as valid_preparation_condition_expression_required,
    valid_preparations.consumes_vessel as valid_preparation_consumes_vessel,
    valid_preparations.only_for_vessels as valid_preparation_only_for_vessels,
    valid_preparations.minimum_vessel_count as valid_preparation_minimum_vessel_count,
    valid_preparations.maximum_vessel_count as valid_preparation_maximum_vessel_count,
    valid_preparations.slug as valid_preparation_slug,
    valid_preparations.past_tense as valid_preparation_past_tense,
    valid_preparations.created_at as valid_preparation_created_at,
    valid_preparations.last_updated_at as valid_preparation_last_updated_at,
    valid_preparations.archived_at as valid_preparation_archived_at,
    valid_instruments.id as valid_instrument_id,
    valid_instruments.name as valid_instrument_name,
    valid_instruments.plural_name as valid_instrument_plural_name,
    valid_instruments.description as valid_instrument_description,
    valid_instruments.icon_path as valid_instrument_icon_path,
    valid_instruments.usable_for_storage as valid_instrument_usable_for_storage,
    valid_instruments.display_in_summary_lists as valid_instrument_display_in_summary_lists,
    valid_instruments.include_in_generated_instructions as valid_instrument_include_in_generated_instructions,
    valid_instruments.slug as valid_instrument_slug,
    valid_instruments.created_at as valid_instrument_created_at,
    valid_instruments.last_updated_at as valid_instrument_last_updated_at,
    valid_instruments.archived_at as valid_instrument_archived_at,
    valid_preparation_instruments.created_at as valid_preparation_instrument_created_at,
    valid_preparation_instruments.last_updated_at as valid_preparation_instrument_last_updated_at,
    valid_preparation_instruments.archived_at as valid_preparation_instrument_archived_at,
    (
        SELECT
            COUNT(valid_preparation_instruments.id)
        FROM
            valid_preparation_instruments
                JOIN valid_instruments ON valid_preparation_instruments.valid_instrument_id = valid_instruments.id
                JOIN valid_preparations ON valid_preparation_instruments.valid_preparation_id = valid_preparations.id
        WHERE
            valid_preparation_instruments.archived_at IS NULL
            AND valid_instruments.archived_at IS NULL
            AND valid_preparations.archived_at IS NULL
            AND valid_preparation_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
            AND valid_preparation_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
            AND (
                valid_preparation_instruments.last_updated_at IS NULL
                OR valid_preparation_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
            AND (
                valid_preparation_instruments.last_updated_at IS NULL
                OR valid_preparation_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_preparation_instruments.id)
        FROM
            valid_preparation_instruments
                JOIN valid_instruments ON valid_preparation_instruments.valid_instrument_id = valid_instruments.id
                JOIN valid_preparations ON valid_preparation_instruments.valid_preparation_id = valid_preparations.id
        WHERE
            valid_preparation_instruments.archived_at IS NULL
            AND valid_instruments.archived_at IS NULL
            AND valid_preparations.archived_at IS NULL
    ) as total_count
FROM
    valid_preparation_instruments
    JOIN valid_instruments ON valid_preparation_instruments.valid_instrument_id = valid_instruments.id
    JOIN valid_preparations ON valid_preparation_instruments.valid_preparation_id = valid_preparations.id
WHERE
    valid_preparation_instruments.archived_at IS NULL
    AND valid_instruments.archived_at IS NULL
    AND valid_preparations.archived_at IS NULL
    AND valid_preparation_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
    AND valid_preparation_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
    AND (
        valid_preparation_instruments.last_updated_at IS NULL
        OR valid_preparation_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
    )
    AND (
        valid_preparation_instruments.last_updated_at IS NULL
        OR valid_preparation_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
    )
GROUP BY
    valid_preparation_instruments.id,
    valid_preparations.id,
    valid_instruments.id
ORDER BY
    valid_preparation_instruments.id
    LIMIT $6
    OFFSET $5
`

type GetValidPreparationInstrumentsParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidPreparationInstrumentsRow struct {
	ValidPreparationInstrumentCreatedAt           time.Time
	ValidPreparationCreatedAt                     time.Time
	ValidInstrumentCreatedAt                      time.Time
	ValidInstrumentArchivedAt                     sql.NullTime
	ValidPreparationInstrumentLastUpdatedAt       sql.NullTime
	ValidPreparationArchivedAt                    sql.NullTime
	ValidPreparationLastUpdatedAt                 sql.NullTime
	ValidInstrumentLastUpdatedAt                  sql.NullTime
	ValidPreparationInstrumentArchivedAt          sql.NullTime
	ValidPreparationInstrumentID                  string
	ValidPreparationID                            string
	ValidInstrumentDescription                    string
	ValidInstrumentPluralName                     string
	ValidPreparationName                          string
	ValidInstrumentIconPath                       string
	ValidInstrumentName                           string
	ValidPreparationIconPath                      string
	ValidInstrumentSlug                           string
	ValidInstrumentID                             string
	ValidPreparationSlug                          string
	ValidPreparationPastTense                     string
	ValidPreparationInstrumentNotes               string
	ValidPreparationDescription                   string
	TotalCount                                    int64
	FilteredCount                                 int64
	ValidPreparationMaximumVesselCount            sql.NullInt32
	ValidPreparationMaximumIngredientCount        sql.NullInt32
	ValidPreparationMaximumInstrumentCount        sql.NullInt32
	ValidPreparationMinimumInstrumentCount        int32
	ValidPreparationMinimumVesselCount            int32
	ValidPreparationMinimumIngredientCount        int32
	ValidInstrumentUsableForStorage               bool
	ValidInstrumentDisplayInSummaryLists          bool
	ValidInstrumentIncludeInGeneratedInstructions bool
	ValidPreparationOnlyForVessels                bool
	ValidPreparationConsumesVessel                bool
	ValidPreparationConditionExpressionRequired   bool
	ValidPreparationTimeEstimateRequired          bool
	ValidPreparationTemperatureRequired           bool
	ValidPreparationRestrictToIngredients         bool
	ValidPreparationYieldsNothing                 bool
}

func (q *Queries) GetValidPreparationInstruments(ctx context.Context, db DBTX, arg *GetValidPreparationInstrumentsParams) ([]*GetValidPreparationInstrumentsRow, error) {
	rows, err := db.QueryContext(ctx, getValidPreparationInstruments,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidPreparationInstrumentsRow{}
	for rows.Next() {
		var i GetValidPreparationInstrumentsRow
		if err := rows.Scan(
			&i.ValidPreparationInstrumentID,
			&i.ValidPreparationInstrumentNotes,
			&i.ValidPreparationID,
			&i.ValidPreparationName,
			&i.ValidPreparationDescription,
			&i.ValidPreparationIconPath,
			&i.ValidPreparationYieldsNothing,
			&i.ValidPreparationRestrictToIngredients,
			&i.ValidPreparationMinimumIngredientCount,
			&i.ValidPreparationMaximumIngredientCount,
			&i.ValidPreparationMinimumInstrumentCount,
			&i.ValidPreparationMaximumInstrumentCount,
			&i.ValidPreparationTemperatureRequired,
			&i.ValidPreparationTimeEstimateRequired,
			&i.ValidPreparationConditionExpressionRequired,
			&i.ValidPreparationConsumesVessel,
			&i.ValidPreparationOnlyForVessels,
			&i.ValidPreparationMinimumVesselCount,
			&i.ValidPreparationMaximumVesselCount,
			&i.ValidPreparationSlug,
			&i.ValidPreparationPastTense,
			&i.ValidPreparationCreatedAt,
			&i.ValidPreparationLastUpdatedAt,
			&i.ValidPreparationArchivedAt,
			&i.ValidInstrumentID,
			&i.ValidInstrumentName,
			&i.ValidInstrumentPluralName,
			&i.ValidInstrumentDescription,
			&i.ValidInstrumentIconPath,
			&i.ValidInstrumentUsableForStorage,
			&i.ValidInstrumentDisplayInSummaryLists,
			&i.ValidInstrumentIncludeInGeneratedInstructions,
			&i.ValidInstrumentSlug,
			&i.ValidInstrumentCreatedAt,
			&i.ValidInstrumentLastUpdatedAt,
			&i.ValidInstrumentArchivedAt,
			&i.ValidPreparationInstrumentCreatedAt,
			&i.ValidPreparationInstrumentLastUpdatedAt,
			&i.ValidPreparationInstrumentArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidPreparationVessels = `-- name: GetValidPreparationVessels :many

SELECT
	valid_preparation_vessels.id as valid_preparation_vessel_id,
	valid_preparation_vessels.notes as valid_preparation_vessel_notes,
	valid_preparations.id as valid_preparation_id,
	valid_preparations.name as valid_preparation_name,
	valid_preparations.description as valid_preparation_description,
	valid_preparations.icon_path as valid_preparation_icon_path,
	valid_preparations.yields_nothing as valid_preparation_yields_nothing,
	valid_preparations.restrict_to_ingredients as valid_preparation_restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count as valid_preparation_minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count as valid_preparation_maximum_ingredient_count,
	valid_preparations.minimum_instrument_count as valid_preparation_minimum_instrument_count,
	valid_preparations.maximum_instrument_count as valid_preparation_maximum_instrument_count,
	valid_preparations.temperature_required as valid_preparation_temperature_required,
	valid_preparations.time_estimate_required as valid_preparation_time_estimate_required,
	valid_preparations.condition_expression_required as valid_preparation_condition_expression_required,
	valid_preparations.consumes_vessel as valid_preparation_consumes_vessel,
	valid_preparations.only_for_vessels as valid_preparation_only_for_vessels,
	valid_preparations.minimum_vessel_count as valid_preparation_minimum_vessel_count,
	valid_preparations.maximum_vessel_count as valid_preparation_maximum_vessel_count,
	valid_preparations.slug as valid_preparation_slug,
	valid_preparations.past_tense as valid_preparation_past_tense,
	valid_preparations.created_at as valid_preparation_created_at,
	valid_preparations.last_updated_at as valid_preparation_last_updated_at,
	valid_preparations.archived_at as valid_preparation_archived_at,
	valid_vessels.id as valid_vessel_id,
	valid_vessels.name as valid_vessel_name,
	valid_vessels.plural_name as valid_vessel_plural_name,
	valid_vessels.description as valid_vessel_description,
	valid_vessels.icon_path as valid_vessel_icon_path,
	valid_vessels.usable_for_storage as valid_vessel_usable_for_storage,
	valid_vessels.slug as valid_vessel_slug,
	valid_vessels.display_in_summary_lists as valid_vessel_display_in_summary_lists,
	valid_vessels.include_in_generated_instructions as valid_vessel_include_in_generated_instructions,
	valid_vessels.capacity::float as valid_vessel_capacity,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	valid_vessels.width_in_millimeters::float as valid_vessel_width_in_millimeters,
	valid_vessels.length_in_millimeters::float as valid_vessel_length_in_millimeters,
	valid_vessels.height_in_millimeters::float as valid_vessel_height_in_millimeters,
	valid_vessels.shape as valid_vessel_shape,
	valid_vessels.created_at as valid_vessel_created_at,
	valid_vessels.last_updated_at as valid_vessel_last_updated_at,
	valid_vessels.archived_at as valid_vessel_archived_at,
	valid_preparation_vessels.created_at as valid_preparation_vessel_created_at,
	valid_preparation_vessels.last_updated_at as valid_preparation_vessel_last_updated_at,
	valid_preparation_vessels.archived_at as valid_preparation_vessel_archived_at,
	(
		SELECT
			COUNT(valid_preparation_vessels.id)
		FROM
			valid_preparation_vessels
		WHERE
            valid_preparation_vessels.archived_at IS NULL
            AND valid_preparation_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
            AND valid_preparation_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
            AND (
                valid_preparation_vessels.last_updated_at IS NULL
                OR valid_preparation_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
            AND (
                valid_preparation_vessels.last_updated_at IS NULL
                OR valid_preparation_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
	) as filtered_count,
	(
		SELECT
			COUNT(valid_preparation_vessels.id)
		FROM
			valid_preparation_vessels
		WHERE
			valid_preparation_vessels.archived_at IS NULL
	) as total_count
FROM
	valid_preparation_vessels
		JOIN valid_vessels ON valid_preparation_vessels.valid_vessel_id = valid_vessels.id
		JOIN valid_preparations ON valid_preparation_vessels.valid_preparation_id = valid_preparations.id
		LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit = valid_measurement_units.id
WHERE
	valid_preparation_vessels.archived_at IS NULL
    AND valid_vessels.archived_at IS NULL
    AND valid_preparations.archived_at IS NULL
    AND valid_measurement_units.archived_at IS NULL
    AND valid_preparation_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
    AND valid_preparation_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
    AND (
        valid_preparation_vessels.last_updated_at IS NULL
        OR valid_preparation_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
    )
    AND (
        valid_preparation_vessels.last_updated_at IS NULL
        OR valid_preparation_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
    )
GROUP BY
	valid_preparation_vessels.id,
	valid_preparations.id,
	valid_vessels.id,
	valid_measurement_units.id
ORDER BY
	valid_preparation_vessels.id
OFFSET $5
LIMIT $6
`

type GetValidPreparationVesselsParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidPreparationVesselsRow struct {
	ValidPreparationCreatedAt                   time.Time
	ValidPreparationVesselCreatedAt             time.Time
	ValidVesselCreatedAt                        time.Time
	ValidMeasurementUnitArchivedAt              sql.NullTime
	ValidPreparationArchivedAt                  sql.NullTime
	ValidPreparationLastUpdatedAt               sql.NullTime
	ValidMeasurementUnitCreatedAt               sql.NullTime
	ValidMeasurementUnitLastUpdatedAt           sql.NullTime
	ValidPreparationVesselArchivedAt            sql.NullTime
	ValidPreparationVesselLastUpdatedAt         sql.NullTime
	ValidVesselArchivedAt                       sql.NullTime
	ValidVesselLastUpdatedAt                    sql.NullTime
	ValidVesselShape                            VesselShape
	ValidPreparationSlug                        string
	ValidPreparationIconPath                    string
	ValidPreparationDescription                 string
	ValidPreparationVesselID                    string
	ValidVesselSlug                             string
	ValidVesselIconPath                         string
	ValidVesselDescription                      string
	ValidPreparationPastTense                   string
	ValidPreparationName                        string
	ValidPreparationID                          string
	ValidPreparationVesselNotes                 string
	ValidVesselID                               string
	ValidVesselName                             string
	ValidVesselPluralName                       string
	ValidMeasurementUnitPluralName              sql.NullString
	ValidMeasurementUnitSlug                    sql.NullString
	ValidMeasurementUnitIconPath                sql.NullString
	ValidMeasurementUnitDescription             sql.NullString
	ValidMeasurementUnitName                    sql.NullString
	ValidMeasurementUnitID                      sql.NullString
	ValidVesselWidthInMillimeters               float64
	TotalCount                                  int64
	FilteredCount                               int64
	ValidVesselCapacity                         float64
	ValidVesselHeightInMillimeters              float64
	ValidVesselLengthInMillimeters              float64
	ValidPreparationMaximumIngredientCount      sql.NullInt32
	ValidPreparationMaximumInstrumentCount      sql.NullInt32
	ValidPreparationMaximumVesselCount          sql.NullInt32
	ValidPreparationMinimumVesselCount          int32
	ValidPreparationMinimumIngredientCount      int32
	ValidPreparationMinimumInstrumentCount      int32
	ValidMeasurementUnitUniversal               sql.NullBool
	ValidMeasurementUnitImperial                sql.NullBool
	ValidMeasurementUnitVolumetric              sql.NullBool
	ValidMeasurementUnitMetric                  sql.NullBool
	ValidPreparationOnlyForVessels              bool
	ValidPreparationTemperatureRequired         bool
	ValidPreparationTimeEstimateRequired        bool
	ValidPreparationConsumesVessel              bool
	ValidVesselUsableForStorage                 bool
	ValidPreparationConditionExpressionRequired bool
	ValidPreparationRestrictToIngredients       bool
	ValidPreparationYieldsNothing               bool
	ValidVesselDisplayInSummaryLists            bool
	ValidVesselIncludeInGeneratedInstructions   bool
}

func (q *Queries) GetValidPreparationVessels(ctx context.Context, db DBTX, arg *GetValidPreparationVesselsParams) ([]*GetValidPreparationVesselsRow, error) {
	rows, err := db.QueryContext(ctx, getValidPreparationVessels,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidPreparationVesselsRow{}
	for rows.Next() {
		var i GetValidPreparationVesselsRow
		if err := rows.Scan(
			&i.ValidPreparationVesselID,
			&i.ValidPreparationVesselNotes,
			&i.ValidPreparationID,
			&i.ValidPreparationName,
			&i.ValidPreparationDescription,
			&i.ValidPreparationIconPath,
			&i.ValidPreparationYieldsNothing,
			&i.ValidPreparationRestrictToIngredients,
			&i.ValidPreparationMinimumIngredientCount,
			&i.ValidPreparationMaximumIngredientCount,
			&i.ValidPreparationMinimumInstrumentCount,
			&i.ValidPreparationMaximumInstrumentCount,
			&i.ValidPreparationTemperatureRequired,
			&i.ValidPreparationTimeEstimateRequired,
			&i.ValidPreparationConditionExpressionRequired,
			&i.ValidPreparationConsumesVessel,
			&i.ValidPreparationOnlyForVessels,
			&i.ValidPreparationMinimumVesselCount,
			&i.ValidPreparationMaximumVesselCount,
			&i.ValidPreparationSlug,
			&i.ValidPreparationPastTense,
			&i.ValidPreparationCreatedAt,
			&i.ValidPreparationLastUpdatedAt,
			&i.ValidPreparationArchivedAt,
			&i.ValidVesselID,
			&i.ValidVesselName,
			&i.ValidVesselPluralName,
			&i.ValidVesselDescription,
			&i.ValidVesselIconPath,
			&i.ValidVesselUsableForStorage,
			&i.ValidVesselSlug,
			&i.ValidVesselDisplayInSummaryLists,
			&i.ValidVesselIncludeInGeneratedInstructions,
			&i.ValidVesselCapacity,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.ValidVesselWidthInMillimeters,
			&i.ValidVesselLengthInMillimeters,
			&i.ValidVesselHeightInMillimeters,
			&i.ValidVesselShape,
			&i.ValidVesselCreatedAt,
			&i.ValidVesselLastUpdatedAt,
			&i.ValidVesselArchivedAt,
			&i.ValidPreparationVesselCreatedAt,
			&i.ValidPreparationVesselLastUpdatedAt,
			&i.ValidPreparationVesselArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidPreparations = `-- name: GetValidPreparations :many

SELECT
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
    valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at,
    (
        SELECT
            COUNT(valid_preparations.id)
        FROM
            valid_preparations
        WHERE
            valid_preparations.archived_at IS NULL
          AND valid_preparations.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
          AND valid_preparations.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
          AND (
                valid_preparations.last_updated_at IS NULL
                OR valid_preparations.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
            )
          AND (
                valid_preparations.last_updated_at IS NULL
                OR valid_preparations.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
            )
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_preparations.id)
        FROM
            valid_preparations
        WHERE
            valid_preparations.archived_at IS NULL
    ) as total_count
FROM valid_preparations
WHERE
    valid_preparations.archived_at IS NULL
  AND valid_preparations.created_at > (COALESCE($1, (SELECT NOW() - interval '999 years')))
  AND valid_preparations.created_at < (COALESCE($2, (SELECT NOW() + interval '999 years')))
  AND (
        valid_preparations.last_updated_at IS NULL
        OR valid_preparations.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
    )
  AND (
        valid_preparations.last_updated_at IS NULL
        OR valid_preparations.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
    )
GROUP BY
    valid_preparations.id
ORDER BY
    valid_preparations.id
OFFSET
    $5
    LIMIT
    $6
`

type GetValidPreparationsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidPreparationsRow struct {
	CreatedAt                   time.Time
	ArchivedAt                  sql.NullTime
	LastUpdatedAt               sql.NullTime
	ID                          string
	IconPath                    string
	Description                 string
	Name                        string
	PastTense                   string
	Slug                        string
	TotalCount                  int64
	FilteredCount               int64
	MaximumVesselCount          sql.NullInt32
	MaximumIngredientCount      sql.NullInt32
	MaximumInstrumentCount      sql.NullInt32
	MinimumIngredientCount      int32
	MinimumVesselCount          int32
	MinimumInstrumentCount      int32
	OnlyForVessels              bool
	ConsumesVessel              bool
	ConditionExpressionRequired bool
	TimeEstimateRequired        bool
	TemperatureRequired         bool
	RestrictToIngredients       bool
	YieldsNothing               bool
}

func (q *Queries) GetValidPreparations(ctx context.Context, db DBTX, arg *GetValidPreparationsParams) ([]*GetValidPreparationsRow, error) {
	rows, err := db.QueryContext(ctx, getValidPreparations,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidPreparationsRow{}
	for rows.Next() {
		var i GetValidPreparationsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.YieldsNothing,
			&i.RestrictToIngredients,
			&i.MinimumIngredientCount,
			&i.MaximumIngredientCount,
			&i.MinimumInstrumentCount,
			&i.MaximumInstrumentCount,
			&i.TemperatureRequired,
			&i.TimeEstimateRequired,
			&i.ConditionExpressionRequired,
			&i.ConsumesVessel,
			&i.OnlyForVessels,
			&i.MinimumVesselCount,
			&i.MaximumVesselCount,
			&i.Slug,
			&i.PastTense,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVessels = `-- name: GetValidVessels :many

SELECT
  valid_vessels.id,
  valid_vessels.name,
  valid_vessels.plural_name,
  valid_vessels.description,
  valid_vessels.icon_path,
  valid_vessels.usable_for_storage,
  valid_vessels.slug,
  valid_vessels.display_in_summary_lists,
  valid_vessels.include_in_generated_instructions,
  valid_vessels.capacity::float,
  valid_vessels.capacity_unit,
  valid_vessels.width_in_millimeters::float,
  valid_vessels.length_in_millimeters::float,
  valid_vessels.height_in_millimeters::float,
  valid_vessels.shape,
  valid_vessels.created_at,
  valid_vessels.last_updated_at,
  valid_vessels.archived_at,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
      AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
      AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
      )
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
  ) as total_count
FROM
  valid_vessels
WHERE
  valid_vessels.archived_at IS NULL
  AND valid_vessels.created_at > (COALESCE($1, (SELECT NOW() - interval '999 years')))
  AND valid_vessels.created_at < (COALESCE($2, (SELECT NOW() + interval '999 years')))
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
  )
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  valid_vessels.id
ORDER BY
  valid_vessels.id
OFFSET
    $5
LIMIT
    $6
`

type GetValidVesselsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidVesselsRow struct {
	CreatedAt                       time.Time
	ArchivedAt                      sql.NullTime
	LastUpdatedAt                   sql.NullTime
	ID                              string
	Name                            string
	PluralName                      string
	Description                     string
	IconPath                        string
	Slug                            string
	Shape                           VesselShape
	CapacityUnit                    sql.NullString
	ValidVesselsWidthInMillimeters  float64
	ValidVesselsLengthInMillimeters float64
	ValidVesselsHeightInMillimeters float64
	ValidVesselsCapacity            float64
	FilteredCount                   int64
	TotalCount                      int64
	IncludeInGeneratedInstructions  bool
	DisplayInSummaryLists           bool
	UsableForStorage                bool
}

func (q *Queries) GetValidVessels(ctx context.Context, db DBTX, arg *GetValidVesselsParams) ([]*GetValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVessels,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsRow{}
	for rows.Next() {
		var i GetValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.ValidVesselsCapacity,
			&i.CapacityUnit,
			&i.ValidVesselsWidthInMillimeters,
			&i.ValidVesselsLengthInMillimeters,
			&i.ValidVesselsHeightInMillimeters,
			&i.Shape,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhooks = `-- name: GetWebhooks :many

SELECT
	webhooks.id,
	webhooks.name,
	webhooks.content_type,
	webhooks.url,
	webhooks.method,
	webhooks.created_at,
	webhooks.last_updated_at,
	webhooks.archived_at,
	webhooks.belongs_to_household,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
	      AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	        )
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	        )
          AND webhooks.belongs_to_household = $5
	) as filtered_count,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
            AND webhooks.belongs_to_household = $5
	) as total_count
FROM
	webhooks
WHERE
	webhooks.archived_at IS NULL
	AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	)
	AND webhooks.belongs_to_household = $5
	OFFSET $6
    LIMIT $7
`

type GetWebhooksParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	HouseholdID   string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetWebhooksRow struct {
	ID                 string
	Name               string
	ContentType        string
	URL                string
	Method             string
	CreatedAt          time.Time
	LastUpdatedAt      sql.NullTime
	ArchivedAt         sql.NullTime
	BelongsToHousehold string
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetWebhooks(ctx context.Context, db DBTX, arg *GetWebhooksParams) ([]*GetWebhooksRow, error) {
	rows, err := db.QueryContext(ctx, getWebhooks,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.HouseholdID,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebhooksRow{}
	for rows.Next() {
		var i GetWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentType,
			&i.URL,
			&i.Method,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
