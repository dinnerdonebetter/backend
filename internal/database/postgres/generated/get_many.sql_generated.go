// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_many.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getHouseholdInstrumentOwnerships = `-- name: GetHouseholdInstrumentOwnerships :many

SELECT
  household_instrument_ownerships.id,
  household_instrument_ownerships.notes,
  household_instrument_ownerships.quantity,
  valid_instruments.id,
  valid_instruments.name,
  valid_instruments.plural_name,
  valid_instruments.description,
  valid_instruments.icon_path,
  valid_instruments.usable_for_storage,
  valid_instruments.display_in_summary_lists,
  valid_instruments.include_in_generated_instructions,
  valid_instruments.slug,
  valid_instruments.created_at,
  valid_instruments.last_updated_at,
  valid_instruments.archived_at,
  household_instrument_ownerships.belongs_to_household,
  household_instrument_ownerships.created_at,
  household_instrument_ownerships.last_updated_at,
  household_instrument_ownerships.archived_at,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
      AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
      AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
      )
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
  ) as total_count
FROM
  household_instrument_ownerships
  JOIN valid_instruments ON valid_instruments.id = household_instrument_ownerships.valid_instrument_id
WHERE household_instrument_ownerships.belongs_to_household = $1
  AND household_instrument_ownerships.archived_at IS NULL
  AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
  AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
  )
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  household_instrument_ownerships.id,
  valid_instruments.id
ORDER BY
  household_instrument_ownerships.id
OFFSET $6
LIMIT $7
`

type GetHouseholdInstrumentOwnershipsParams struct {
	BelongsToHousehold string
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	LastUpdatedAt      sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	Offset             int32
	Limit              int32
}

type GetHouseholdInstrumentOwnershipsRow struct {
	CreatedAt                      time.Time
	CreatedAt_2                    time.Time
	ArchivedAt_2                   sql.NullTime
	LastUpdatedAt_2                sql.NullTime
	ArchivedAt                     sql.NullTime
	LastUpdatedAt                  sql.NullTime
	BelongsToHousehold             string
	ID_2                           string
	Notes                          string
	IconPath                       string
	ID                             string
	Slug                           string
	Description                    string
	PluralName                     string
	Name                           string
	FilteredCount                  int64
	TotalCount                     int64
	Quantity                       int32
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) GetHouseholdInstrumentOwnerships(ctx context.Context, db DBTX, arg *GetHouseholdInstrumentOwnershipsParams) ([]*GetHouseholdInstrumentOwnershipsRow, error) {
	rows, err := db.QueryContext(ctx, getHouseholdInstrumentOwnerships,
		arg.BelongsToHousehold,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHouseholdInstrumentOwnershipsRow{}
	for rows.Next() {
		var i GetHouseholdInstrumentOwnershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Quantity,
			&i.ID_2,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeRatings = `-- name: GetRecipeRatings :many

SELECT
	recipe_ratings.id,
    recipe_ratings.recipe_id,
    recipe_ratings.taste,
    recipe_ratings.difficulty,
    recipe_ratings.cleanup,
    recipe_ratings.instructions,
    recipe_ratings.overall,
    recipe_ratings.notes,
    recipe_ratings.by_user,
    recipe_ratings.created_at,
    recipe_ratings.last_updated_at,
    recipe_ratings.archived_at,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	 AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	) as total_count
FROM
	recipe_ratings
WHERE
	recipe_ratings.archived_at IS NULL
	AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_ratings.id
ORDER BY
	recipe_ratings.id
	LIMIT $5
`

type GetRecipeRatingsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Limit           int32
}

type GetRecipeRatingsRow struct {
	CreatedAt     time.Time
	ArchivedAt    sql.NullTime
	LastUpdatedAt sql.NullTime
	Notes         string
	RecipeID      string
	ID            string
	ByUser        string
	Difficulty    sql.NullString
	Overall       sql.NullString
	Instructions  sql.NullString
	Cleanup       sql.NullString
	Taste         sql.NullString
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetRecipeRatings(ctx context.Context, db DBTX, arg *GetRecipeRatingsParams) ([]*GetRecipeRatingsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeRatings,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeRatingsRow{}
	for rows.Next() {
		var i GetRecipeRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.Taste,
			&i.Difficulty,
			&i.Cleanup,
			&i.Instructions,
			&i.Overall,
			&i.Notes,
			&i.ByUser,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeStepCompletionConditions = `-- name: GetRecipeStepCompletionConditions :many

SELECT
	recipe_step_completion_condition_ingredients.id,
	recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition,
	recipe_step_completion_condition_ingredients.recipe_step_ingredient,
	recipe_step_completion_conditions.id,
	recipe_step_completion_conditions.belongs_to_recipe_step,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	recipe_step_completion_conditions.optional,
	recipe_step_completion_conditions.notes,
	recipe_step_completion_conditions.created_at,
	recipe_step_completion_conditions.last_updated_at,
	recipe_step_completion_conditions.archived_at,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	      AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	) as total_count
FROM recipe_step_completion_condition_ingredients
	JOIN recipe_step_completion_conditions ON recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition = recipe_step_completion_conditions.id
	JOIN recipe_steps ON recipe_step_completion_conditions.belongs_to_recipe_step = recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe = recipes.id
	JOIN valid_ingredient_states ON recipe_step_completion_conditions.ingredient_state = valid_ingredient_states.id
WHERE
	recipe_step_completion_conditions.archived_at IS NULL
	AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_step_completion_conditions.id,
	valid_ingredient_states.id,
	recipe_step_completion_condition_ingredients.id
ORDER BY
	recipe_step_completion_conditions.id
	LIMIT $5
	OFFSET $6
`

type GetRecipeStepCompletionConditionsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Limit           int32
	Offset          int32
}

type GetRecipeStepCompletionConditionsRow struct {
	CreatedAt                              time.Time
	CreatedAt_2                            time.Time
	ArchivedAt_2                           sql.NullTime
	LastUpdatedAt_2                        sql.NullTime
	ArchivedAt                             sql.NullTime
	LastUpdatedAt                          sql.NullTime
	PastTense                              string
	ID_3                                   string
	IconPath                               string
	Slug                                   string
	ID                                     string
	AttributeType                          IngredientAttributeType
	Name                                   string
	Description                            string
	BelongsToRecipeStep                    string
	BelongsToRecipeStepCompletionCondition string
	Notes                                  string
	ID_2                                   string
	RecipeStepIngredient                   string
	FilteredCount                          int64
	TotalCount                             int64
	Optional                               bool
}

func (q *Queries) GetRecipeStepCompletionConditions(ctx context.Context, db DBTX, arg *GetRecipeStepCompletionConditionsParams) ([]*GetRecipeStepCompletionConditionsRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepCompletionConditions,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepCompletionConditionsRow{}
	for rows.Next() {
		var i GetRecipeStepCompletionConditionsRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToRecipeStepCompletionCondition,
			&i.RecipeStepIngredient,
			&i.ID_2,
			&i.BelongsToRecipeStep,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.Slug,
			&i.PastTense,
			&i.AttributeType,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.Optional,
			&i.Notes,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
          AND users.created_at > COALESCE($1::TIMESTAMP, (SELECT NOW() - interval '999 years'))
          AND users.created_at < COALESCE($2::TIMESTAMP, (SELECT NOW() + interval '999 years'))
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at > COALESCE($3::TIMESTAMP, (SELECT NOW() - interval '999 years'))
            )
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at < COALESCE($4::TIMESTAMP, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $5
    ) as filtered_count,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
    ) as total_count
FROM users
WHERE
    users.archived_at IS NULL
  AND users.created_at > COALESCE($1::TIMESTAMP, (SELECT NOW() - interval '999 years'))
  AND users.created_at < COALESCE($2::TIMESTAMP, (SELECT NOW() + interval '999 years'))
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at > COALESCE($3::TIMESTAMP, (SELECT NOW() - interval '999 years'))
    )
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at < COALESCE($4::TIMESTAMP, (SELECT NOW() + interval '999 years'))
    )
OFFSET $5
LIMIT $6
`

type GetUsersParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetUsersRow struct {
	CreatedAt                    time.Time
	Birthday                     sql.NullTime
	PasswordLastChangedAt        sql.NullTime
	TwoFactorSecretVerifiedAt    sql.NullTime
	ArchivedAt                   sql.NullTime
	EmailAddressVerifiedAt       sql.NullTime
	LastUpdatedAt                sql.NullTime
	LastAcceptedPrivacyPolicy    sql.NullTime
	LastAcceptedTermsOfService   sql.NullTime
	HashedPassword               string
	TwoFactorSecret              string
	ServiceRole                  string
	Username                     string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	ID                           string
	EmailAddress                 string
	LastName                     string
	FirstName                    string
	AvatarSrc                    sql.NullString
	FilteredCount                int64
	TotalCount                   int64
	RequiresPasswordChange       bool
}

func (q *Queries) GetUsers(ctx context.Context, db DBTX, arg *GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := db.QueryContext(ctx, getUsers,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.EmailAddress,
			&i.EmailAddressVerifiedAt,
			&i.AvatarSrc,
			&i.HashedPassword,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedAt,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredientGroups = `-- name: GetValidIngredientGroups :many

SELECT
    valid_ingredient_groups.id,
    valid_ingredient_groups.name,
    valid_ingredient_groups.description,
    valid_ingredient_groups.slug,
    valid_ingredient_groups.created_at,
    valid_ingredient_groups.last_updated_at,
    valid_ingredient_groups.archived_at,
    valid_ingredient_group_members.id,
    valid_ingredient_group_members.belongs_to_group,
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at,
    valid_ingredient_group_members.created_at,
    valid_ingredient_group_members.archived_at,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
          AND valid_ingredient_groups.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_groups.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
            )
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $1
    ) AS filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
    ) AS total_count
FROM valid_ingredient_groups
  JOIN valid_ingredient_group_members ON valid_ingredient_groups.id = valid_ingredient_group_members.belongs_to_group
  JOIN valid_ingredients ON valid_ingredients.id = valid_ingredient_group_members.valid_ingredient
WHERE
	valid_ingredient_groups.archived_at IS NULL
	AND valid_ingredient_group_members.archived_at IS NULL
	AND valid_ingredient_groups.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
	AND valid_ingredient_groups.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
	)
	OFFSET $1
`

type GetValidIngredientGroupsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Offset          int32
}

type GetValidIngredientGroupsRow struct {
	CreatedAt_2                             time.Time
	CreatedAt                               time.Time
	CreatedAt_3                             time.Time
	ArchivedAt_3                            sql.NullTime
	LastUpdatedAt_2                         sql.NullTime
	ArchivedAt_2                            sql.NullTime
	LastUpdatedAt                           sql.NullTime
	ArchivedAt                              sql.NullTime
	Slug_2                                  string
	PluralName                              string
	Name_2                                  string
	Description_2                           string
	Warning                                 string
	IconPath                                string
	ID                                      string
	BelongsToGroup                          string
	ID_2                                    string
	Slug                                    string
	Description                             string
	Name                                    string
	ShoppingSuggestions                     string
	ID_3                                    string
	StorageInstructions                     string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	FilteredCount                           int64
	TotalCount                              int64
	IsLiquid                                sql.NullBool
	AnimalFlesh                             bool
	RestrictToPreparations                  bool
	AnimalDerived                           bool
	Volumetric                              bool
	ContainsGluten                          bool
	ContainsFish                            bool
	ContainsAlcohol                         bool
	ContainsSesame                          bool
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsShellfish                       bool
	ContainsWheat                           bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredientGroups(ctx context.Context, db DBTX, arg *GetValidIngredientGroupsParams) ([]*GetValidIngredientGroupsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredientGroups,
		arg.Offset,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientGroupsRow{}
	for rows.Next() {
		var i GetValidIngredientGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.ID_2,
			&i.BelongsToGroup,
			&i.ID_3,
			&i.Name_2,
			&i.Description_2,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug_2,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.CreatedAt_3,
			&i.ArchivedAt_3,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidIngredients = `-- name: GetValidIngredients :many

SELECT
  valid_ingredients.id,
  valid_ingredients.name,
  valid_ingredients.description,
  valid_ingredients.warning,
  valid_ingredients.contains_egg,
  valid_ingredients.contains_dairy,
  valid_ingredients.contains_peanut,
  valid_ingredients.contains_tree_nut,
  valid_ingredients.contains_soy,
  valid_ingredients.contains_wheat,
  valid_ingredients.contains_shellfish,
  valid_ingredients.contains_sesame,
  valid_ingredients.contains_fish,
  valid_ingredients.contains_gluten,
  valid_ingredients.animal_flesh,
  valid_ingredients.volumetric,
  valid_ingredients.is_liquid,
  valid_ingredients.icon_path,
  valid_ingredients.animal_derived,
  valid_ingredients.plural_name,
  valid_ingredients.restrict_to_preparations,
  valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
  valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
  valid_ingredients.storage_instructions,
  valid_ingredients.slug,
  valid_ingredients.contains_alcohol,
  valid_ingredients.shopping_suggestions,
  valid_ingredients.is_starch,
  valid_ingredients.is_protein,
  valid_ingredients.is_grain,
  valid_ingredients.is_fruit,
  valid_ingredients.is_salt,
  valid_ingredients.is_fat,
  valid_ingredients.is_acid,
  valid_ingredients.is_heat,
  valid_ingredients.created_at,
  valid_ingredients.last_updated_at,
  valid_ingredients.archived_at,
  (
    SELECT
      COUNT(valid_ingredients.id)
    FROM
      valid_ingredients
    WHERE
      valid_ingredients.archived_at IS NULL
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_ingredients.id)
    FROM
      valid_ingredients
    WHERE
      valid_ingredients.archived_at IS NULL
  ) as total_count
FROM
  valid_ingredients
WHERE
  valid_ingredients.archived_at IS NULL
GROUP BY
  valid_ingredients.id
ORDER BY
  valid_ingredients.id
LIMIT
  20
`

type GetValidIngredientsRow struct {
	CreatedAt                               time.Time
	ArchivedAt                              sql.NullTime
	LastUpdatedAt                           sql.NullTime
	IconPath                                string
	Name                                    string
	Description                             string
	Warning                                 string
	PluralName                              string
	ID                                      string
	ShoppingSuggestions                     string
	Slug                                    string
	StorageInstructions                     string
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	FilteredCount                           int64
	TotalCount                              int64
	IsLiquid                                sql.NullBool
	RestrictToPreparations                  bool
	IsProtein                               bool
	Volumetric                              bool
	AnimalFlesh                             bool
	ContainsGluten                          bool
	ContainsFish                            bool
	ContainsSesame                          bool
	ContainsShellfish                       bool
	ContainsAlcohol                         bool
	ContainsWheat                           bool
	IsStarch                                bool
	AnimalDerived                           bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	ContainsSoy                             bool
	ContainsTreeNut                         bool
	ContainsPeanut                          bool
	ContainsDairy                           bool
	ContainsEgg                             bool
}

func (q *Queries) GetValidIngredients(ctx context.Context, db DBTX) ([]*GetValidIngredientsRow, error) {
	rows, err := db.QueryContext(ctx, getValidIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientsRow{}
	for rows.Next() {
		var i GetValidIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidInstruments = `-- name: GetValidInstruments :many

SELECT
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	 AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	) as total_count
FROM
	valid_instruments
WHERE
	valid_instruments.archived_at IS NULL
	AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	valid_instruments.id
ORDER BY
	valid_instruments.id
	LIMIT $5
`

type GetValidInstrumentsParams struct {
	CreatedAt       time.Time
	CreatedAt_2     time.Time
	LastUpdatedAt   sql.NullTime
	LastUpdatedAt_2 sql.NullTime
	Limit           int32
}

type GetValidInstrumentsRow struct {
	ID            string
	Name          string
	PluralName    string
	Description   string
	IconPath      string
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetValidInstruments(ctx context.Context, db DBTX, arg *GetValidInstrumentsParams) ([]*GetValidInstrumentsRow, error) {
	rows, err := db.QueryContext(ctx, getValidInstruments,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidInstrumentsRow{}
	for rows.Next() {
		var i GetValidInstrumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVessels = `-- name: GetValidVessels :many

SELECT
  valid_vessels.id,
  valid_vessels.name,
  valid_vessels.plural_name,
  valid_vessels.description,
  valid_vessels.icon_path,
  valid_vessels.usable_for_storage,
  valid_vessels.slug,
  valid_vessels.display_in_summary_lists,
  valid_vessels.include_in_generated_instructions,
  valid_vessels.capacity::float,
  valid_vessels.capacity_unit,
  valid_vessels.width_in_millimeters::float,
  valid_vessels.length_in_millimeters::float,
  valid_vessels.height_in_millimeters::float,
  valid_vessels.shape,
  valid_vessels.created_at,
  valid_vessels.last_updated_at,
  valid_vessels.archived_at,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
      AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
      AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
      )
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
  ) as total_count
FROM
  valid_vessels
WHERE
  valid_vessels.archived_at IS NULL
  AND valid_vessels.created_at > (COALESCE($1, (SELECT NOW() - interval '999 years')))
  AND valid_vessels.created_at < (COALESCE($2, (SELECT NOW() + interval '999 years')))
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
  )
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  valid_vessels.id
ORDER BY
  valid_vessels.id
OFFSET
    $5
LIMIT
    $6
`

type GetValidVesselsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidVesselsRow struct {
	CreatedAt                       time.Time
	ArchivedAt                      sql.NullTime
	LastUpdatedAt                   sql.NullTime
	ID                              string
	Name                            string
	PluralName                      string
	Description                     string
	IconPath                        string
	Slug                            string
	Shape                           VesselShape
	CapacityUnit                    sql.NullString
	ValidVesselsWidthInMillimeters  float64
	ValidVesselsLengthInMillimeters float64
	ValidVesselsHeightInMillimeters float64
	ValidVesselsCapacity            float64
	FilteredCount                   int64
	TotalCount                      int64
	IncludeInGeneratedInstructions  bool
	DisplayInSummaryLists           bool
	UsableForStorage                bool
}

func (q *Queries) GetValidVessels(ctx context.Context, db DBTX, arg *GetValidVesselsParams) ([]*GetValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVessels,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsRow{}
	for rows.Next() {
		var i GetValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.ValidVesselsCapacity,
			&i.CapacityUnit,
			&i.ValidVesselsWidthInMillimeters,
			&i.ValidVesselsLengthInMillimeters,
			&i.ValidVesselsHeightInMillimeters,
			&i.Shape,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhooks = `-- name: GetWebhooks :many

SELECT
	webhooks.id,
	webhooks.name,
	webhooks.content_type,
	webhooks.url,
	webhooks.method,
	webhooks.created_at,
	webhooks.last_updated_at,
	webhooks.archived_at,
	webhooks.belongs_to_household,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
	      AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	        )
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	        )
          AND webhooks.belongs_to_household = $5
	) as filtered_count,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
            AND webhooks.belongs_to_household = $5
	) as total_count
FROM
	webhooks
WHERE
	webhooks.archived_at IS NULL
	AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	)
	AND webhooks.belongs_to_household = $5
	OFFSET $6
    LIMIT $7
`

type GetWebhooksParams struct {
	CreatedBefore sql.NullTime
	CreatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	HouseholdID   string
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetWebhooksRow struct {
	ID                 string
	Name               string
	ContentType        string
	URL                string
	Method             string
	CreatedAt          time.Time
	LastUpdatedAt      sql.NullTime
	ArchivedAt         sql.NullTime
	BelongsToHousehold string
	FilteredCount      int64
	TotalCount         int64
}

func (q *Queries) GetWebhooks(ctx context.Context, db DBTX, arg *GetWebhooksParams) ([]*GetWebhooksRow, error) {
	rows, err := db.QueryContext(ctx, getWebhooks,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.HouseholdID,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebhooksRow{}
	for rows.Next() {
		var i GetWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentType,
			&i.URL,
			&i.Method,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
