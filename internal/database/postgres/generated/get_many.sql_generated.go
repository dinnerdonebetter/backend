// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_many.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const GetHouseholdInstrumentOwnerships = `-- name: GetHouseholdInstrumentOwnerships :many

SELECT
  household_instrument_ownerships.id,
  household_instrument_ownerships.notes,
  household_instrument_ownerships.quantity,
  valid_instruments.id,
  valid_instruments.name,
  valid_instruments.plural_name,
  valid_instruments.description,
  valid_instruments.icon_path,
  valid_instruments.usable_for_storage,
  valid_instruments.display_in_summary_lists,
  valid_instruments.include_in_generated_instructions,
  valid_instruments.slug,
  valid_instruments.created_at,
  valid_instruments.last_updated_at,
  valid_instruments.archived_at,
  household_instrument_ownerships.belongs_to_household,
  household_instrument_ownerships.created_at,
  household_instrument_ownerships.last_updated_at,
  household_instrument_ownerships.archived_at,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
      AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
      AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
      )
      AND (
        household_instrument_ownerships.last_updated_at IS NULL
        OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(household_instrument_ownerships.id)
    FROM
      household_instrument_ownerships
    WHERE
      household_instrument_ownerships.belongs_to_household = $1
      AND household_instrument_ownerships.archived_at IS NULL
  ) as total_count
FROM
  household_instrument_ownerships
  JOIN valid_instruments ON valid_instruments.id = household_instrument_ownerships.valid_instrument_id
WHERE household_instrument_ownerships.belongs_to_household = $1
  AND household_instrument_ownerships.archived_at IS NULL
  AND household_instrument_ownerships.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
  AND household_instrument_ownerships.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
  )
  AND (
    household_instrument_ownerships.last_updated_at IS NULL
    OR household_instrument_ownerships.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  household_instrument_ownerships.id,
  valid_instruments.id
ORDER BY
  household_instrument_ownerships.id
OFFSET $6
LIMIT $7
`

type GetHouseholdInstrumentOwnershipsParams struct {
	BelongsToHousehold string       `db:"belongs_to_household"`
	CreatedAt          time.Time    `db:"created_at"`
	CreatedAt_2        time.Time    `db:"created_at_2"`
	LastUpdatedAt      sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2    sql.NullTime `db:"last_updated_at_2"`
	Offset             int32        `db:"offset"`
	Limit              int32        `db:"limit"`
}

type GetHouseholdInstrumentOwnershipsRow struct {
	CreatedAt                      time.Time    `db:"created_at"`
	CreatedAt_2                    time.Time    `db:"created_at_2"`
	ArchivedAt_2                   sql.NullTime `db:"archived_at_2"`
	LastUpdatedAt_2                sql.NullTime `db:"last_updated_at_2"`
	ArchivedAt                     sql.NullTime `db:"archived_at"`
	LastUpdatedAt                  sql.NullTime `db:"last_updated_at"`
	BelongsToHousehold             string       `db:"belongs_to_household"`
	ID_2                           string       `db:"id_2"`
	Notes                          string       `db:"notes"`
	IconPath                       string       `db:"icon_path"`
	ID                             string       `db:"id"`
	Slug                           string       `db:"slug"`
	Description                    string       `db:"description"`
	PluralName                     string       `db:"plural_name"`
	Name                           string       `db:"name"`
	FilteredCount                  int64        `db:"filtered_count"`
	TotalCount                     int64        `db:"total_count"`
	Quantity                       int32        `db:"quantity"`
	IncludeInGeneratedInstructions bool         `db:"include_in_generated_instructions"`
	DisplayInSummaryLists          bool         `db:"display_in_summary_lists"`
	UsableForStorage               bool         `db:"usable_for_storage"`
}

func (q *Queries) GetHouseholdInstrumentOwnerships(ctx context.Context, db DBTX, arg *GetHouseholdInstrumentOwnershipsParams) ([]*GetHouseholdInstrumentOwnershipsRow, error) {
	rows, err := db.QueryContext(ctx, GetHouseholdInstrumentOwnerships,
		arg.BelongsToHousehold,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHouseholdInstrumentOwnershipsRow{}
	for rows.Next() {
		var i GetHouseholdInstrumentOwnershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Notes,
			&i.Quantity,
			&i.ID_2,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecipeRatings = `-- name: GetRecipeRatings :many

SELECT
	recipe_ratings.id,
    recipe_ratings.recipe_id,
    recipe_ratings.taste,
    recipe_ratings.difficulty,
    recipe_ratings.cleanup,
    recipe_ratings.instructions,
    recipe_ratings.overall,
    recipe_ratings.notes,
    recipe_ratings.by_user,
    recipe_ratings.created_at,
    recipe_ratings.last_updated_at,
    recipe_ratings.archived_at,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	 AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(recipe_ratings.id)
	 FROM
		recipe_ratings
	 WHERE
		recipe_ratings.archived_at IS NULL
	) as total_count
FROM
	recipe_ratings
WHERE
	recipe_ratings.archived_at IS NULL
	AND recipe_ratings.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_ratings.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_ratings.last_updated_at IS NULL OR recipe_ratings.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_ratings.id
ORDER BY
	recipe_ratings.id
	LIMIT $5
`

type GetRecipeRatingsParams struct {
	CreatedAt       time.Time    `db:"created_at"`
	CreatedAt_2     time.Time    `db:"created_at_2"`
	LastUpdatedAt   sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2 sql.NullTime `db:"last_updated_at_2"`
	Limit           int32        `db:"limit"`
}

type GetRecipeRatingsRow struct {
	CreatedAt     time.Time      `db:"created_at"`
	ArchivedAt    sql.NullTime   `db:"archived_at"`
	LastUpdatedAt sql.NullTime   `db:"last_updated_at"`
	Notes         string         `db:"notes"`
	RecipeID      string         `db:"recipe_id"`
	ID            string         `db:"id"`
	ByUser        string         `db:"by_user"`
	Difficulty    sql.NullString `db:"difficulty"`
	Overall       sql.NullString `db:"overall"`
	Instructions  sql.NullString `db:"instructions"`
	Cleanup       sql.NullString `db:"cleanup"`
	Taste         sql.NullString `db:"taste"`
	FilteredCount int64          `db:"filtered_count"`
	TotalCount    int64          `db:"total_count"`
}

func (q *Queries) GetRecipeRatings(ctx context.Context, db DBTX, arg *GetRecipeRatingsParams) ([]*GetRecipeRatingsRow, error) {
	rows, err := db.QueryContext(ctx, GetRecipeRatings,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeRatingsRow{}
	for rows.Next() {
		var i GetRecipeRatingsRow
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.Taste,
			&i.Difficulty,
			&i.Cleanup,
			&i.Instructions,
			&i.Overall,
			&i.Notes,
			&i.ByUser,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecipeStepCompletionConditions = `-- name: GetRecipeStepCompletionConditions :many

SELECT
	recipe_step_completion_condition_ingredients.id,
	recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition,
	recipe_step_completion_condition_ingredients.recipe_step_ingredient,
	recipe_step_completion_conditions.id,
	recipe_step_completion_conditions.belongs_to_recipe_step,
	valid_ingredient_states.id,
	valid_ingredient_states.name,
	valid_ingredient_states.description,
	valid_ingredient_states.icon_path,
	valid_ingredient_states.slug,
	valid_ingredient_states.past_tense,
	valid_ingredient_states.attribute_type,
	valid_ingredient_states.created_at,
	valid_ingredient_states.last_updated_at,
	valid_ingredient_states.archived_at,
	recipe_step_completion_conditions.optional,
	recipe_step_completion_conditions.notes,
	recipe_step_completion_conditions.created_at,
	recipe_step_completion_conditions.last_updated_at,
	recipe_step_completion_conditions.archived_at,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	      AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	      AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	    SELECT
	        COUNT(recipe_step_completion_conditions.id)
	    FROM
	        recipe_step_completion_conditions
	    WHERE
	        recipe_step_completion_conditions.archived_at IS NULL
	) as total_count
FROM recipe_step_completion_condition_ingredients
	JOIN recipe_step_completion_conditions ON recipe_step_completion_condition_ingredients.belongs_to_recipe_step_completion_condition = recipe_step_completion_conditions.id
	JOIN recipe_steps ON recipe_step_completion_conditions.belongs_to_recipe_step = recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe = recipes.id
	JOIN valid_ingredient_states ON recipe_step_completion_conditions.ingredient_state = valid_ingredient_states.id
WHERE
	recipe_step_completion_conditions.archived_at IS NULL
	AND recipe_step_completion_conditions.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND recipe_step_completion_conditions.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (recipe_step_completion_conditions.last_updated_at IS NULL OR recipe_step_completion_conditions.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	recipe_step_completion_conditions.id,
	valid_ingredient_states.id,
	recipe_step_completion_condition_ingredients.id
ORDER BY
	recipe_step_completion_conditions.id
	LIMIT $5
	OFFSET $6
`

type GetRecipeStepCompletionConditionsParams struct {
	CreatedAt       time.Time    `db:"created_at"`
	CreatedAt_2     time.Time    `db:"created_at_2"`
	LastUpdatedAt   sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2 sql.NullTime `db:"last_updated_at_2"`
	Limit           int32        `db:"limit"`
	Offset          int32        `db:"offset"`
}

type GetRecipeStepCompletionConditionsRow struct {
	CreatedAt                              time.Time               `db:"created_at"`
	CreatedAt_2                            time.Time               `db:"created_at_2"`
	ArchivedAt_2                           sql.NullTime            `db:"archived_at_2"`
	LastUpdatedAt_2                        sql.NullTime            `db:"last_updated_at_2"`
	ArchivedAt                             sql.NullTime            `db:"archived_at"`
	LastUpdatedAt                          sql.NullTime            `db:"last_updated_at"`
	PastTense                              string                  `db:"past_tense"`
	ID_3                                   string                  `db:"id_3"`
	IconPath                               string                  `db:"icon_path"`
	Slug                                   string                  `db:"slug"`
	ID                                     string                  `db:"id"`
	AttributeType                          IngredientAttributeType `db:"attribute_type"`
	Name                                   string                  `db:"name"`
	Description                            string                  `db:"description"`
	BelongsToRecipeStep                    string                  `db:"belongs_to_recipe_step"`
	BelongsToRecipeStepCompletionCondition string                  `db:"belongs_to_recipe_step_completion_condition"`
	Notes                                  string                  `db:"notes"`
	ID_2                                   string                  `db:"id_2"`
	RecipeStepIngredient                   string                  `db:"recipe_step_ingredient"`
	FilteredCount                          int64                   `db:"filtered_count"`
	TotalCount                             int64                   `db:"total_count"`
	Optional                               bool                    `db:"optional"`
}

func (q *Queries) GetRecipeStepCompletionConditions(ctx context.Context, db DBTX, arg *GetRecipeStepCompletionConditionsParams) ([]*GetRecipeStepCompletionConditionsRow, error) {
	rows, err := db.QueryContext(ctx, GetRecipeStepCompletionConditions,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepCompletionConditionsRow{}
	for rows.Next() {
		var i GetRecipeStepCompletionConditionsRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToRecipeStepCompletionCondition,
			&i.RecipeStepIngredient,
			&i.ID_2,
			&i.BelongsToRecipeStep,
			&i.ID_3,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.Slug,
			&i.PastTense,
			&i.AttributeType,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.Optional,
			&i.Notes,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetUsers = `-- name: GetUsers :many

SELECT
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.last_accepted_terms_of_service,
    users.last_accepted_privacy_policy,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
          AND users.created_at > COALESCE($1::TIMESTAMP, (SELECT NOW() - interval '999 years'))
          AND users.created_at < COALESCE($2::TIMESTAMP, (SELECT NOW() + interval '999 years'))
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at > COALESCE($3::TIMESTAMP, (SELECT NOW() - interval '999 years'))
            )
          AND (
                users.last_updated_at IS NULL
                OR users.last_updated_at < COALESCE($4::TIMESTAMP, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $5
    ) as filtered_count,
    (
        SELECT
            COUNT(users.id)
        FROM
            users
        WHERE
            users.archived_at IS NULL
    ) as total_count
FROM users
WHERE
    users.archived_at IS NULL
  AND users.created_at > COALESCE($1::TIMESTAMP, (SELECT NOW() - interval '999 years'))
  AND users.created_at < COALESCE($2::TIMESTAMP, (SELECT NOW() + interval '999 years'))
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at > COALESCE($3::TIMESTAMP, (SELECT NOW() - interval '999 years'))
    )
  AND (
        users.last_updated_at IS NULL
        OR users.last_updated_at < COALESCE($4::TIMESTAMP, (SELECT NOW() + interval '999 years'))
    )
OFFSET $5
LIMIT $6
`

type GetUsersParams struct {
	CreatedBefore sql.NullTime  `db:"created_before"`
	CreatedAfter  sql.NullTime  `db:"created_after"`
	UpdatedBefore sql.NullTime  `db:"updated_before"`
	UpdatedAfter  sql.NullTime  `db:"updated_after"`
	QueryOffset   sql.NullInt32 `db:"query_offset"`
	QueryLimit    sql.NullInt32 `db:"query_limit"`
}

type GetUsersRow struct {
	CreatedAt                    time.Time      `db:"created_at"`
	Birthday                     sql.NullTime   `db:"birthday"`
	PasswordLastChangedAt        sql.NullTime   `db:"password_last_changed_at"`
	TwoFactorSecretVerifiedAt    sql.NullTime   `db:"two_factor_secret_verified_at"`
	ArchivedAt                   sql.NullTime   `db:"archived_at"`
	EmailAddressVerifiedAt       sql.NullTime   `db:"email_address_verified_at"`
	LastUpdatedAt                sql.NullTime   `db:"last_updated_at"`
	LastAcceptedPrivacyPolicy    sql.NullTime   `db:"last_accepted_privacy_policy"`
	LastAcceptedTermsOfService   sql.NullTime   `db:"last_accepted_terms_of_service"`
	HashedPassword               string         `db:"hashed_password"`
	TwoFactorSecret              string         `db:"two_factor_secret"`
	ServiceRole                  string         `db:"service_role"`
	Username                     string         `db:"username"`
	UserAccountStatus            string         `db:"user_account_status"`
	UserAccountStatusExplanation string         `db:"user_account_status_explanation"`
	ID                           string         `db:"id"`
	EmailAddress                 string         `db:"email_address"`
	LastName                     string         `db:"last_name"`
	FirstName                    string         `db:"first_name"`
	AvatarSrc                    sql.NullString `db:"avatar_src"`
	FilteredCount                int64          `db:"filtered_count"`
	TotalCount                   int64          `db:"total_count"`
	RequiresPasswordChange       bool           `db:"requires_password_change"`
}

func (q *Queries) GetUsers(ctx context.Context, db DBTX, arg *GetUsersParams) ([]*GetUsersRow, error) {
	rows, err := db.QueryContext(ctx, GetUsers,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUsersRow{}
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.EmailAddress,
			&i.EmailAddressVerifiedAt,
			&i.AvatarSrc,
			&i.HashedPassword,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedAt,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.LastAcceptedTermsOfService,
			&i.LastAcceptedPrivacyPolicy,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetValidIngredientGroups = `-- name: GetValidIngredientGroups :many

SELECT
    valid_ingredient_groups.id,
    valid_ingredient_groups.name,
    valid_ingredient_groups.description,
    valid_ingredient_groups.slug,
    valid_ingredient_groups.created_at,
    valid_ingredient_groups.last_updated_at,
    valid_ingredient_groups.archived_at,
    valid_ingredient_group_members.id,
    valid_ingredient_group_members.belongs_to_group,
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.animal_derived,
    valid_ingredients.plural_name,
    valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
    valid_ingredients.storage_instructions,
    valid_ingredients.slug,
    valid_ingredients.contains_alcohol,
    valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
    valid_ingredients.created_at,
    valid_ingredients.last_updated_at,
    valid_ingredients.archived_at,
    valid_ingredient_group_members.created_at,
    valid_ingredient_group_members.archived_at,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
          AND valid_ingredient_groups.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
          AND valid_ingredient_groups.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
            )
          AND (
                valid_ingredient_groups.last_updated_at IS NULL
                OR valid_ingredient_groups.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
            )
        OFFSET $1
    ) AS filtered_count,
    (
        SELECT
            COUNT(valid_ingredient_groups.id)
        FROM
            valid_ingredient_groups
        WHERE
            valid_ingredient_groups.archived_at IS NULL
    ) AS total_count
FROM valid_ingredient_groups
  JOIN valid_ingredient_group_members ON valid_ingredient_groups.id = valid_ingredient_group_members.belongs_to_group
  JOIN valid_ingredients ON valid_ingredients.id = valid_ingredient_group_members.valid_ingredient
WHERE
	valid_ingredient_groups.archived_at IS NULL
	AND valid_ingredient_group_members.archived_at IS NULL
	AND valid_ingredient_groups.created_at > COALESCE($2, (SELECT NOW() - interval '999 years'))
	AND valid_ingredient_groups.created_at < COALESCE($3, (SELECT NOW() + interval '999 years'))
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at > COALESCE($4, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    valid_ingredient_groups.last_updated_at IS NULL
	    OR valid_ingredient_groups.last_updated_at < COALESCE($5, (SELECT NOW() + interval '999 years'))
	)
	OFFSET $1
`

type GetValidIngredientGroupsParams struct {
	CreatedAt       time.Time    `db:"created_at"`
	CreatedAt_2     time.Time    `db:"created_at_2"`
	LastUpdatedAt   sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2 sql.NullTime `db:"last_updated_at_2"`
	Offset          int32        `db:"offset"`
}

type GetValidIngredientGroupsRow struct {
	CreatedAt_2                             time.Time      `db:"created_at_2"`
	CreatedAt                               time.Time      `db:"created_at"`
	CreatedAt_3                             time.Time      `db:"created_at_3"`
	ArchivedAt_3                            sql.NullTime   `db:"archived_at_3"`
	LastUpdatedAt_2                         sql.NullTime   `db:"last_updated_at_2"`
	ArchivedAt_2                            sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	Slug_2                                  string         `db:"slug_2"`
	PluralName                              string         `db:"plural_name"`
	Name_2                                  string         `db:"name_2"`
	Description_2                           string         `db:"description_2"`
	Warning                                 string         `db:"warning"`
	IconPath                                string         `db:"icon_path"`
	ID                                      string         `db:"id"`
	BelongsToGroup                          string         `db:"belongs_to_group"`
	ID_2                                    string         `db:"id_2"`
	Slug                                    string         `db:"slug"`
	Description                             string         `db:"description"`
	Name                                    string         `db:"name"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	ID_3                                    string         `db:"id_3"`
	StorageInstructions                     string         `db:"storage_instructions"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	FilteredCount                           int64          `db:"filtered_count"`
	TotalCount                              int64          `db:"total_count"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	AnimalDerived                           bool           `db:"animal_derived"`
	Volumetric                              bool           `db:"volumetric"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	IsStarch                                bool           `db:"is_starch"`
	IsProtein                               bool           `db:"is_protein"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
}

func (q *Queries) GetValidIngredientGroups(ctx context.Context, db DBTX, arg *GetValidIngredientGroupsParams) ([]*GetValidIngredientGroupsRow, error) {
	rows, err := db.QueryContext(ctx, GetValidIngredientGroups,
		arg.Offset,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientGroupsRow{}
	for rows.Next() {
		var i GetValidIngredientGroupsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Slug,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.ID_2,
			&i.BelongsToGroup,
			&i.ID_3,
			&i.Name_2,
			&i.Description_2,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug_2,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.CreatedAt_3,
			&i.ArchivedAt_3,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetValidIngredients = `-- name: GetValidIngredients :many

SELECT
  valid_ingredients.id,
  valid_ingredients.name,
  valid_ingredients.description,
  valid_ingredients.warning,
  valid_ingredients.contains_egg,
  valid_ingredients.contains_dairy,
  valid_ingredients.contains_peanut,
  valid_ingredients.contains_tree_nut,
  valid_ingredients.contains_soy,
  valid_ingredients.contains_wheat,
  valid_ingredients.contains_shellfish,
  valid_ingredients.contains_sesame,
  valid_ingredients.contains_fish,
  valid_ingredients.contains_gluten,
  valid_ingredients.animal_flesh,
  valid_ingredients.volumetric,
  valid_ingredients.is_liquid,
  valid_ingredients.icon_path,
  valid_ingredients.animal_derived,
  valid_ingredients.plural_name,
  valid_ingredients.restrict_to_preparations,
  valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
  valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
  valid_ingredients.storage_instructions,
  valid_ingredients.slug,
  valid_ingredients.contains_alcohol,
  valid_ingredients.shopping_suggestions,
  valid_ingredients.is_starch,
  valid_ingredients.is_protein,
  valid_ingredients.is_grain,
  valid_ingredients.is_fruit,
  valid_ingredients.is_salt,
  valid_ingredients.is_fat,
  valid_ingredients.is_acid,
  valid_ingredients.is_heat,
  valid_ingredients.created_at,
  valid_ingredients.last_updated_at,
  valid_ingredients.archived_at,
  (
    SELECT
      COUNT(valid_ingredients.id)
    FROM
      valid_ingredients
    WHERE
      valid_ingredients.archived_at IS NULL
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_ingredients.id)
    FROM
      valid_ingredients
    WHERE
      valid_ingredients.archived_at IS NULL
  ) as total_count
FROM
  valid_ingredients
WHERE
  valid_ingredients.archived_at IS NULL
GROUP BY
  valid_ingredients.id
ORDER BY
  valid_ingredients.id
LIMIT
  20
`

type GetValidIngredientsRow struct {
	CreatedAt                               time.Time      `db:"created_at"`
	ArchivedAt                              sql.NullTime   `db:"archived_at"`
	LastUpdatedAt                           sql.NullTime   `db:"last_updated_at"`
	IconPath                                string         `db:"icon_path"`
	Name                                    string         `db:"name"`
	Description                             string         `db:"description"`
	Warning                                 string         `db:"warning"`
	PluralName                              string         `db:"plural_name"`
	ID                                      string         `db:"id"`
	ShoppingSuggestions                     string         `db:"shopping_suggestions"`
	Slug                                    string         `db:"slug"`
	StorageInstructions                     string         `db:"storage_instructions"`
	MaximumIdealStorageTemperatureInCelsius sql.NullString `db:"maximum_ideal_storage_temperature_in_celsius"`
	MinimumIdealStorageTemperatureInCelsius sql.NullString `db:"minimum_ideal_storage_temperature_in_celsius"`
	FilteredCount                           int64          `db:"filtered_count"`
	TotalCount                              int64          `db:"total_count"`
	IsLiquid                                sql.NullBool   `db:"is_liquid"`
	RestrictToPreparations                  bool           `db:"restrict_to_preparations"`
	IsProtein                               bool           `db:"is_protein"`
	Volumetric                              bool           `db:"volumetric"`
	AnimalFlesh                             bool           `db:"animal_flesh"`
	ContainsGluten                          bool           `db:"contains_gluten"`
	ContainsFish                            bool           `db:"contains_fish"`
	ContainsSesame                          bool           `db:"contains_sesame"`
	ContainsShellfish                       bool           `db:"contains_shellfish"`
	ContainsAlcohol                         bool           `db:"contains_alcohol"`
	ContainsWheat                           bool           `db:"contains_wheat"`
	IsStarch                                bool           `db:"is_starch"`
	AnimalDerived                           bool           `db:"animal_derived"`
	IsGrain                                 bool           `db:"is_grain"`
	IsFruit                                 bool           `db:"is_fruit"`
	IsSalt                                  bool           `db:"is_salt"`
	IsFat                                   bool           `db:"is_fat"`
	IsAcid                                  bool           `db:"is_acid"`
	IsHeat                                  bool           `db:"is_heat"`
	ContainsSoy                             bool           `db:"contains_soy"`
	ContainsTreeNut                         bool           `db:"contains_tree_nut"`
	ContainsPeanut                          bool           `db:"contains_peanut"`
	ContainsDairy                           bool           `db:"contains_dairy"`
	ContainsEgg                             bool           `db:"contains_egg"`
}

func (q *Queries) GetValidIngredients(ctx context.Context, db DBTX) ([]*GetValidIngredientsRow, error) {
	rows, err := db.QueryContext(ctx, GetValidIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidIngredientsRow{}
	for rows.Next() {
		var i GetValidIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.AnimalDerived,
			&i.PluralName,
			&i.RestrictToPreparations,
			&i.MinimumIdealStorageTemperatureInCelsius,
			&i.MaximumIdealStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.Slug,
			&i.ContainsAlcohol,
			&i.ShoppingSuggestions,
			&i.IsStarch,
			&i.IsProtein,
			&i.IsGrain,
			&i.IsFruit,
			&i.IsSalt,
			&i.IsFat,
			&i.IsAcid,
			&i.IsHeat,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetValidInstruments = `-- name: GetValidInstruments :many

SELECT
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	 AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	 AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	 AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
	) as filtered_count,
	(
	 SELECT
		COUNT(valid_instruments.id)
	 FROM
		valid_instruments
	 WHERE
		valid_instruments.archived_at IS NULL
	) as total_count
FROM
	valid_instruments
WHERE
	valid_instruments.archived_at IS NULL
	AND valid_instruments.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND valid_instruments.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years')))
	AND (valid_instruments.last_updated_at IS NULL OR valid_instruments.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years')))
GROUP BY
	valid_instruments.id
ORDER BY
	valid_instruments.id
	LIMIT $5
`

type GetValidInstrumentsParams struct {
	CreatedAt       time.Time    `db:"created_at"`
	CreatedAt_2     time.Time    `db:"created_at_2"`
	LastUpdatedAt   sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2 sql.NullTime `db:"last_updated_at_2"`
	Limit           int32        `db:"limit"`
}

type GetValidInstrumentsRow struct {
	ID            string       `db:"id"`
	Name          string       `db:"name"`
	PluralName    string       `db:"plural_name"`
	Description   string       `db:"description"`
	IconPath      string       `db:"icon_path"`
	CreatedAt     time.Time    `db:"created_at"`
	LastUpdatedAt sql.NullTime `db:"last_updated_at"`
	ArchivedAt    sql.NullTime `db:"archived_at"`
	FilteredCount int64        `db:"filtered_count"`
	TotalCount    int64        `db:"total_count"`
}

func (q *Queries) GetValidInstruments(ctx context.Context, db DBTX, arg *GetValidInstrumentsParams) ([]*GetValidInstrumentsRow, error) {
	rows, err := db.QueryContext(ctx, GetValidInstruments,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidInstrumentsRow{}
	for rows.Next() {
		var i GetValidInstrumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetValidVessels = `-- name: GetValidVessels :many

SELECT
  valid_vessels.id,
  valid_vessels.name,
  valid_vessels.plural_name,
  valid_vessels.description,
  valid_vessels.icon_path,
  valid_vessels.usable_for_storage,
  valid_vessels.slug,
  valid_vessels.display_in_summary_lists,
  valid_vessels.include_in_generated_instructions,
  valid_vessels.capacity,
  valid_measurement_units.id,
  valid_measurement_units.name,
  valid_measurement_units.description,
  valid_measurement_units.volumetric,
  valid_measurement_units.icon_path,
  valid_measurement_units.universal,
  valid_measurement_units.metric,
  valid_measurement_units.imperial,
  valid_measurement_units.slug,
  valid_measurement_units.plural_name,
  valid_measurement_units.created_at,
  valid_measurement_units.last_updated_at,
  valid_measurement_units.archived_at,
  valid_vessels.width_in_millimeters,
  valid_vessels.length_in_millimeters,
  valid_vessels.height_in_millimeters,
  valid_vessels.shape,
  valid_vessels.created_at,
  valid_vessels.last_updated_at,
  valid_vessels.archived_at,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
      AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
      AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
      )
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
  ) as total_count
FROM
  valid_vessels
  LEFT JOIN valid_measurement_units ON valid_vessels.capacity_unit = valid_measurement_units.id
WHERE
  valid_vessels.archived_at IS NULL
  AND valid_measurement_units.archived_at IS NULL
  AND valid_vessels.created_at > (COALESCE($1, (SELECT NOW() - interval '999 years')))
  AND valid_vessels.created_at < (COALESCE($2, (SELECT NOW() + interval '999 years')))
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
  )
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  valid_vessels.id,
  valid_measurement_units.id
ORDER BY
  valid_vessels.id
OFFSET
  $5
LIMIT
  $6
`

type GetValidVesselsParams struct {
	CreatedAt       time.Time    `db:"created_at"`
	CreatedAt_2     time.Time    `db:"created_at_2"`
	LastUpdatedAt   sql.NullTime `db:"last_updated_at"`
	LastUpdatedAt_2 sql.NullTime `db:"last_updated_at_2"`
	Offset          int32        `db:"offset"`
	Limit           int32        `db:"limit"`
}

type GetValidVesselsRow struct {
	CreatedAt_2                    time.Time      `db:"created_at_2"`
	LastUpdatedAt_2                sql.NullTime   `db:"last_updated_at_2"`
	CreatedAt                      sql.NullTime   `db:"created_at"`
	ArchivedAt_2                   sql.NullTime   `db:"archived_at_2"`
	LastUpdatedAt                  sql.NullTime   `db:"last_updated_at"`
	ArchivedAt                     sql.NullTime   `db:"archived_at"`
	Slug                           string         `db:"slug"`
	IconPath                       string         `db:"icon_path"`
	Description                    string         `db:"description"`
	Capacity                       string         `db:"capacity"`
	PluralName                     string         `db:"plural_name"`
	Shape                          VesselShape    `db:"shape"`
	ID                             string         `db:"id"`
	Name                           string         `db:"name"`
	Description_2                  sql.NullString `db:"description_2"`
	IconPath_2                     sql.NullString `db:"icon_path_2"`
	HeightInMillimeters            sql.NullString `db:"height_in_millimeters"`
	Name_2                         sql.NullString `db:"name_2"`
	Slug_2                         sql.NullString `db:"slug_2"`
	PluralName_2                   sql.NullString `db:"plural_name_2"`
	ID_2                           sql.NullString `db:"id_2"`
	WidthInMillimeters             sql.NullString `db:"width_in_millimeters"`
	LengthInMillimeters            sql.NullString `db:"length_in_millimeters"`
	FilteredCount                  int64          `db:"filtered_count"`
	TotalCount                     int64          `db:"total_count"`
	Metric                         sql.NullBool   `db:"metric"`
	Imperial                       sql.NullBool   `db:"imperial"`
	Universal                      sql.NullBool   `db:"universal"`
	Volumetric                     sql.NullBool   `db:"volumetric"`
	IncludeInGeneratedInstructions bool           `db:"include_in_generated_instructions"`
	DisplayInSummaryLists          bool           `db:"display_in_summary_lists"`
	UsableForStorage               bool           `db:"usable_for_storage"`
}

func (q *Queries) GetValidVessels(ctx context.Context, db DBTX, arg *GetValidVesselsParams) ([]*GetValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, GetValidVessels,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.LastUpdatedAt,
		arg.LastUpdatedAt_2,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsRow{}
	for rows.Next() {
		var i GetValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.Capacity,
			&i.ID_2,
			&i.Name_2,
			&i.Description_2,
			&i.Volumetric,
			&i.IconPath_2,
			&i.Universal,
			&i.Metric,
			&i.Imperial,
			&i.Slug_2,
			&i.PluralName_2,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.WidthInMillimeters,
			&i.LengthInMillimeters,
			&i.HeightInMillimeters,
			&i.Shape,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetWebhooks = `-- name: GetWebhooks :many

SELECT
	webhooks.id,
	webhooks.name,
	webhooks.content_type,
	webhooks.url,
	webhooks.method,
	webhooks.created_at,
	webhooks.last_updated_at,
	webhooks.archived_at,
	webhooks.belongs_to_household,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
	      AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	      AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	        )
	      AND (
	            webhooks.last_updated_at IS NULL
	            OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	        )
          AND webhooks.belongs_to_household = $5
	) as filtered_count,
	(
	    SELECT
	        COUNT(webhooks.id)
	    FROM
	        webhooks
	    WHERE
	        webhooks.archived_at IS NULL
            AND webhooks.belongs_to_household = $5
	) as total_count
FROM
	webhooks
WHERE
	webhooks.archived_at IS NULL
	AND webhooks.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
	AND webhooks.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
	)
	AND (
	    webhooks.last_updated_at IS NULL
	    OR webhooks.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
	)
	AND webhooks.belongs_to_household = $5
	OFFSET $6
    LIMIT $7
`

type GetWebhooksParams struct {
	CreatedBefore sql.NullTime  `db:"created_before"`
	CreatedAfter  sql.NullTime  `db:"created_after"`
	UpdatedBefore sql.NullTime  `db:"updated_before"`
	UpdatedAfter  sql.NullTime  `db:"updated_after"`
	HouseholdID   string        `db:"household_id"`
	QueryOffset   sql.NullInt32 `db:"query_offset"`
	QueryLimit    sql.NullInt32 `db:"query_limit"`
}

type GetWebhooksRow struct {
	ID                 string       `db:"id"`
	Name               string       `db:"name"`
	ContentType        string       `db:"content_type"`
	Url                string       `db:"url"`
	Method             string       `db:"method"`
	CreatedAt          time.Time    `db:"created_at"`
	LastUpdatedAt      sql.NullTime `db:"last_updated_at"`
	ArchivedAt         sql.NullTime `db:"archived_at"`
	BelongsToHousehold string       `db:"belongs_to_household"`
	FilteredCount      int64        `db:"filtered_count"`
	TotalCount         int64        `db:"total_count"`
}

func (q *Queries) GetWebhooks(ctx context.Context, db DBTX, arg *GetWebhooksParams) ([]*GetWebhooksRow, error) {
	rows, err := db.QueryContext(ctx, GetWebhooks,
		arg.CreatedBefore,
		arg.CreatedAfter,
		arg.UpdatedBefore,
		arg.UpdatedAfter,
		arg.HouseholdID,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWebhooksRow{}
	for rows.Next() {
		var i GetWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ContentType,
			&i.Url,
			&i.Method,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToHousehold,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
