// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: get_random.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getRandomValidIngredient = `-- name: GetRandomValidIngredient :one

SELECT
	valid_ingredients.id,
	valid_ingredients.name,
	valid_ingredients.description,
	valid_ingredients.warning,
	valid_ingredients.contains_egg,
	valid_ingredients.contains_dairy,
	valid_ingredients.contains_peanut,
	valid_ingredients.contains_tree_nut,
	valid_ingredients.contains_soy,
	valid_ingredients.contains_wheat,
	valid_ingredients.contains_shellfish,
	valid_ingredients.contains_sesame,
	valid_ingredients.contains_fish,
	valid_ingredients.contains_gluten,
	valid_ingredients.animal_flesh,
	valid_ingredients.volumetric,
	valid_ingredients.is_liquid,
	valid_ingredients.icon_path,
	valid_ingredients.animal_derived,
	valid_ingredients.plural_name,
	valid_ingredients.restrict_to_preparations,
    valid_ingredients.minimum_ideal_storage_temperature_in_celsius,
    valid_ingredients.maximum_ideal_storage_temperature_in_celsius,
	valid_ingredients.storage_instructions,
	valid_ingredients.slug,
	valid_ingredients.contains_alcohol,
	valid_ingredients.shopping_suggestions,
    valid_ingredients.is_starch,
    valid_ingredients.is_protein,
    valid_ingredients.is_grain,
    valid_ingredients.is_fruit,
    valid_ingredients.is_salt,
    valid_ingredients.is_fat,
    valid_ingredients.is_acid,
    valid_ingredients.is_heat,
	valid_ingredients.created_at,
	valid_ingredients.last_updated_at,
	valid_ingredients.archived_at
FROM valid_ingredients
WHERE valid_ingredients.archived_at IS NULL
ORDER BY random() LIMIT 1
`

type GetRandomValidIngredientRow struct {
	ID                                      string
	Name                                    string
	Description                             string
	Warning                                 string
	ContainsEgg                             bool
	ContainsDairy                           bool
	ContainsPeanut                          bool
	ContainsTreeNut                         bool
	ContainsSoy                             bool
	ContainsWheat                           bool
	ContainsShellfish                       bool
	ContainsSesame                          bool
	ContainsFish                            bool
	ContainsGluten                          bool
	AnimalFlesh                             bool
	Volumetric                              bool
	IsLiquid                                sql.NullBool
	IconPath                                string
	AnimalDerived                           bool
	PluralName                              string
	RestrictToPreparations                  bool
	MinimumIdealStorageTemperatureInCelsius sql.NullString
	MaximumIdealStorageTemperatureInCelsius sql.NullString
	StorageInstructions                     string
	Slug                                    string
	ContainsAlcohol                         bool
	ShoppingSuggestions                     string
	IsStarch                                bool
	IsProtein                               bool
	IsGrain                                 bool
	IsFruit                                 bool
	IsSalt                                  bool
	IsFat                                   bool
	IsAcid                                  bool
	IsHeat                                  bool
	CreatedAt                               time.Time
	LastUpdatedAt                           sql.NullTime
	ArchivedAt                              sql.NullTime
}

func (q *Queries) GetRandomValidIngredient(ctx context.Context, db DBTX) (*GetRandomValidIngredientRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidIngredient)
	var i GetRandomValidIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.AnimalDerived,
		&i.PluralName,
		&i.RestrictToPreparations,
		&i.MinimumIdealStorageTemperatureInCelsius,
		&i.MaximumIdealStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.Slug,
		&i.ContainsAlcohol,
		&i.ShoppingSuggestions,
		&i.IsStarch,
		&i.IsProtein,
		&i.IsGrain,
		&i.IsFruit,
		&i.IsSalt,
		&i.IsFat,
		&i.IsAcid,
		&i.IsHeat,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRandomValidInstrument = `-- name: GetRandomValidInstrument :one

SELECT
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.plural_name,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.usable_for_storage,
	valid_instruments.display_in_summary_lists,
	valid_instruments.include_in_generated_instructions,
	valid_instruments.slug,
	valid_instruments.created_at,
	valid_instruments.last_updated_at,
	valid_instruments.archived_at
FROM valid_instruments
WHERE valid_instruments.archived_at IS NULL
	ORDER BY random() LIMIT 1
`

type GetRandomValidInstrumentRow struct {
	ID                             string
	Name                           string
	PluralName                     string
	Description                    string
	IconPath                       string
	UsableForStorage               bool
	DisplayInSummaryLists          bool
	IncludeInGeneratedInstructions bool
	Slug                           string
	CreatedAt                      time.Time
	LastUpdatedAt                  sql.NullTime
	ArchivedAt                     sql.NullTime
}

func (q *Queries) GetRandomValidInstrument(ctx context.Context, db DBTX) (*GetRandomValidInstrumentRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidInstrument)
	var i GetRandomValidInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.Slug,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRandomValidMeasurementUnit = `-- name: GetRandomValidMeasurementUnit :one

SELECT
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at
FROM valid_measurement_units
WHERE valid_measurement_units.archived_at IS NULL
	ORDER BY random() LIMIT 1
`

type GetRandomValidMeasurementUnitRow struct {
	ID            string
	Name          string
	Description   string
	Volumetric    sql.NullBool
	IconPath      string
	Universal     bool
	Metric        bool
	Imperial      bool
	Slug          string
	PluralName    string
	CreatedAt     time.Time
	LastUpdatedAt sql.NullTime
	ArchivedAt    sql.NullTime
}

func (q *Queries) GetRandomValidMeasurementUnit(ctx context.Context, db DBTX) (*GetRandomValidMeasurementUnitRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidMeasurementUnit)
	var i GetRandomValidMeasurementUnitRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Volumetric,
		&i.IconPath,
		&i.Universal,
		&i.Metric,
		&i.Imperial,
		&i.Slug,
		&i.PluralName,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRandomValidPreparation = `-- name: GetRandomValidPreparation :one

SELECT
	valid_preparations.id,
	valid_preparations.name,
	valid_preparations.description,
	valid_preparations.icon_path,
	valid_preparations.yields_nothing,
	valid_preparations.restrict_to_ingredients,
	valid_preparations.minimum_ingredient_count,
	valid_preparations.maximum_ingredient_count,
	valid_preparations.minimum_instrument_count,
	valid_preparations.maximum_instrument_count,
	valid_preparations.temperature_required,
	valid_preparations.time_estimate_required,
	valid_preparations.condition_expression_required,
    valid_preparations.consumes_vessel,
    valid_preparations.only_for_vessels,
    valid_preparations.minimum_vessel_count,
    valid_preparations.maximum_vessel_count,
	valid_preparations.slug,
	valid_preparations.past_tense,
	valid_preparations.created_at,
	valid_preparations.last_updated_at,
	valid_preparations.archived_at
FROM valid_preparations
WHERE valid_preparations.archived_at IS NULL
	ORDER BY random() LIMIT 1
`

type GetRandomValidPreparationRow struct {
	ID                          string
	Name                        string
	Description                 string
	IconPath                    string
	YieldsNothing               bool
	RestrictToIngredients       bool
	MinimumIngredientCount      int32
	MaximumIngredientCount      sql.NullInt32
	MinimumInstrumentCount      int32
	MaximumInstrumentCount      sql.NullInt32
	TemperatureRequired         bool
	TimeEstimateRequired        bool
	ConditionExpressionRequired bool
	ConsumesVessel              bool
	OnlyForVessels              bool
	MinimumVesselCount          int32
	MaximumVesselCount          sql.NullInt32
	Slug                        string
	PastTense                   string
	CreatedAt                   time.Time
	LastUpdatedAt               sql.NullTime
	ArchivedAt                  sql.NullTime
}

func (q *Queries) GetRandomValidPreparation(ctx context.Context, db DBTX) (*GetRandomValidPreparationRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidPreparation)
	var i GetRandomValidPreparationRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IconPath,
		&i.YieldsNothing,
		&i.RestrictToIngredients,
		&i.MinimumIngredientCount,
		&i.MaximumIngredientCount,
		&i.MinimumInstrumentCount,
		&i.MaximumInstrumentCount,
		&i.TemperatureRequired,
		&i.TimeEstimateRequired,
		&i.ConditionExpressionRequired,
		&i.ConsumesVessel,
		&i.OnlyForVessels,
		&i.MinimumVesselCount,
		&i.MaximumVesselCount,
		&i.Slug,
		&i.PastTense,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getRandomValidVessel = `-- name: GetRandomValidVessel :one

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	ORDER BY random() LIMIT 1
`

type GetRandomValidVesselRow struct {
	ID                                string
	Name                              string
	PluralName                        string
	Description                       string
	IconPath                          string
	UsableForStorage                  bool
	Slug                              string
	DisplayInSummaryLists             bool
	IncludeInGeneratedInstructions    bool
	ValidVesselsCapacity              float64
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	ValidMeasurementUnitDescription   string
	ValidMeasurementUnitVolumetric    sql.NullBool
	ValidMeasurementUnitIconPath      string
	ValidMeasurementUnitUniversal     bool
	ValidMeasurementUnitMetric        bool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitSlug          string
	ValidMeasurementUnitPluralName    string
	ValidMeasurementUnitCreatedAt     time.Time
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidVesselsWidthInMillimeters    float64
	ValidVesselsLengthInMillimeters   float64
	ValidVesselsHeightInMillimeters   float64
	Shape                             VesselShape
	CreatedAt                         time.Time
	LastUpdatedAt                     sql.NullTime
	ArchivedAt                        sql.NullTime
}

func (q *Queries) GetRandomValidVessel(ctx context.Context, db DBTX) (*GetRandomValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidVessel)
	var i GetRandomValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.ValidVesselsCapacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.ValidVesselsWidthInMillimeters,
		&i.ValidVesselsLengthInMillimeters,
		&i.ValidVesselsHeightInMillimeters,
		&i.Shape,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}
