// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: service_setting_configurations.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveServiceSettingConfiguration = `-- name: ArchiveServiceSettingConfiguration :exec

UPDATE service_setting_configurations SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveServiceSettingConfiguration(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, archiveServiceSettingConfiguration, id)
	return err
}

const checkServiceSettingConfigurationExistence = `-- name: CheckServiceSettingConfigurationExistence :one

SELECT EXISTS ( SELECT service_setting_configurations.id FROM service_setting_configurations WHERE service_setting_configurations.archived_at IS NULL AND service_setting_configurations.id = $1 )
`

func (q *Queries) CheckServiceSettingConfigurationExistence(ctx context.Context, db DBTX, id string) (bool, error) {
	row := db.QueryRowContext(ctx, checkServiceSettingConfigurationExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createServiceSettingConfiguration = `-- name: CreateServiceSettingConfiguration :exec

INSERT INTO service_setting_configurations (id,value,notes,service_setting_id,belongs_to_user,belongs_to_household) VALUES ($1,$2,$3,$4,$5,$6)
`

type CreateServiceSettingConfigurationParams struct {
	ID                 string
	Value              string
	Notes              string
	ServiceSettingID   string
	BelongsToUser      string
	BelongsToHousehold string
}

func (q *Queries) CreateServiceSettingConfiguration(ctx context.Context, db DBTX, arg *CreateServiceSettingConfigurationParams) error {
	_, err := db.ExecContext(ctx, createServiceSettingConfiguration,
		arg.ID,
		arg.Value,
		arg.Notes,
		arg.ServiceSettingID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
	)
	return err
}

const getServiceSettingConfigurationByID = `-- name: GetServiceSettingConfigurationByID :one

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.id = $1
`

type GetServiceSettingConfigurationByIDRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationByID(ctx context.Context, db DBTX, id string) (*GetServiceSettingConfigurationByIDRow, error) {
	row := db.QueryRowContext(ctx, getServiceSettingConfigurationByID, id)
	var i GetServiceSettingConfigurationByIDRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.Notes,
		&i.ID_2,
		&i.Name,
		&i.Type,
		&i.Description,
		&i.DefaultValue,
		&i.Enumeration,
		&i.AdminsOnly,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToUser,
		&i.BelongsToHousehold,
		&i.CreatedAt_2,
		&i.LastUpdatedAt_2,
		&i.ArchivedAt_2,
	)
	return &i, err
}

const getServiceSettingConfigurationsForHousehold = `-- name: GetServiceSettingConfigurationsForHousehold :many

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.belongs_to_household = $1
`

type GetServiceSettingConfigurationsForHouseholdRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationsForHousehold(ctx context.Context, db DBTX, belongsToHousehold string) ([]*GetServiceSettingConfigurationsForHouseholdRow, error) {
	rows, err := db.QueryContext(ctx, getServiceSettingConfigurationsForHousehold, belongsToHousehold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetServiceSettingConfigurationsForHouseholdRow{}
	for rows.Next() {
		var i GetServiceSettingConfigurationsForHouseholdRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Notes,
			&i.ID_2,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.DefaultValue,
			&i.Enumeration,
			&i.AdminsOnly,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceSettingConfigurationsForHouseholdBySettingName = `-- name: GetServiceSettingConfigurationsForHouseholdBySettingName :many

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_settings.name = $1
  AND service_setting_configurations.belongs_to_household = $2
`

type GetServiceSettingConfigurationsForHouseholdBySettingNameParams struct {
	Name               string
	BelongsToHousehold string
}

type GetServiceSettingConfigurationsForHouseholdBySettingNameRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationsForHouseholdBySettingName(ctx context.Context, db DBTX, arg *GetServiceSettingConfigurationsForHouseholdBySettingNameParams) ([]*GetServiceSettingConfigurationsForHouseholdBySettingNameRow, error) {
	rows, err := db.QueryContext(ctx, getServiceSettingConfigurationsForHouseholdBySettingName, arg.Name, arg.BelongsToHousehold)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetServiceSettingConfigurationsForHouseholdBySettingNameRow{}
	for rows.Next() {
		var i GetServiceSettingConfigurationsForHouseholdBySettingNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Notes,
			&i.ID_2,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.DefaultValue,
			&i.Enumeration,
			&i.AdminsOnly,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceSettingConfigurationsForUser = `-- name: GetServiceSettingConfigurationsForUser :many

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_setting_configurations.belongs_to_user = $1
`

type GetServiceSettingConfigurationsForUserRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationsForUser(ctx context.Context, db DBTX, belongsToUser string) ([]*GetServiceSettingConfigurationsForUserRow, error) {
	rows, err := db.QueryContext(ctx, getServiceSettingConfigurationsForUser, belongsToUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetServiceSettingConfigurationsForUserRow{}
	for rows.Next() {
		var i GetServiceSettingConfigurationsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Notes,
			&i.ID_2,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.DefaultValue,
			&i.Enumeration,
			&i.AdminsOnly,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServiceSettingConfigurationsForUserBySettingName = `-- name: GetServiceSettingConfigurationsForUserBySettingName :many

SELECT
	service_setting_configurations.id,
    service_setting_configurations.value,
    service_setting_configurations.notes,
	service_settings.id,
    service_settings.name,
    service_settings.type,
    service_settings.description,
    service_settings.default_value,
    service_settings.enumeration,
    service_settings.admins_only,
    service_settings.created_at,
    service_settings.last_updated_at,
    service_settings.archived_at,
    service_setting_configurations.belongs_to_user,
    service_setting_configurations.belongs_to_household,
    service_setting_configurations.created_at,
    service_setting_configurations.last_updated_at,
    service_setting_configurations.archived_at
FROM service_setting_configurations
 JOIN service_settings ON service_setting_configurations.service_setting_id=service_settings.id
WHERE service_settings.archived_at IS NULL
  AND service_setting_configurations.archived_at IS NULL
  AND service_settings.name = $1
  AND service_setting_configurations.belongs_to_user = $2
`

type GetServiceSettingConfigurationsForUserBySettingNameParams struct {
	Name          string
	BelongsToUser string
}

type GetServiceSettingConfigurationsForUserBySettingNameRow struct {
	CreatedAt          time.Time
	CreatedAt_2        time.Time
	ArchivedAt_2       sql.NullTime
	LastUpdatedAt_2    sql.NullTime
	ArchivedAt         sql.NullTime
	LastUpdatedAt      sql.NullTime
	Name               string
	Enumeration        string
	Description        string
	Type               SettingType
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	ID_2               string
	Notes              string
	Value              string
	DefaultValue       sql.NullString
	AdminsOnly         bool
}

func (q *Queries) GetServiceSettingConfigurationsForUserBySettingName(ctx context.Context, db DBTX, arg *GetServiceSettingConfigurationsForUserBySettingNameParams) ([]*GetServiceSettingConfigurationsForUserBySettingNameRow, error) {
	rows, err := db.QueryContext(ctx, getServiceSettingConfigurationsForUserBySettingName, arg.Name, arg.BelongsToUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetServiceSettingConfigurationsForUserBySettingNameRow{}
	for rows.Next() {
		var i GetServiceSettingConfigurationsForUserBySettingNameRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.Notes,
			&i.ID_2,
			&i.Name,
			&i.Type,
			&i.Description,
			&i.DefaultValue,
			&i.Enumeration,
			&i.AdminsOnly,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToUser,
			&i.BelongsToHousehold,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServiceSettingConfiguration = `-- name: UpdateServiceSettingConfiguration :exec

UPDATE service_setting_configurations
SET
    value = $1,
    notes = $2,
    service_setting_id = $3,
    belongs_to_user = $4,
    belongs_to_household = $5,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $6
`

type UpdateServiceSettingConfigurationParams struct {
	Value              string
	Notes              string
	ServiceSettingID   string
	BelongsToUser      string
	BelongsToHousehold string
	ID                 string
}

func (q *Queries) UpdateServiceSettingConfiguration(ctx context.Context, db DBTX, arg *UpdateServiceSettingConfigurationParams) error {
	_, err := db.ExecContext(ctx, updateServiceSettingConfiguration,
		arg.Value,
		arg.Notes,
		arg.ServiceSettingID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
		arg.ID,
	)
	return err
}
