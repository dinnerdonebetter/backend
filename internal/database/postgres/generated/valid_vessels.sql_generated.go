// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: valid_vessels.sql

package generated

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const archiveValidVessel = `-- name: ArchiveValidVessel :exec

UPDATE valid_vessels SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveValidVessel(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, archiveValidVessel, id)
	return err
}

const checkValidVesselExistence = `-- name: CheckValidVesselExistence :one

SELECT EXISTS ( SELECT valid_vessels.id FROM valid_vessels WHERE valid_vessels.archived_at IS NULL AND valid_vessels.id = $1 )
`

func (q *Queries) CheckValidVesselExistence(ctx context.Context, db DBTX, id string) (bool, error) {
	row := db.QueryRowContext(ctx, checkValidVesselExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createValidVessel = `-- name: CreateValidVessel :exec

INSERT INTO valid_vessels (id,"name",plural_name,description,icon_path,usable_for_storage,slug,display_in_summary_lists,include_in_generated_instructions,capacity,capacity_unit,width_in_millimeters,length_in_millimeters,height_in_millimeters,shape)
    VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10::float,$11,$12::float,$13::float,$14::float,$15)
`

type CreateValidVesselParams struct {
	Slug                           string
	ID                             string
	PluralName                     string
	Description                    string
	IconPath                       string
	Shape                          VesselShape
	Name                           string
	CapacityUnit                   sql.NullString
	Capacity                       float64
	WidthInMillimeters             float64
	LengthInMillimeters            float64
	HeightInMillimeters            float64
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) CreateValidVessel(ctx context.Context, db DBTX, arg *CreateValidVesselParams) error {
	_, err := db.ExecContext(ctx, createValidVessel,
		arg.ID,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.Slug,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Capacity,
		arg.CapacityUnit,
		arg.WidthInMillimeters,
		arg.LengthInMillimeters,
		arg.HeightInMillimeters,
		arg.Shape,
	)
	return err
}

const getRandomValidVessel = `-- name: GetRandomValidVessel :one

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	ORDER BY random() LIMIT 1
`

type GetRandomValidVesselRow struct {
	ValidMeasurementUnitCreatedAt     time.Time
	CreatedAt                         time.Time
	ArchivedAt                        sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitIconPath      string
	IconPath                          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	ValidMeasurementUnitDescription   string
	Description                       string
	ID                                string
	Shape                             VesselShape
	Slug                              string
	ValidMeasurementUnitPluralName    string
	ValidMeasurementUnitSlug          string
	ValidVesselsWidthInMillimeters    float64
	ValidVesselsLengthInMillimeters   float64
	ValidVesselsHeightInMillimeters   float64
	ValidVesselsCapacity              float64
	ValidMeasurementUnitVolumetric    sql.NullBool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	UsableForStorage                  bool
	DisplayInSummaryLists             bool
	ValidMeasurementUnitUniversal     bool
	IncludeInGeneratedInstructions    bool
}

func (q *Queries) GetRandomValidVessel(ctx context.Context, db DBTX) (*GetRandomValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getRandomValidVessel)
	var i GetRandomValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.ValidVesselsCapacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.ValidVesselsWidthInMillimeters,
		&i.ValidVesselsLengthInMillimeters,
		&i.ValidVesselsHeightInMillimeters,
		&i.Shape,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidVessel = `-- name: GetValidVessel :one

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
	AND valid_measurement_units.archived_at IS NULL
	AND valid_vessels.id = $1
`

type GetValidVesselRow struct {
	ValidMeasurementUnitCreatedAt     time.Time
	CreatedAt                         time.Time
	ArchivedAt                        sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitIconPath      string
	IconPath                          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	ValidMeasurementUnitDescription   string
	Description                       string
	ID                                string
	Shape                             VesselShape
	Slug                              string
	ValidMeasurementUnitPluralName    string
	ValidMeasurementUnitSlug          string
	ValidVesselsWidthInMillimeters    float64
	ValidVesselsLengthInMillimeters   float64
	ValidVesselsHeightInMillimeters   float64
	ValidVesselsCapacity              float64
	ValidMeasurementUnitVolumetric    sql.NullBool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	UsableForStorage                  bool
	DisplayInSummaryLists             bool
	ValidMeasurementUnitUniversal     bool
	IncludeInGeneratedInstructions    bool
}

func (q *Queries) GetValidVessel(ctx context.Context, db DBTX, id string) (*GetValidVesselRow, error) {
	row := db.QueryRowContext(ctx, getValidVessel, id)
	var i GetValidVesselRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.UsableForStorage,
		&i.Slug,
		&i.DisplayInSummaryLists,
		&i.IncludeInGeneratedInstructions,
		&i.ValidVesselsCapacity,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.ValidVesselsWidthInMillimeters,
		&i.ValidVesselsLengthInMillimeters,
		&i.ValidVesselsHeightInMillimeters,
		&i.Shape,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getValidVesselIDsNeedingIndexing = `-- name: GetValidVesselIDsNeedingIndexing :many

SELECT
	valid_vessels.id
FROM valid_vessels
	 JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE (valid_vessels.archived_at IS NULL AND valid_measurement_units.archived_at IS NULL)
   AND (
        (valid_vessels.last_indexed_at IS NULL)
        OR valid_vessels.last_indexed_at
            < now() - '24 hours'::INTERVAL
    )
`

func (q *Queries) GetValidVesselIDsNeedingIndexing(ctx context.Context, db DBTX) ([]string, error) {
	rows, err := db.QueryContext(ctx, getValidVesselIDsNeedingIndexing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVessels = `-- name: GetValidVessels :many

SELECT
  valid_vessels.id,
  valid_vessels.name,
  valid_vessels.plural_name,
  valid_vessels.description,
  valid_vessels.icon_path,
  valid_vessels.usable_for_storage,
  valid_vessels.slug,
  valid_vessels.display_in_summary_lists,
  valid_vessels.include_in_generated_instructions,
  valid_vessels.capacity::float,
  valid_vessels.capacity_unit,
  valid_vessels.width_in_millimeters::float,
  valid_vessels.length_in_millimeters::float,
  valid_vessels.height_in_millimeters::float,
  valid_vessels.shape,
  valid_vessels.created_at,
  valid_vessels.last_updated_at,
  valid_vessels.archived_at,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
      AND valid_vessels.created_at > COALESCE($1, (SELECT NOW() - interval '999 years'))
      AND valid_vessels.created_at < COALESCE($2, (SELECT NOW() + interval '999 years'))
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
      )
      AND (
        valid_vessels.last_updated_at IS NULL
        OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
      )
  ) as filtered_count,
  (
    SELECT
      COUNT(valid_vessels.id)
    FROM
      valid_vessels
    WHERE
      valid_vessels.archived_at IS NULL
  ) as total_count
FROM
  valid_vessels
WHERE
  valid_vessels.archived_at IS NULL
  AND valid_vessels.created_at > (COALESCE($1, (SELECT NOW() - interval '999 years')))
  AND valid_vessels.created_at < (COALESCE($2, (SELECT NOW() + interval '999 years')))
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at > COALESCE($3, (SELECT NOW() - interval '999 years'))
  )
  AND (
    valid_vessels.last_updated_at IS NULL
    OR valid_vessels.last_updated_at < COALESCE($4, (SELECT NOW() + interval '999 years'))
  )
GROUP BY
  valid_vessels.id
ORDER BY
  valid_vessels.id
OFFSET
    $5
LIMIT
    $6
`

type GetValidVesselsParams struct {
	CreatedAfter  sql.NullTime
	CreatedBefore sql.NullTime
	UpdatedAfter  sql.NullTime
	UpdatedBefore sql.NullTime
	QueryOffset   sql.NullInt32
	QueryLimit    sql.NullInt32
}

type GetValidVesselsRow struct {
	CreatedAt                       time.Time
	ArchivedAt                      sql.NullTime
	LastUpdatedAt                   sql.NullTime
	ID                              string
	Name                            string
	PluralName                      string
	Description                     string
	IconPath                        string
	Slug                            string
	Shape                           VesselShape
	CapacityUnit                    sql.NullString
	ValidVesselsWidthInMillimeters  float64
	ValidVesselsLengthInMillimeters float64
	ValidVesselsHeightInMillimeters float64
	ValidVesselsCapacity            float64
	FilteredCount                   int64
	TotalCount                      int64
	IncludeInGeneratedInstructions  bool
	DisplayInSummaryLists           bool
	UsableForStorage                bool
}

func (q *Queries) GetValidVessels(ctx context.Context, db DBTX, arg *GetValidVesselsParams) ([]*GetValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVessels,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.QueryOffset,
		arg.QueryLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsRow{}
	for rows.Next() {
		var i GetValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.ValidVesselsCapacity,
			&i.CapacityUnit,
			&i.ValidVesselsWidthInMillimeters,
			&i.ValidVesselsLengthInMillimeters,
			&i.ValidVesselsHeightInMillimeters,
			&i.Shape,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getValidVesselsWithIDs = `-- name: GetValidVesselsWithIDs :many

SELECT
    valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
    valid_measurement_units.id as valid_measurement_unit_id,
    valid_measurement_units.name as valid_measurement_unit_name,
    valid_measurement_units.description as valid_measurement_unit_description,
    valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
    valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
    valid_measurement_units.universal as valid_measurement_unit_universal,
    valid_measurement_units.metric as valid_measurement_unit_metric,
    valid_measurement_units.imperial as valid_measurement_unit_imperial,
    valid_measurement_units.slug as valid_measurement_unit_slug,
    valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
    valid_measurement_units.created_at as valid_measurement_unit_created_at,
    valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
    valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
    JOIN valid_measurement_units ON valid_vessels.capacity_unit=valid_measurement_units.id
WHERE valid_vessels.archived_at IS NULL
  AND valid_measurement_units.archived_at IS NULL
  AND valid_vessels.id = ANY($1::text[])
`

type GetValidVesselsWithIDsRow struct {
	ValidMeasurementUnitCreatedAt     time.Time
	CreatedAt                         time.Time
	ArchivedAt                        sql.NullTime
	LastUpdatedAt                     sql.NullTime
	ValidMeasurementUnitArchivedAt    sql.NullTime
	ValidMeasurementUnitLastUpdatedAt sql.NullTime
	ValidMeasurementUnitIconPath      string
	IconPath                          string
	Name                              string
	PluralName                        string
	ValidMeasurementUnitID            string
	ValidMeasurementUnitName          string
	ValidMeasurementUnitDescription   string
	Description                       string
	ID                                string
	Shape                             VesselShape
	Slug                              string
	ValidMeasurementUnitPluralName    string
	ValidMeasurementUnitSlug          string
	ValidVesselsWidthInMillimeters    float64
	ValidVesselsLengthInMillimeters   float64
	ValidVesselsHeightInMillimeters   float64
	ValidVesselsCapacity              float64
	ValidMeasurementUnitVolumetric    sql.NullBool
	ValidMeasurementUnitImperial      bool
	ValidMeasurementUnitMetric        bool
	UsableForStorage                  bool
	DisplayInSummaryLists             bool
	ValidMeasurementUnitUniversal     bool
	IncludeInGeneratedInstructions    bool
}

func (q *Queries) GetValidVesselsWithIDs(ctx context.Context, db DBTX, ids []string) ([]*GetValidVesselsWithIDsRow, error) {
	rows, err := db.QueryContext(ctx, getValidVesselsWithIDs, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetValidVesselsWithIDsRow{}
	for rows.Next() {
		var i GetValidVesselsWithIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.ValidVesselsCapacity,
			&i.ValidMeasurementUnitID,
			&i.ValidMeasurementUnitName,
			&i.ValidMeasurementUnitDescription,
			&i.ValidMeasurementUnitVolumetric,
			&i.ValidMeasurementUnitIconPath,
			&i.ValidMeasurementUnitUniversal,
			&i.ValidMeasurementUnitMetric,
			&i.ValidMeasurementUnitImperial,
			&i.ValidMeasurementUnitSlug,
			&i.ValidMeasurementUnitPluralName,
			&i.ValidMeasurementUnitCreatedAt,
			&i.ValidMeasurementUnitLastUpdatedAt,
			&i.ValidMeasurementUnitArchivedAt,
			&i.ValidVesselsWidthInMillimeters,
			&i.ValidVesselsLengthInMillimeters,
			&i.ValidVesselsHeightInMillimeters,
			&i.Shape,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchForValidVessels = `-- name: SearchForValidVessels :many

SELECT
	valid_vessels.id,
    valid_vessels.name,
    valid_vessels.plural_name,
    valid_vessels.description,
    valid_vessels.icon_path,
    valid_vessels.usable_for_storage,
    valid_vessels.slug,
    valid_vessels.display_in_summary_lists,
    valid_vessels.include_in_generated_instructions,
    valid_vessels.capacity::float,
    valid_vessels.capacity_unit,
    valid_vessels.width_in_millimeters::float,
    valid_vessels.length_in_millimeters::float,
    valid_vessels.height_in_millimeters::float,
    valid_vessels.shape,
    valid_vessels.created_at,
    valid_vessels.last_updated_at,
    valid_vessels.archived_at
FROM valid_vessels
WHERE valid_vessels.archived_at IS NULL
    AND valid_vessels.name ILIKE '%' || $1::text || '%'
	LIMIT 50
`

type SearchForValidVesselsRow struct {
	CreatedAt                       time.Time
	ArchivedAt                      sql.NullTime
	LastUpdatedAt                   sql.NullTime
	ID                              string
	Name                            string
	PluralName                      string
	Description                     string
	IconPath                        string
	Slug                            string
	Shape                           VesselShape
	CapacityUnit                    sql.NullString
	ValidVesselsLengthInMillimeters float64
	ValidVesselsWidthInMillimeters  float64
	ValidVesselsHeightInMillimeters float64
	ValidVesselsCapacity            float64
	IncludeInGeneratedInstructions  bool
	DisplayInSummaryLists           bool
	UsableForStorage                bool
}

func (q *Queries) SearchForValidVessels(ctx context.Context, db DBTX, query string) ([]*SearchForValidVesselsRow, error) {
	rows, err := db.QueryContext(ctx, searchForValidVessels, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchForValidVesselsRow{}
	for rows.Next() {
		var i SearchForValidVesselsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.UsableForStorage,
			&i.Slug,
			&i.DisplayInSummaryLists,
			&i.IncludeInGeneratedInstructions,
			&i.ValidVesselsCapacity,
			&i.CapacityUnit,
			&i.ValidVesselsWidthInMillimeters,
			&i.ValidVesselsLengthInMillimeters,
			&i.ValidVesselsHeightInMillimeters,
			&i.Shape,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateValidVessel = `-- name: UpdateValidVessel :exec

UPDATE valid_vessels
SET
    name = $1,
    plural_name = $2,
    description = $3,
    icon_path = $4,
    usable_for_storage = $5,
    slug = $6,
    display_in_summary_lists = $7,
    include_in_generated_instructions = $8,
    capacity = $9::float,
    capacity_unit = $10,
    width_in_millimeters = $11::float,
    length_in_millimeters = $12::float,
    height_in_millimeters = $13::float,
    shape = $14,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $15
`

type UpdateValidVesselParams struct {
	Name                           string
	PluralName                     string
	Description                    string
	IconPath                       string
	ID                             string
	Slug                           string
	Shape                          VesselShape
	CapacityUnit                   sql.NullString
	Capacity                       float64
	WidthInMillimeters             float64
	LengthInMillimeters            float64
	HeightInMillimeters            float64
	IncludeInGeneratedInstructions bool
	DisplayInSummaryLists          bool
	UsableForStorage               bool
}

func (q *Queries) UpdateValidVessel(ctx context.Context, db DBTX, arg *UpdateValidVesselParams) error {
	_, err := db.ExecContext(ctx, updateValidVessel,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.UsableForStorage,
		arg.Slug,
		arg.DisplayInSummaryLists,
		arg.IncludeInGeneratedInstructions,
		arg.Capacity,
		arg.CapacityUnit,
		arg.WidthInMillimeters,
		arg.LengthInMillimeters,
		arg.HeightInMillimeters,
		arg.Shape,
		arg.ID,
	)
	return err
}

const updateValidVesselLastIndexedAt = `-- name: UpdateValidVesselLastIndexedAt :exec

UPDATE valid_vessels SET last_indexed_at = NOW() WHERE id = $1 AND archived_at IS NULL
`

func (q *Queries) UpdateValidVesselLastIndexedAt(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, updateValidVesselLastIndexedAt, id)
	return err
}
