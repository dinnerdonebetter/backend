// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: households.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const addToHouseholdDuringCreation = `-- name: AddToHouseholdDuringCreation :exec

INSERT INTO household_user_memberships (id,belongs_to_user,belongs_to_household,household_role)
VALUES ($1,$2,$3,$4)
`

type AddToHouseholdDuringCreationParams struct {
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	HouseholdRole      string
}

func (q *Queries) AddToHouseholdDuringCreation(ctx context.Context, db DBTX, arg *AddToHouseholdDuringCreationParams) error {
	_, err := db.ExecContext(ctx, addToHouseholdDuringCreation,
		arg.ID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
		arg.HouseholdRole,
	)
	return err
}

const archiveHousehold = `-- name: ArchiveHousehold :exec

UPDATE households SET last_updated_at = NOW(), archived_at = NOW() WHERE archived_at IS NULL AND belongs_to_user = $1 AND id = $2
`

type ArchiveHouseholdParams struct {
	BelongsToUser string
	ID            string
}

func (q *Queries) ArchiveHousehold(ctx context.Context, db DBTX, arg *ArchiveHouseholdParams) error {
	_, err := db.ExecContext(ctx, archiveHousehold, arg.BelongsToUser, arg.ID)
	return err
}

const createHousehold = `-- name: CreateHousehold :exec

INSERT INTO households (id,"name",billing_status,contact_phone,address_line_1,address_line_2,city,state,zip_code,country,latitude,longitude,belongs_to_user) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13)
`

type CreateHouseholdParams struct {
	City          string
	Name          string
	BillingStatus string
	ContactPhone  string
	AddressLine1  string
	AddressLine2  string
	ID            string
	State         string
	ZipCode       string
	Country       string
	BelongsToUser string
	Latitude      sql.NullString
	Longitude     sql.NullString
}

func (q *Queries) CreateHousehold(ctx context.Context, db DBTX, arg *CreateHouseholdParams) error {
	_, err := db.ExecContext(ctx, createHousehold,
		arg.ID,
		arg.Name,
		arg.BillingStatus,
		arg.ContactPhone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.BelongsToUser,
	)
	return err
}

const getHouseholdByIDWithMemberships = `-- name: GetHouseholdByIDWithMemberships :many

SELECT
	households.id,
	households.name,
	households.billing_status,
	households.contact_phone,
	households.address_line_1,
	households.address_line_2,
	households.city,
	households.state,
	households.zip_code,
	households.country,
	households.latitude,
    households.longitude,
	households.payment_processor_customer_id,
	households.subscription_plan_id,
	households.created_at,
	households.last_updated_at,
	households.archived_at,
	households.belongs_to_user,
	users.id,
	users.first_name,
	users.last_name,
	users.username,
	users.email_address,
	users.email_address_verified_at,
	users.avatar_src,
	users.requires_password_change,
	users.password_last_changed_at,
	users.two_factor_secret_verified_at,
	users.service_role,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birthday,
	users.created_at,
	users.last_updated_at,
	users.archived_at,
	household_user_memberships.id,
	household_user_memberships.belongs_to_user,
	household_user_memberships.belongs_to_household,
	household_user_memberships.household_role,
	household_user_memberships.default_household,
	household_user_memberships.created_at,
	household_user_memberships.last_updated_at,
	household_user_memberships.archived_at
FROM households
	JOIN household_user_memberships ON household_user_memberships.belongs_to_household = households.id
	JOIN users ON household_user_memberships.belongs_to_user = users.id
WHERE households.archived_at IS NULL
	AND household_user_memberships.archived_at IS NULL
	AND households.id = $1
`

type GetHouseholdByIDWithMembershipsRow struct {
	CreatedAt_2                  time.Time
	CreatedAt_3                  time.Time
	CreatedAt                    time.Time
	ArchivedAt_3                 sql.NullTime
	LastUpdatedAt_3              sql.NullTime
	ArchivedAt_2                 sql.NullTime
	LastUpdatedAt_2              sql.NullTime
	Birthday                     sql.NullTime
	TwoFactorSecretVerifiedAt    sql.NullTime
	PasswordLastChangedAt        sql.NullTime
	EmailAddressVerifiedAt       sql.NullTime
	ArchivedAt                   sql.NullTime
	LastUpdatedAt                sql.NullTime
	UserAccountStatusExplanation string
	ServiceRole                  string
	PaymentProcessorCustomerID   string
	Name                         string
	BelongsToUser                string
	ID_2                         string
	FirstName                    string
	LastName                     string
	Username                     string
	EmailAddress                 string
	BillingStatus                string
	ContactPhone                 string
	HouseholdRole                string
	Country                      string
	ZipCode                      string
	BelongsToHousehold           string
	UserAccountStatus            string
	ID                           string
	State                        string
	City                         string
	AddressLine2                 string
	AddressLine1                 string
	ID_3                         string
	BelongsToUser_2              string
	SubscriptionPlanID           sql.NullString
	AvatarSrc                    sql.NullString
	Latitude                     sql.NullString
	Longitude                    sql.NullString
	RequiresPasswordChange       bool
	DefaultHousehold             bool
}

func (q *Queries) GetHouseholdByIDWithMemberships(ctx context.Context, db DBTX, id string) ([]*GetHouseholdByIDWithMembershipsRow, error) {
	rows, err := db.QueryContext(ctx, getHouseholdByIDWithMemberships, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetHouseholdByIDWithMembershipsRow{}
	for rows.Next() {
		var i GetHouseholdByIDWithMembershipsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.BillingStatus,
			&i.ContactPhone,
			&i.AddressLine1,
			&i.AddressLine2,
			&i.City,
			&i.State,
			&i.ZipCode,
			&i.Country,
			&i.Latitude,
			&i.Longitude,
			&i.PaymentProcessorCustomerID,
			&i.SubscriptionPlanID,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.BelongsToUser,
			&i.ID_2,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.EmailAddress,
			&i.EmailAddressVerifiedAt,
			&i.AvatarSrc,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedAt,
			&i.TwoFactorSecretVerifiedAt,
			&i.ServiceRole,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.Birthday,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.ID_3,
			&i.BelongsToUser_2,
			&i.BelongsToHousehold,
			&i.HouseholdRole,
			&i.DefaultHousehold,
			&i.CreatedAt_3,
			&i.LastUpdatedAt_3,
			&i.ArchivedAt_3,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateHousehold = `-- name: UpdateHousehold :exec

UPDATE households
SET
	name = $1,
	contact_phone = $2,
	address_line_1 = $3,
	address_line_2 = $4,
	city = $5,
	state = $6,
	zip_code = $7,
	country = $8,
	latitude = $9,
    longitude = $10,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_user = $11
	AND id = $12
`

type UpdateHouseholdParams struct {
	Name          string
	ContactPhone  string
	AddressLine1  string
	AddressLine2  string
	City          string
	State         string
	ZipCode       string
	Country       string
	BelongsToUser string
	ID            string
	Latitude      sql.NullString
	Longitude     sql.NullString
}

func (q *Queries) UpdateHousehold(ctx context.Context, db DBTX, arg *UpdateHouseholdParams) error {
	_, err := db.ExecContext(ctx, updateHousehold,
		arg.Name,
		arg.ContactPhone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Country,
		arg.Latitude,
		arg.Longitude,
		arg.BelongsToUser,
		arg.ID,
	)
	return err
}
