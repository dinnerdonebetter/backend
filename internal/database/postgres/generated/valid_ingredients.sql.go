// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: valid_ingredients.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveValidIngredient = `-- name: ArchiveValidIngredient :exec
UPDATE valid_ingredients SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND id = $1
`

func (q *Queries) ArchiveValidIngredient(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, ArchiveValidIngredient, id)
	return err
}

const CreateValidIngredient = `-- name: CreateValidIngredient :exec
INSERT INTO valid_ingredients (id,name,description,warning,contains_egg,contains_dairy,contains_peanut,contains_tree_nut,contains_soy,contains_wheat,contains_shellfish,contains_sesame,contains_fish,contains_gluten,animal_flesh,volumetric,is_liquid,icon_path) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18)
`

type CreateValidIngredientParams struct {
	ID                string
	Name              string
	Description       string
	Warning           string
	ContainsEgg       bool
	ContainsDairy     bool
	ContainsPeanut    bool
	ContainsTreeNut   bool
	ContainsSoy       bool
	ContainsWheat     bool
	ContainsShellfish bool
	ContainsSesame    bool
	ContainsFish      bool
	ContainsGluten    bool
	AnimalFlesh       bool
	Volumetric        bool
	IsLiquid          sql.NullBool
	IconPath          string
}

func (q *Queries) CreateValidIngredient(ctx context.Context, arg *CreateValidIngredientParams) error {
	_, err := q.db.ExecContext(ctx, CreateValidIngredient,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Warning,
		arg.ContainsEgg,
		arg.ContainsDairy,
		arg.ContainsPeanut,
		arg.ContainsTreeNut,
		arg.ContainsSoy,
		arg.ContainsWheat,
		arg.ContainsShellfish,
		arg.ContainsSesame,
		arg.ContainsFish,
		arg.ContainsGluten,
		arg.AnimalFlesh,
		arg.Volumetric,
		arg.IsLiquid,
		arg.IconPath,
	)
	return err
}

const GetRandomValidIngredient = `-- name: GetRandomValidIngredient :one
SELECT
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.created_on,
    valid_ingredients.last_updated_on,
    valid_ingredients.archived_on
FROM valid_ingredients
WHERE valid_ingredients.archived_on IS NULL
ORDER BY random() LIMIT 1
`

type GetRandomValidIngredientRow struct {
	ID                string
	Name              string
	Description       string
	Warning           string
	ContainsEgg       bool
	ContainsDairy     bool
	ContainsPeanut    bool
	ContainsTreeNut   bool
	ContainsSoy       bool
	ContainsWheat     bool
	ContainsShellfish bool
	ContainsSesame    bool
	ContainsFish      bool
	ContainsGluten    bool
	AnimalFlesh       bool
	Volumetric        bool
	IsLiquid          sql.NullBool
	IconPath          string
	CreatedOn         int64
	LastUpdatedOn     sql.NullInt64
	ArchivedOn        sql.NullInt64
}

func (q *Queries) GetRandomValidIngredient(ctx context.Context) (*GetRandomValidIngredientRow, error) {
	row := q.db.QueryRowContext(ctx, GetRandomValidIngredient)
	var i GetRandomValidIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetTotalValidIngredientCount = `-- name: GetTotalValidIngredientCount :one
SELECT COUNT(valid_ingredients.id) FROM valid_ingredients WHERE valid_ingredients.archived_on IS NULL
`

func (q *Queries) GetTotalValidIngredientCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalValidIngredientCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetValidIngredient = `-- name: GetValidIngredient :one
SELECT
    valid_ingredients.id,
    valid_ingredients.name,
    valid_ingredients.description,
    valid_ingredients.warning,
    valid_ingredients.contains_egg,
    valid_ingredients.contains_dairy,
    valid_ingredients.contains_peanut,
    valid_ingredients.contains_tree_nut,
    valid_ingredients.contains_soy,
    valid_ingredients.contains_wheat,
    valid_ingredients.contains_shellfish,
    valid_ingredients.contains_sesame,
    valid_ingredients.contains_fish,
    valid_ingredients.contains_gluten,
    valid_ingredients.animal_flesh,
    valid_ingredients.volumetric,
    valid_ingredients.is_liquid,
    valid_ingredients.icon_path,
    valid_ingredients.created_on,
    valid_ingredients.last_updated_on,
    valid_ingredients.archived_on
FROM valid_ingredients
WHERE valid_ingredients.archived_on IS NULL
  AND valid_ingredients.id = $1
`

type GetValidIngredientRow struct {
	ID                string
	Name              string
	Description       string
	Warning           string
	ContainsEgg       bool
	ContainsDairy     bool
	ContainsPeanut    bool
	ContainsTreeNut   bool
	ContainsSoy       bool
	ContainsWheat     bool
	ContainsShellfish bool
	ContainsSesame    bool
	ContainsFish      bool
	ContainsGluten    bool
	AnimalFlesh       bool
	Volumetric        bool
	IsLiquid          sql.NullBool
	IconPath          string
	CreatedOn         int64
	LastUpdatedOn     sql.NullInt64
	ArchivedOn        sql.NullInt64
}

func (q *Queries) GetValidIngredient(ctx context.Context, id string) (*GetValidIngredientRow, error) {
	row := q.db.QueryRowContext(ctx, GetValidIngredient, id)
	var i GetValidIngredientRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Warning,
		&i.ContainsEgg,
		&i.ContainsDairy,
		&i.ContainsPeanut,
		&i.ContainsTreeNut,
		&i.ContainsSoy,
		&i.ContainsWheat,
		&i.ContainsShellfish,
		&i.ContainsSesame,
		&i.ContainsFish,
		&i.ContainsGluten,
		&i.AnimalFlesh,
		&i.Volumetric,
		&i.IsLiquid,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const SearchForValidIngredients = `-- name: SearchForValidIngredients :many
SELECT valid_ingredients.id, valid_ingredients.name, valid_ingredients.description, valid_ingredients.warning, valid_ingredients.contains_egg, valid_ingredients.contains_dairy, valid_ingredients.contains_peanut, valid_ingredients.contains_tree_nut, valid_ingredients.contains_soy, valid_ingredients.contains_wheat, valid_ingredients.contains_shellfish, valid_ingredients.contains_sesame, valid_ingredients.contains_fish, valid_ingredients.contains_gluten, valid_ingredients.animal_flesh, valid_ingredients.volumetric, valid_ingredients.is_liquid, valid_ingredients.icon_path, valid_ingredients.created_on, valid_ingredients.last_updated_on, valid_ingredients.archived_on FROM valid_ingredients WHERE valid_ingredients.name ILIKE $1 AND valid_ingredients.archived_on IS NULL LIMIT 50
`

type SearchForValidIngredientsRow struct {
	ID                string
	Name              string
	Description       string
	Warning           string
	ContainsEgg       bool
	ContainsDairy     bool
	ContainsPeanut    bool
	ContainsTreeNut   bool
	ContainsSoy       bool
	ContainsWheat     bool
	ContainsShellfish bool
	ContainsSesame    bool
	ContainsFish      bool
	ContainsGluten    bool
	AnimalFlesh       bool
	Volumetric        bool
	IsLiquid          sql.NullBool
	IconPath          string
	CreatedOn         int64
	LastUpdatedOn     sql.NullInt64
	ArchivedOn        sql.NullInt64
}

func (q *Queries) SearchForValidIngredients(ctx context.Context, name string) ([]*SearchForValidIngredientsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchForValidIngredients, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchForValidIngredientsRow
	for rows.Next() {
		var i SearchForValidIngredientsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Warning,
			&i.ContainsEgg,
			&i.ContainsDairy,
			&i.ContainsPeanut,
			&i.ContainsTreeNut,
			&i.ContainsSoy,
			&i.ContainsWheat,
			&i.ContainsShellfish,
			&i.ContainsSesame,
			&i.ContainsFish,
			&i.ContainsGluten,
			&i.AnimalFlesh,
			&i.Volumetric,
			&i.IsLiquid,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateValidIngredient = `-- name: UpdateValidIngredient :exec
UPDATE valid_ingredients
SET
    name = $1,
    description = $2,
    warning = $3,
    contains_egg = $4,
    contains_dairy = $5,
    contains_peanut = $6,
    contains_tree_nut = $7,
    contains_soy = $8,
    contains_wheat = $9,
    contains_shellfish = $10,
    contains_sesame = $11,
    contains_fish = $12,
    contains_gluten = $13,
    animal_flesh = $14,
    volumetric = $15,
    is_liquid = $16,
    icon_path = $17,
    last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL AND id = $18
`

type UpdateValidIngredientParams struct {
	Name              string
	Description       string
	Warning           string
	ContainsEgg       bool
	ContainsDairy     bool
	ContainsPeanut    bool
	ContainsTreeNut   bool
	ContainsSoy       bool
	ContainsWheat     bool
	ContainsShellfish bool
	ContainsSesame    bool
	ContainsFish      bool
	ContainsGluten    bool
	AnimalFlesh       bool
	Volumetric        bool
	IsLiquid          sql.NullBool
	IconPath          string
	ID                string
}

func (q *Queries) UpdateValidIngredient(ctx context.Context, arg *UpdateValidIngredientParams) error {
	_, err := q.db.ExecContext(ctx, UpdateValidIngredient,
		arg.Name,
		arg.Description,
		arg.Warning,
		arg.ContainsEgg,
		arg.ContainsDairy,
		arg.ContainsPeanut,
		arg.ContainsTreeNut,
		arg.ContainsSoy,
		arg.ContainsWheat,
		arg.ContainsShellfish,
		arg.ContainsSesame,
		arg.ContainsFish,
		arg.ContainsGluten,
		arg.AnimalFlesh,
		arg.Volumetric,
		arg.IsLiquid,
		arg.IconPath,
		arg.ID,
	)
	return err
}

const ValidIngredientExists = `-- name: ValidIngredientExists :one
SELECT EXISTS ( SELECT valid_ingredients.id FROM valid_ingredients WHERE valid_ingredients.archived_on IS NULL AND valid_ingredients.id = $1 )
`

func (q *Queries) ValidIngredientExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, ValidIngredientExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
