// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: valid_instruments.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveValidInstrument = `-- name: ArchiveValidInstrument :exec
UPDATE valid_instruments SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND id = $1
`

func (q *Queries) ArchiveValidInstrument(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, ArchiveValidInstrument, id)
	return err
}

const CreateValidInstrument = `-- name: CreateValidInstrument :exec
INSERT INTO valid_instruments (id,name,plural_name,description,icon_path) VALUES ($1,$2,$3,$4,$5)
`

type CreateValidInstrumentParams struct {
	ID          string
	Name        string
	PluralName  string
	Description string
	IconPath    string
}

func (q *Queries) CreateValidInstrument(ctx context.Context, arg *CreateValidInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, CreateValidInstrument,
		arg.ID,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
	)
	return err
}

const GetRandomValidInstrument = `-- name: GetRandomValidInstrument :one
SELECT
    valid_instruments.id,
    valid_instruments.name,
    valid_instruments.plural_name,
    valid_instruments.description,
    valid_instruments.icon_path,
    valid_instruments.created_on,
    valid_instruments.last_updated_on,
    valid_instruments.archived_on
FROM valid_instruments
WHERE valid_instruments.archived_on IS NULL
ORDER BY random() LIMIT 1
`

type GetRandomValidInstrumentRow struct {
	ID            string
	Name          string
	PluralName    string
	Description   string
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) GetRandomValidInstrument(ctx context.Context) (*GetRandomValidInstrumentRow, error) {
	row := q.db.QueryRowContext(ctx, GetRandomValidInstrument)
	var i GetRandomValidInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetTotalValidInstrumentCount = `-- name: GetTotalValidInstrumentCount :one
SELECT COUNT(valid_instruments.id) FROM valid_instruments WHERE valid_instruments.archived_on IS NULL
`

func (q *Queries) GetTotalValidInstrumentCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalValidInstrumentCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetValidInstrument = `-- name: GetValidInstrument :one
SELECT
    valid_instruments.id,
    valid_instruments.name,
    valid_instruments.plural_name,
    valid_instruments.description,
    valid_instruments.icon_path,
    valid_instruments.created_on,
    valid_instruments.last_updated_on,
    valid_instruments.archived_on
FROM valid_instruments
WHERE valid_instruments.archived_on IS NULL
  AND valid_instruments.id = $1
`

type GetValidInstrumentRow struct {
	ID            string
	Name          string
	PluralName    string
	Description   string
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) GetValidInstrument(ctx context.Context, id string) (*GetValidInstrumentRow, error) {
	row := q.db.QueryRowContext(ctx, GetValidInstrument, id)
	var i GetValidInstrumentRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PluralName,
		&i.Description,
		&i.IconPath,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetValidInstruments = `-- name: GetValidInstruments :many
SELECT
    valid_instruments.id,
    valid_instruments.name,
    valid_instruments.plural_name,
    valid_instruments.description,
    valid_instruments.icon_path,
    valid_instruments.created_on,
    valid_instruments.last_updated_on,
    valid_instruments.archived_on,
    (
        SELECT
            COUNT(valid_instruments.id)
        FROM
            valid_instruments
        WHERE
            valid_instruments.archived_on IS NULL
          AND valid_instruments.created_on > COALESCE($1, 0)
          AND valid_instruments.created_on < COALESCE($2, (SELECT ~(1::bigint<<63)))
          AND (valid_instruments.last_updated_on IS NULL OR valid_instruments.last_updated_on > COALESCE($3, 0))
          AND (valid_instruments.last_updated_on IS NULL OR valid_instruments.last_updated_on < COALESCE($4, (SELECT ~(1::bigint<<63))))
    ) as filtered_count,
    (
        SELECT
            COUNT(valid_instruments.id)
        FROM
            valid_instruments
        WHERE
            valid_instruments.archived_on IS NULL
    ) as total_count
FROM
    valid_instruments
WHERE
    valid_instruments.archived_on IS NULL
  AND valid_instruments.created_on > COALESCE($1, 0)
  AND valid_instruments.created_on < COALESCE($2, (SELECT ~(1::bigint<<63)))
  AND (valid_instruments.last_updated_on IS NULL OR valid_instruments.last_updated_on > COALESCE($3, 0))
  AND (valid_instruments.last_updated_on IS NULL OR valid_instruments.last_updated_on < COALESCE($4, (SELECT ~(1::bigint<<63))))
GROUP BY
    valid_instruments.id
ORDER BY
    valid_instruments.id
    LIMIT $5
`

type GetValidInstrumentsParams struct {
	CreatedAfter  sql.NullInt64
	CreatedBefore sql.NullInt64
	UpdatedAfter  sql.NullInt64
	UpdatedBefore sql.NullInt64
	Limit         sql.NullInt32
}

type GetValidInstrumentsRow struct {
	ID            string
	Name          string
	PluralName    string
	Description   string
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
	FilteredCount int64
	TotalCount    int64
}

func (q *Queries) GetValidInstruments(ctx context.Context, arg *GetValidInstrumentsParams) ([]*GetValidInstrumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, GetValidInstruments,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.UpdatedAfter,
		arg.UpdatedBefore,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetValidInstrumentsRow
	for rows.Next() {
		var i GetValidInstrumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.FilteredCount,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SearchForValidInstruments = `-- name: SearchForValidInstruments :many
SELECT
    valid_instruments.id,
    valid_instruments.name,
    valid_instruments.plural_name,
    valid_instruments.description,
    valid_instruments.icon_path,
    valid_instruments.created_on,
    valid_instruments.last_updated_on,
    valid_instruments.archived_on
FROM valid_instruments
WHERE valid_instruments.archived_on IS NULL
  AND valid_instruments.name ILIKE $1
  LIMIT 50
`

type SearchForValidInstrumentsRow struct {
	ID            string
	Name          string
	PluralName    string
	Description   string
	IconPath      string
	CreatedOn     int64
	LastUpdatedOn sql.NullInt64
	ArchivedOn    sql.NullInt64
}

func (q *Queries) SearchForValidInstruments(ctx context.Context, name string) ([]*SearchForValidInstrumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchForValidInstruments, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchForValidInstrumentsRow
	for rows.Next() {
		var i SearchForValidInstrumentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PluralName,
			&i.Description,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateValidInstrument = `-- name: UpdateValidInstrument :exec
UPDATE valid_instruments SET name = $1, plural_name = $2, description = $3, icon_path = $4, last_updated_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND id = $5
`

type UpdateValidInstrumentParams struct {
	Name        string
	PluralName  string
	Description string
	IconPath    string
	ID          string
}

func (q *Queries) UpdateValidInstrument(ctx context.Context, arg *UpdateValidInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, UpdateValidInstrument,
		arg.Name,
		arg.PluralName,
		arg.Description,
		arg.IconPath,
		arg.ID,
	)
	return err
}

const ValidInstrumentExists = `-- name: ValidInstrumentExists :one
SELECT EXISTS ( SELECT valid_instruments.id FROM valid_instruments WHERE valid_instruments.archived_on IS NULL AND valid_instruments.id = $1 )
`

func (q *Queries) ValidInstrumentExists(ctx context.Context, id string) (bool, error) {
	row := q.db.QueryRowContext(ctx, ValidInstrumentExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
