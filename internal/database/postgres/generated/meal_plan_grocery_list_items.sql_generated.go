// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: meal_plan_grocery_list_items.sql

package generated

import (
	"context"
	"database/sql"
)

const archiveMealPlanGroceryListItem = `-- name: ArchiveMealPlanGroceryListItem :exec

UPDATE meal_plan_grocery_list_items SET archived_at = NOW() WHERE archived_at IS NULL AND id = $1
`

func (q *Queries) ArchiveMealPlanGroceryListItem(ctx context.Context, db DBTX, id string) error {
	_, err := db.ExecContext(ctx, archiveMealPlanGroceryListItem, id)
	return err
}

const checkMealPlanGroceryListItemExistence = `-- name: CheckMealPlanGroceryListItemExistence :one

SELECT EXISTS ( SELECT meal_plan_grocery_list_items.id FROM meal_plan_grocery_list_items WHERE meal_plan_grocery_list_items.archived_at IS NULL AND meal_plan_grocery_list_items.id = $1 AND meal_plan_grocery_list_items.belongs_to_meal_plan = $2 )
`

type CheckMealPlanGroceryListItemExistenceParams struct {
	MealPlanGroceryListItemID string
	MealPlanID                string
}

func (q *Queries) CheckMealPlanGroceryListItemExistence(ctx context.Context, db DBTX, arg *CheckMealPlanGroceryListItemExistenceParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkMealPlanGroceryListItemExistence, arg.MealPlanGroceryListItemID, arg.MealPlanID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createMealPlanGroceryListItem = `-- name: CreateMealPlanGroceryListItem :exec

INSERT INTO meal_plan_grocery_list_items
(id,belongs_to_meal_plan,valid_ingredient,valid_measurement_unit,minimum_quantity_needed,maximum_quantity_needed,quantity_purchased,purchased_measurement_unit,purchased_upc,purchase_price,status_explanation,status)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
`

type CreateMealPlanGroceryListItemParams struct {
	ID                       string
	BelongsToMealPlan        string
	ValidIngredient          string
	ValidMeasurementUnit     string
	MinimumQuantityNeeded    string
	StatusExplanation        string
	Status                   GroceryListItemStatus
	MaximumQuantityNeeded    sql.NullString
	QuantityPurchased        sql.NullString
	PurchasedMeasurementUnit sql.NullString
	PurchasedUpc             sql.NullString
	PurchasePrice            sql.NullString
}

func (q *Queries) CreateMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *CreateMealPlanGroceryListItemParams) error {
	_, err := db.ExecContext(ctx, createMealPlanGroceryListItem,
		arg.ID,
		arg.BelongsToMealPlan,
		arg.ValidIngredient,
		arg.ValidMeasurementUnit,
		arg.MinimumQuantityNeeded,
		arg.MaximumQuantityNeeded,
		arg.QuantityPurchased,
		arg.PurchasedMeasurementUnit,
		arg.PurchasedUpc,
		arg.PurchasePrice,
		arg.StatusExplanation,
		arg.Status,
	)
	return err
}

const getMealPlanGroceryListItem = `-- name: GetMealPlanGroceryListItem :one

SELECT
	meal_plan_grocery_list_items.id,
	meal_plan_grocery_list_items.belongs_to_meal_plan,
	meal_plan_grocery_list_items.valid_ingredient,
	meal_plan_grocery_list_items.valid_measurement_unit,
	meal_plan_grocery_list_items.minimum_quantity_needed,
	meal_plan_grocery_list_items.maximum_quantity_needed,
	meal_plan_grocery_list_items.quantity_purchased,
	meal_plan_grocery_list_items.purchased_measurement_unit,
	meal_plan_grocery_list_items.purchased_upc,
	meal_plan_grocery_list_items.purchase_price,
	meal_plan_grocery_list_items.status_explanation,
	meal_plan_grocery_list_items.status,
	meal_plan_grocery_list_items.created_at,
	meal_plan_grocery_list_items.last_updated_at,
	meal_plan_grocery_list_items.archived_at
FROM meal_plan_grocery_list_items
	FULL OUTER JOIN meal_plans ON meal_plan_grocery_list_items.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_grocery_list_items.archived_at IS NULL
  AND meal_plan_grocery_list_items.id = $2
  AND meal_plan_grocery_list_items.belongs_to_meal_plan = $1
`

type GetMealPlanGroceryListItemParams struct {
	BelongsToMealPlan string
	ID                string
}

type GetMealPlanGroceryListItemRow struct {
	CreatedAt                sql.NullTime
	ArchivedAt               sql.NullTime
	LastUpdatedAt            sql.NullTime
	QuantityPurchased        sql.NullString
	MinimumQuantityNeeded    sql.NullString
	MaximumQuantityNeeded    sql.NullString
	ID                       sql.NullString
	PurchasedMeasurementUnit sql.NullString
	PurchasedUpc             sql.NullString
	PurchasePrice            sql.NullString
	StatusExplanation        sql.NullString
	Status                   NullGroceryListItemStatus
	ValidMeasurementUnit     sql.NullString
	ValidIngredient          sql.NullString
	BelongsToMealPlan        sql.NullString
}

func (q *Queries) GetMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *GetMealPlanGroceryListItemParams) (*GetMealPlanGroceryListItemRow, error) {
	row := db.QueryRowContext(ctx, getMealPlanGroceryListItem, arg.BelongsToMealPlan, arg.ID)
	var i GetMealPlanGroceryListItemRow
	err := row.Scan(
		&i.ID,
		&i.BelongsToMealPlan,
		&i.ValidIngredient,
		&i.ValidMeasurementUnit,
		&i.MinimumQuantityNeeded,
		&i.MaximumQuantityNeeded,
		&i.QuantityPurchased,
		&i.PurchasedMeasurementUnit,
		&i.PurchasedUpc,
		&i.PurchasePrice,
		&i.StatusExplanation,
		&i.Status,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
	)
	return &i, err
}

const getMealPlanGroceryListItemsForMealPlan = `-- name: GetMealPlanGroceryListItemsForMealPlan :many

SELECT
	meal_plan_grocery_list_items.id,
	meal_plan_grocery_list_items.belongs_to_meal_plan,
	meal_plan_grocery_list_items.valid_ingredient,
	meal_plan_grocery_list_items.valid_measurement_unit,
	meal_plan_grocery_list_items.minimum_quantity_needed,
	meal_plan_grocery_list_items.maximum_quantity_needed,
	meal_plan_grocery_list_items.quantity_purchased,
	meal_plan_grocery_list_items.purchased_measurement_unit,
	meal_plan_grocery_list_items.purchased_upc,
	meal_plan_grocery_list_items.purchase_price,
	meal_plan_grocery_list_items.status_explanation,
	meal_plan_grocery_list_items.status,
	meal_plan_grocery_list_items.created_at,
	meal_plan_grocery_list_items.last_updated_at,
	meal_plan_grocery_list_items.archived_at
FROM meal_plan_grocery_list_items
	FULL OUTER JOIN meal_plans ON meal_plan_grocery_list_items.belongs_to_meal_plan=meal_plans.id
WHERE meal_plan_grocery_list_items.archived_at IS NULL
  AND meal_plan_grocery_list_items.belongs_to_meal_plan = $1
  AND meal_plans.archived_at IS NULL
  AND meal_plans.id = $1
GROUP BY meal_plan_grocery_list_items.id
ORDER BY meal_plan_grocery_list_items.id
`

type GetMealPlanGroceryListItemsForMealPlanRow struct {
	CreatedAt                sql.NullTime
	ArchivedAt               sql.NullTime
	LastUpdatedAt            sql.NullTime
	QuantityPurchased        sql.NullString
	MinimumQuantityNeeded    sql.NullString
	MaximumQuantityNeeded    sql.NullString
	ID                       sql.NullString
	PurchasedMeasurementUnit sql.NullString
	PurchasedUpc             sql.NullString
	PurchasePrice            sql.NullString
	StatusExplanation        sql.NullString
	Status                   NullGroceryListItemStatus
	ValidMeasurementUnit     sql.NullString
	ValidIngredient          sql.NullString
	BelongsToMealPlan        sql.NullString
}

func (q *Queries) GetMealPlanGroceryListItemsForMealPlan(ctx context.Context, db DBTX, belongsToMealPlan string) ([]*GetMealPlanGroceryListItemsForMealPlanRow, error) {
	rows, err := db.QueryContext(ctx, getMealPlanGroceryListItemsForMealPlan, belongsToMealPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMealPlanGroceryListItemsForMealPlanRow{}
	for rows.Next() {
		var i GetMealPlanGroceryListItemsForMealPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.BelongsToMealPlan,
			&i.ValidIngredient,
			&i.ValidMeasurementUnit,
			&i.MinimumQuantityNeeded,
			&i.MaximumQuantityNeeded,
			&i.QuantityPurchased,
			&i.PurchasedMeasurementUnit,
			&i.PurchasedUpc,
			&i.PurchasePrice,
			&i.StatusExplanation,
			&i.Status,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMealPlanGroceryListItem = `-- name: UpdateMealPlanGroceryListItem :exec

UPDATE meal_plan_grocery_list_items
SET
	belongs_to_meal_plan = $1,
	valid_ingredient = $2,
	valid_measurement_unit = $3,
	minimum_quantity_needed = $4,
	maximum_quantity_needed = $5,
	quantity_purchased = $6,
	purchased_measurement_unit = $7,
	purchased_upc = $8,
	purchase_price = $9,
	status_explanation = $10,
	status = $11,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND id = $12
`

type UpdateMealPlanGroceryListItemParams struct {
	BelongsToMealPlan        string
	ValidIngredient          string
	ValidMeasurementUnit     string
	MinimumQuantityNeeded    string
	StatusExplanation        string
	Status                   GroceryListItemStatus
	ID                       string
	MaximumQuantityNeeded    sql.NullString
	QuantityPurchased        sql.NullString
	PurchasedMeasurementUnit sql.NullString
	PurchasedUpc             sql.NullString
	PurchasePrice            sql.NullString
}

func (q *Queries) UpdateMealPlanGroceryListItem(ctx context.Context, db DBTX, arg *UpdateMealPlanGroceryListItemParams) error {
	_, err := db.ExecContext(ctx, updateMealPlanGroceryListItem,
		arg.BelongsToMealPlan,
		arg.ValidIngredient,
		arg.ValidMeasurementUnit,
		arg.MinimumQuantityNeeded,
		arg.MaximumQuantityNeeded,
		arg.QuantityPurchased,
		arg.PurchasedMeasurementUnit,
		arg.PurchasedUpc,
		arg.PurchasePrice,
		arg.StatusExplanation,
		arg.Status,
		arg.ID,
	)
	return err
}
