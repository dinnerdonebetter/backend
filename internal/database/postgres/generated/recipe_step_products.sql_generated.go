// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: recipe_step_products.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const archiveRecipeStepProduct = `-- name: ArchiveRecipeStepProduct :exec

UPDATE recipe_step_products SET archived_at = NOW() WHERE archived_at IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepProduct(ctx context.Context, db DBTX, arg *ArchiveRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, archiveRecipeStepProduct, arg.BelongsToRecipeStep, arg.ID)
	return err
}

const checkRecipeStepProductExistence = `-- name: CheckRecipeStepProductExistence :one

SELECT EXISTS ( SELECT recipe_step_products.id FROM recipe_step_products JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id WHERE recipe_step_products.archived_at IS NULL AND recipe_step_products.belongs_to_recipe_step = $1 AND recipe_step_products.id = $2 AND recipe_steps.archived_at IS NULL AND recipe_steps.belongs_to_recipe = $3 AND recipe_steps.id = $1 AND recipes.archived_at IS NULL AND recipes.id = $3 )
`

type CheckRecipeStepProductExistenceParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

func (q *Queries) CheckRecipeStepProductExistence(ctx context.Context, db DBTX, arg *CheckRecipeStepProductExistenceParams) (bool, error) {
	row := db.QueryRowContext(ctx, checkRecipeStepProductExistence, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createRecipeStepProduct = `-- name: CreateRecipeStepProduct :exec

INSERT INTO recipe_step_products
(id,"name","type",measurement_unit,minimum_quantity_value,maximum_quantity_value,quantity_notes,compostable,maximum_storage_duration_in_seconds,minimum_storage_temperature_in_celsius,maximum_storage_temperature_in_celsius,storage_instructions,belongs_to_recipe_step,is_liquid,is_waste,"index",contained_in_vessel_index)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
`

type CreateRecipeStepProductParams struct {
	QuantityNotes                      string
	Name                               string
	Type                               RecipeStepProductType
	BelongsToRecipeStep                string
	ID                                 string
	StorageInstructions                string
	MinimumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue               sql.NullString
	MeasurementUnit                    sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Compostable                        bool
	IsLiquid                           bool
	IsWaste                            bool
}

func (q *Queries) CreateRecipeStepProduct(ctx context.Context, db DBTX, arg *CreateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, createRecipeStepProduct,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.BelongsToRecipeStep,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
	)
	return err
}

const getRecipeStepProduct = `-- name: GetRecipeStepProduct :one

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id as valid_measurement_unit_id,
	valid_measurement_units.name as valid_measurement_unit_name,
	valid_measurement_units.description as valid_measurement_unit_description,
	valid_measurement_units.volumetric as valid_measurement_unit_volumetric,
	valid_measurement_units.icon_path as valid_measurement_unit_icon_path,
	valid_measurement_units.universal as valid_measurement_unit_universal,
	valid_measurement_units.metric as valid_measurement_unit_metric,
	valid_measurement_units.imperial as valid_measurement_unit_imperial,
	valid_measurement_units.slug as valid_measurement_unit_slug,
	valid_measurement_units.plural_name as valid_measurement_unit_plural_name,
	valid_measurement_units.created_at as valid_measurement_unit_created_at,
	valid_measurement_units.last_updated_at as valid_measurement_unit_last_updated_at,
	valid_measurement_units.archived_at as valid_measurement_unit_archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_step_products.belongs_to_recipe_step = $1
	AND recipe_step_products.id = $2
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $3
	AND recipe_steps.id = $1
	AND recipes.archived_at IS NULL
	AND recipes.id = $3
`

type GetRecipeStepProductParams struct {
	RecipeStepID        string
	RecipeStepProductID string
	RecipeID            string
}

type GetRecipeStepProductRow struct {
	CreatedAt                          time.Time
	ValidMeasurementUnitCreatedAt      time.Time
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	ValidMeasurementUnitArchivedAt     sql.NullTime
	ValidMeasurementUnitLastUpdatedAt  sql.NullTime
	QuantityNotes                      string
	ValidMeasurementUnitID             string
	ID                                 string
	BelongsToRecipeStep                string
	Name                               string
	ValidMeasurementUnitSlug           string
	ValidMeasurementUnitPluralName     string
	ValidMeasurementUnitDescription    string
	ValidMeasurementUnitName           string
	ValidMeasurementUnitIconPath       string
	StorageInstructions                string
	Type                               RecipeStepProductType
	MaximumQuantityValue               sql.NullString
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	ValidMeasurementUnitVolumetric     sql.NullBool
	ValidMeasurementUnitUniversal      bool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
	ValidMeasurementUnitImperial       bool
	ValidMeasurementUnitMetric         bool
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, db DBTX, arg *GetRecipeStepProductParams) (*GetRecipeStepProductRow, error) {
	row := db.QueryRowContext(ctx, getRecipeStepProduct, arg.RecipeStepID, arg.RecipeStepProductID, arg.RecipeID)
	var i GetRecipeStepProductRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Type,
		&i.ValidMeasurementUnitID,
		&i.ValidMeasurementUnitName,
		&i.ValidMeasurementUnitDescription,
		&i.ValidMeasurementUnitVolumetric,
		&i.ValidMeasurementUnitIconPath,
		&i.ValidMeasurementUnitUniversal,
		&i.ValidMeasurementUnitMetric,
		&i.ValidMeasurementUnitImperial,
		&i.ValidMeasurementUnitSlug,
		&i.ValidMeasurementUnitPluralName,
		&i.ValidMeasurementUnitCreatedAt,
		&i.ValidMeasurementUnitLastUpdatedAt,
		&i.ValidMeasurementUnitArchivedAt,
		&i.MinimumQuantityValue,
		&i.MaximumQuantityValue,
		&i.QuantityNotes,
		&i.Compostable,
		&i.MaximumStorageDurationInSeconds,
		&i.MinimumStorageTemperatureInCelsius,
		&i.MaximumStorageTemperatureInCelsius,
		&i.StorageInstructions,
		&i.IsLiquid,
		&i.IsWaste,
		&i.Index,
		&i.ContainedInVesselIndex,
		&i.CreatedAt,
		&i.LastUpdatedAt,
		&i.ArchivedAt,
		&i.BelongsToRecipeStep,
	)
	return &i, err
}

const getRecipeStepProductsForRecipe = `-- name: GetRecipeStepProductsForRecipe :many

SELECT
	recipe_step_products.id,
	recipe_step_products.name,
	recipe_step_products.type,
	valid_measurement_units.id,
	valid_measurement_units.name,
	valid_measurement_units.description,
	valid_measurement_units.volumetric,
	valid_measurement_units.icon_path,
	valid_measurement_units.universal,
	valid_measurement_units.metric,
	valid_measurement_units.imperial,
	valid_measurement_units.slug,
	valid_measurement_units.plural_name,
	valid_measurement_units.created_at,
	valid_measurement_units.last_updated_at,
	valid_measurement_units.archived_at,
	recipe_step_products.minimum_quantity_value,
	recipe_step_products.maximum_quantity_value,
	recipe_step_products.quantity_notes,
	recipe_step_products.compostable,
	recipe_step_products.maximum_storage_duration_in_seconds,
	recipe_step_products.minimum_storage_temperature_in_celsius,
	recipe_step_products.maximum_storage_temperature_in_celsius,
	recipe_step_products.storage_instructions,
	recipe_step_products.is_liquid,
	recipe_step_products.is_waste,
    recipe_step_products.index,
    recipe_step_products.contained_in_vessel_index,
	recipe_step_products.created_at,
	recipe_step_products.last_updated_at,
	recipe_step_products.archived_at,
	recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
	JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
	JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
	LEFT OUTER JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_at IS NULL
	AND recipe_steps.archived_at IS NULL
	AND recipe_steps.belongs_to_recipe = $1
	AND recipes.archived_at IS NULL
	AND recipes.id = $1
`

type GetRecipeStepProductsForRecipeRow struct {
	CreatedAt_2                        time.Time
	ArchivedAt_2                       sql.NullTime
	ArchivedAt                         sql.NullTime
	LastUpdatedAt                      sql.NullTime
	CreatedAt                          sql.NullTime
	LastUpdatedAt_2                    sql.NullTime
	QuantityNotes                      string
	Name                               string
	ID                                 string
	BelongsToRecipeStep                string
	StorageInstructions                string
	Type                               RecipeStepProductType
	MinimumStorageTemperatureInCelsius sql.NullString
	Name_2                             sql.NullString
	ID_2                               sql.NullString
	Slug                               sql.NullString
	MinimumQuantityValue               sql.NullString
	MaximumQuantityValue               sql.NullString
	IconPath                           sql.NullString
	PluralName                         sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	Description                        sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Universal                          sql.NullBool
	Imperial                           sql.NullBool
	Metric                             sql.NullBool
	Volumetric                         sql.NullBool
	IsWaste                            bool
	IsLiquid                           bool
	Compostable                        bool
}

func (q *Queries) GetRecipeStepProductsForRecipe(ctx context.Context, db DBTX, belongsToRecipe string) ([]*GetRecipeStepProductsForRecipeRow, error) {
	rows, err := db.QueryContext(ctx, getRecipeStepProductsForRecipe, belongsToRecipe)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetRecipeStepProductsForRecipeRow{}
	for rows.Next() {
		var i GetRecipeStepProductsForRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ID_2,
			&i.Name_2,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.Universal,
			&i.Metric,
			&i.Imperial,
			&i.Slug,
			&i.PluralName,
			&i.CreatedAt,
			&i.LastUpdatedAt,
			&i.ArchivedAt,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Compostable,
			&i.MaximumStorageDurationInSeconds,
			&i.MinimumStorageTemperatureInCelsius,
			&i.MaximumStorageTemperatureInCelsius,
			&i.StorageInstructions,
			&i.IsLiquid,
			&i.IsWaste,
			&i.Index,
			&i.ContainedInVesselIndex,
			&i.CreatedAt_2,
			&i.LastUpdatedAt_2,
			&i.ArchivedAt_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRecipeStepProduct = `-- name: UpdateRecipeStepProduct :exec

UPDATE recipe_step_products
SET
	"name" = $1,
	"type" = $2,
	measurement_unit = $3,
	minimum_quantity_value = $4,
	maximum_quantity_value = $5,
	quantity_notes = $6,
	compostable = $7,
	maximum_storage_duration_in_seconds = $8,
	minimum_storage_temperature_in_celsius = $9,
	maximum_storage_temperature_in_celsius = $10,
	storage_instructions = $11,
	is_liquid = $12,
	is_waste = $13,
    "index" = $14,
    contained_in_vessel_index = $15,
	last_updated_at = NOW()
WHERE archived_at IS NULL
	AND belongs_to_recipe_step = $16
	AND id = $17
`

type UpdateRecipeStepProductParams struct {
	Name                               string
	Type                               RecipeStepProductType
	ID                                 string
	BelongsToRecipeStep                string
	StorageInstructions                string
	QuantityNotes                      string
	MinimumStorageTemperatureInCelsius sql.NullString
	MaximumStorageTemperatureInCelsius sql.NullString
	MaximumQuantityValue               sql.NullString
	MinimumQuantityValue               sql.NullString
	MeasurementUnit                    sql.NullString
	MaximumStorageDurationInSeconds    sql.NullInt32
	ContainedInVesselIndex             sql.NullInt32
	Index                              int32
	Compostable                        bool
	IsLiquid                           bool
	IsWaste                            bool
}

func (q *Queries) UpdateRecipeStepProduct(ctx context.Context, db DBTX, arg *UpdateRecipeStepProductParams) error {
	_, err := db.ExecContext(ctx, updateRecipeStepProduct,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.Compostable,
		arg.MaximumStorageDurationInSeconds,
		arg.MinimumStorageTemperatureInCelsius,
		arg.MaximumStorageTemperatureInCelsius,
		arg.StorageInstructions,
		arg.IsLiquid,
		arg.IsWaste,
		arg.Index,
		arg.ContainedInVesselIndex,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}
