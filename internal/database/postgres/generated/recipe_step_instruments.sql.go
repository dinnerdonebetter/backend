// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: recipe_step_instruments.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveRecipeStepInstrument = `-- name: ArchiveRecipeStepInstrument :exec
UPDATE recipe_step_instruments SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepInstrumentParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepInstrument(ctx context.Context, arg *ArchiveRecipeStepInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveRecipeStepInstrument, arg.BelongsToRecipeStep, arg.ID)
	return err
}

const CreateRecipeStepInstrument = `-- name: CreateRecipeStepInstrument :exec
INSERT INTO recipe_step_instruments (id,instrument_id,recipe_step_product_id,name,product_of_recipe_step,notes,preference_rank,belongs_to_recipe_step) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
`

type CreateRecipeStepInstrumentParams struct {
	ID                  string
	InstrumentID        sql.NullString
	RecipeStepProductID sql.NullString
	Name                string
	ProductOfRecipeStep bool
	Notes               string
	PreferenceRank      int32
	BelongsToRecipeStep string
}

func (q *Queries) CreateRecipeStepInstrument(ctx context.Context, arg *CreateRecipeStepInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, CreateRecipeStepInstrument,
		arg.ID,
		arg.InstrumentID,
		arg.RecipeStepProductID,
		arg.Name,
		arg.ProductOfRecipeStep,
		arg.Notes,
		arg.PreferenceRank,
		arg.BelongsToRecipeStep,
	)
	return err
}

const GetRecipeStepInstrument = `-- name: GetRecipeStepInstrument :many
SELECT
	recipe_step_instruments.id,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.variant,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.created_on,
	valid_instruments.last_updated_on,
	valid_instruments.archived_on,
	recipe_step_instruments.recipe_step_product_id,
	recipe_step_instruments.name,
	recipe_step_instruments.product_of_recipe_step,
	recipe_step_instruments.notes,
	recipe_step_instruments.preference_rank,
	recipe_step_instruments.created_on,
	recipe_step_instruments.last_updated_on,
	recipe_step_instruments.archived_on,
	recipe_step_instruments.belongs_to_recipe_step
FROM recipe_step_instruments
LEFT JOIN valid_instruments ON recipe_step_instruments.instrument_id=valid_instruments.id
JOIN recipe_steps ON recipe_step_instruments.belongs_to_recipe_step=recipe_steps.id
JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_instruments.archived_on IS NULL
  AND recipe_step_instruments.belongs_to_recipe_step = $1
  AND recipe_step_instruments.id = $2
  AND recipe_steps.archived_on IS NULL
  AND recipe_steps.belongs_to_recipe = $3
  AND recipe_steps.id = $4
  AND recipes.archived_on IS NULL
  AND recipes.id = $5
`

type GetRecipeStepInstrumentParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepInstrumentRow struct {
	ID                  string
	ID_2                string
	Name                string
	Variant             string
	Description         string
	IconPath            string
	CreatedOn           int64
	LastUpdatedOn       sql.NullInt64
	ArchivedOn          sql.NullInt64
	RecipeStepProductID sql.NullString
	Name_2              string
	ProductOfRecipeStep bool
	Notes               string
	PreferenceRank      int32
	CreatedOn_2         int64
	LastUpdatedOn_2     sql.NullInt64
	ArchivedOn_2        sql.NullInt64
	BelongsToRecipeStep string
}

func (q *Queries) GetRecipeStepInstrument(ctx context.Context, arg *GetRecipeStepInstrumentParams) ([]*GetRecipeStepInstrumentRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRecipeStepInstrument,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecipeStepInstrumentRow
	for rows.Next() {
		var i GetRecipeStepInstrumentRow
		if err := rows.Scan(
			&i.ID,
			&i.ID_2,
			&i.Name,
			&i.Variant,
			&i.Description,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.RecipeStepProductID,
			&i.Name_2,
			&i.ProductOfRecipeStep,
			&i.Notes,
			&i.PreferenceRank,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetRecipeStepInstrumentsForRecipe = `-- name: GetRecipeStepInstrumentsForRecipe :many
SELECT
	recipe_step_instruments.id,
	valid_instruments.id,
	valid_instruments.name,
	valid_instruments.variant,
	valid_instruments.description,
	valid_instruments.icon_path,
	valid_instruments.created_on,
	valid_instruments.last_updated_on,
	valid_instruments.archived_on,
	recipe_step_instruments.recipe_step_product_id,
	recipe_step_instruments.name,
	recipe_step_instruments.product_of_recipe_step,
	recipe_step_instruments.notes,
	recipe_step_instruments.preference_rank,
	recipe_step_instruments.created_on,
	recipe_step_instruments.last_updated_on,
	recipe_step_instruments.archived_on,
	recipe_step_instruments.belongs_to_recipe_step
FROM recipe_step_instruments
LEFT JOIN valid_instruments ON recipe_step_instruments.instrument_id=valid_instruments.id
JOIN recipe_steps ON recipe_step_instruments.belongs_to_recipe_step=recipe_steps.id
JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
WHERE recipe_step_instruments.archived_on IS NULL
AND recipe_steps.archived_on IS NULL
AND recipe_steps.belongs_to_recipe = $1
AND recipes.archived_on IS NULL
AND recipes.id = $2
`

type GetRecipeStepInstrumentsForRecipeParams struct {
	BelongsToRecipe string
	ID              string
}

type GetRecipeStepInstrumentsForRecipeRow struct {
	ID                  string
	ID_2                string
	Name                string
	Variant             string
	Description         string
	IconPath            string
	CreatedOn           int64
	LastUpdatedOn       sql.NullInt64
	ArchivedOn          sql.NullInt64
	RecipeStepProductID sql.NullString
	Name_2              string
	ProductOfRecipeStep bool
	Notes               string
	PreferenceRank      int32
	CreatedOn_2         int64
	LastUpdatedOn_2     sql.NullInt64
	ArchivedOn_2        sql.NullInt64
	BelongsToRecipeStep string
}

func (q *Queries) GetRecipeStepInstrumentsForRecipe(ctx context.Context, arg *GetRecipeStepInstrumentsForRecipeParams) ([]*GetRecipeStepInstrumentsForRecipeRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRecipeStepInstrumentsForRecipe, arg.BelongsToRecipe, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecipeStepInstrumentsForRecipeRow
	for rows.Next() {
		var i GetRecipeStepInstrumentsForRecipeRow
		if err := rows.Scan(
			&i.ID,
			&i.ID_2,
			&i.Name,
			&i.Variant,
			&i.Description,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.RecipeStepProductID,
			&i.Name_2,
			&i.ProductOfRecipeStep,
			&i.Notes,
			&i.PreferenceRank,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTotalRecipeStepInstrumentCount = `-- name: GetTotalRecipeStepInstrumentCount :one
SELECT COUNT(recipe_step_instruments.id) FROM recipe_step_instruments WHERE recipe_step_instruments.archived_on IS NULL
`

func (q *Queries) GetTotalRecipeStepInstrumentCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetTotalRecipeStepInstrumentCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const RecipeStepInstrumentExists = `-- name: RecipeStepInstrumentExists :one
SELECT EXISTS ( SELECT recipe_step_instruments.id FROM recipe_step_instruments JOIN recipe_steps ON recipe_step_instruments.belongs_to_recipe_step=recipe_steps.id JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id WHERE recipe_step_instruments.archived_on IS NULL AND recipe_step_instruments.belongs_to_recipe_step = $1 AND recipe_step_instruments.id = $2 AND recipe_steps.archived_on IS NULL AND recipe_steps.belongs_to_recipe = $3 AND recipe_steps.id = $4 AND recipes.archived_on IS NULL AND recipes.id = $5 )
`

type RecipeStepInstrumentExistsParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

func (q *Queries) RecipeStepInstrumentExists(ctx context.Context, arg *RecipeStepInstrumentExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, RecipeStepInstrumentExists,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const UpdateRecipeStepInstrument = `-- name: UpdateRecipeStepInstrument :exec
UPDATE recipe_step_instruments SET
   instrument_id = $1,
   recipe_step_product_id = $2,
   name = $3,
   product_of_recipe_step = $4,
   notes = $5,
   preference_rank = $6,
   last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL
  AND belongs_to_recipe_step = $7
  AND id = $8
`

type UpdateRecipeStepInstrumentParams struct {
	InstrumentID        sql.NullString
	RecipeStepProductID sql.NullString
	Name                string
	ProductOfRecipeStep bool
	Notes               string
	PreferenceRank      int32
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) UpdateRecipeStepInstrument(ctx context.Context, arg *UpdateRecipeStepInstrumentParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipeStepInstrument,
		arg.InstrumentID,
		arg.RecipeStepProductID,
		arg.Name,
		arg.ProductOfRecipeStep,
		arg.Notes,
		arg.PreferenceRank,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}
