// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveMemberships = `-- name: ArchiveMemberships :exec
UPDATE household_user_memberships SET
	archived_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL
AND belongs_to_user = $1
`

func (q *Queries) ArchiveMemberships(ctx context.Context, belongsToUser string) error {
	_, err := q.db.ExecContext(ctx, ArchiveMemberships, belongsToUser)
	return err
}

const ArchiveUser = `-- name: ArchiveUser :exec
UPDATE users SET
	archived_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL
AND id = $1
`

func (q *Queries) ArchiveUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, ArchiveUser, id)
	return err
}

const CreateHouseholdMembershipForNewUser = `-- name: CreateHouseholdMembershipForNewUser :exec
INSERT INTO household_user_memberships (id,belongs_to_user,belongs_to_household,default_household,household_roles)
	VALUES ($1,$2,$3,$4,$5)
`

type CreateHouseholdMembershipForNewUserParams struct {
	ID                 string
	BelongsToUser      string
	BelongsToHousehold string
	DefaultHousehold   bool
	HouseholdRoles     string
}

func (q *Queries) CreateHouseholdMembershipForNewUser(ctx context.Context, arg *CreateHouseholdMembershipForNewUserParams) error {
	_, err := q.db.ExecContext(ctx, CreateHouseholdMembershipForNewUser,
		arg.ID,
		arg.BelongsToUser,
		arg.BelongsToHousehold,
		arg.DefaultHousehold,
		arg.HouseholdRoles,
	)
	return err
}

const CreateUser = `-- name: CreateUser :exec
INSERT INTO users (id,username,email_address,hashed_password,two_factor_secret,avatar_src,user_account_status,birth_day,birth_month,service_roles) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10)
`

type CreateUserParams struct {
	ID                string
	Username          string
	EmailAddress      string
	HashedPassword    string
	TwoFactorSecret   string
	AvatarSrc         sql.NullString
	UserAccountStatus string
	BirthDay          sql.NullInt16
	BirthMonth        sql.NullInt16
	ServiceRoles      string
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) error {
	_, err := q.db.ExecContext(ctx, CreateUser,
		arg.ID,
		arg.Username,
		arg.EmailAddress,
		arg.HashedPassword,
		arg.TwoFactorSecret,
		arg.AvatarSrc,
		arg.UserAccountStatus,
		arg.BirthDay,
		arg.BirthMonth,
		arg.ServiceRoles,
	)
	return err
}

const GetAdminUserByUsername = `-- name: GetAdminUserByUsername :one
SELECT
    users.id,
    users.username,
    users.email_address,
    users.avatar_src,
    users.hashed_password,
    users.requires_password_change,
    users.password_last_changed_on,
    users.two_factor_secret,
    users.two_factor_secret_verified_on,
    users.service_roles,
    users.user_account_status,
    users.user_account_status_explanation,
    users.birth_day,
    users.birth_month,
    users.created_on,
    users.last_updated_on,
    users.archived_on
FROM users
WHERE users.archived_on IS NULL
AND users.service_roles ILIKE '%service_admin%'
AND users.username = $1
AND users.two_factor_secret_verified_on IS NOT NULL
`

type GetAdminUserByUsernameRow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) GetAdminUserByUsername(ctx context.Context, username string) (*GetAdminUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, GetAdminUserByUsername, username)
	var i GetAdminUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EmailAddress,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedOn,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedOn,
		&i.ServiceRoles,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.BirthDay,
		&i.BirthMonth,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetAllUsersCount = `-- name: GetAllUsersCount :one
SELECT COUNT(users.id) FROM users WHERE users.archived_on IS NULL
`

func (q *Queries) GetAllUsersCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, GetAllUsersCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const GetUserByID = `-- name: GetUserByID :one
	SELECT
		users.id,
		users.username,
		users.email_address,
		users.avatar_src,
		users.hashed_password,
		users.requires_password_change,
		users.password_last_changed_on,
		users.two_factor_secret,
		users.two_factor_secret_verified_on,
		users.service_roles,
		users.user_account_status,
		users.user_account_status_explanation,
		users.birth_day,
		users.birth_month,
		users.created_on,
		users.last_updated_on,
		users.archived_on
	FROM users
	WHERE users.archived_on IS NULL
	AND users.id = $1
`

type GetUserByIDRow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) GetUserByID(ctx context.Context, id string) (*GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EmailAddress,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedOn,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedOn,
		&i.ServiceRoles,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.BirthDay,
		&i.BirthMonth,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetUserByUsername = `-- name: GetUserByUsername :one
SELECT
    users.id,
    users.username,
    users.email_address,
    users.avatar_src,
    users.hashed_password,
    users.requires_password_change,
    users.password_last_changed_on,
    users.two_factor_secret,
    users.two_factor_secret_verified_on,
    users.service_roles,
    users.user_account_status,
    users.user_account_status_explanation,
    users.birth_day,
    users.birth_month,
    users.created_on,
    users.last_updated_on,
    users.archived_on
FROM users
WHERE users.archived_on IS NULL
AND users.username = $1
`

type GetUserByUsernameRow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (*GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EmailAddress,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedOn,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedOn,
		&i.ServiceRoles,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.BirthDay,
		&i.BirthMonth,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetUserIDByEmail = `-- name: GetUserIDByEmail :one
SELECT
    users.id,
    users.username,
    users.email_address,
    users.avatar_src,
    users.hashed_password,
    users.requires_password_change,
    users.password_last_changed_on,
    users.two_factor_secret,
    users.two_factor_secret_verified_on,
    users.service_roles,
    users.user_account_status,
    users.user_account_status_explanation,
    users.birth_day,
    users.birth_month,
    users.created_on,
    users.last_updated_on,
    users.archived_on
FROM users
WHERE users.archived_on IS NULL
AND users.email_address = $1
`

type GetUserIDByEmailRow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) GetUserIDByEmail(ctx context.Context, emailAddress string) (*GetUserIDByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, GetUserIDByEmail, emailAddress)
	var i GetUserIDByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EmailAddress,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedOn,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedOn,
		&i.ServiceRoles,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.BirthDay,
		&i.BirthMonth,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const GetUserWithVerified2FA = `-- name: GetUserWithVerified2FA :one
	SELECT
		users.id,
		users.username,
		users.email_address,
		users.avatar_src,
		users.hashed_password,
		users.requires_password_change,
		users.password_last_changed_on,
		users.two_factor_secret,
		users.two_factor_secret_verified_on,
		users.service_roles,
		users.user_account_status,
		users.user_account_status_explanation,
		users.birth_day,
		users.birth_month,
		users.created_on,
		users.last_updated_on,
		users.archived_on
	FROM users
	WHERE users.archived_on IS NULL
	AND users.id = $1
	AND users.two_factor_secret_verified_on IS NOT NULL
`

type GetUserWithVerified2FARow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) GetUserWithVerified2FA(ctx context.Context, id string) (*GetUserWithVerified2FARow, error) {
	row := q.db.QueryRowContext(ctx, GetUserWithVerified2FA, id)
	var i GetUserWithVerified2FARow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.EmailAddress,
		&i.AvatarSrc,
		&i.HashedPassword,
		&i.RequiresPasswordChange,
		&i.PasswordLastChangedOn,
		&i.TwoFactorSecret,
		&i.TwoFactorSecretVerifiedOn,
		&i.ServiceRoles,
		&i.UserAccountStatus,
		&i.UserAccountStatusExplanation,
		&i.BirthDay,
		&i.BirthMonth,
		&i.CreatedOn,
		&i.LastUpdatedOn,
		&i.ArchivedOn,
	)
	return &i, err
}

const MarkUserTwoFactorSecretAsVerified = `-- name: MarkUserTwoFactorSecretAsVerified :exec
UPDATE users SET
	two_factor_secret_verified_on = extract(epoch FROM NOW()),
	user_account_status = $1
WHERE archived_on IS NULL
AND id = $2
`

type MarkUserTwoFactorSecretAsVerifiedParams struct {
	UserAccountStatus string
	ID                string
}

func (q *Queries) MarkUserTwoFactorSecretAsVerified(ctx context.Context, arg *MarkUserTwoFactorSecretAsVerifiedParams) error {
	_, err := q.db.ExecContext(ctx, MarkUserTwoFactorSecretAsVerified, arg.UserAccountStatus, arg.ID)
	return err
}

const SearchForUserByUsername = `-- name: SearchForUserByUsername :many
SELECT
	users.id,
	users.username,
	users.email_address,
	users.avatar_src,
	users.hashed_password,
	users.requires_password_change,
	users.password_last_changed_on,
	users.two_factor_secret,
	users.two_factor_secret_verified_on,
	users.service_roles,
	users.user_account_status,
	users.user_account_status_explanation,
	users.birth_day,
	users.birth_month,
	users.created_on,
	users.last_updated_on,
	users.archived_on
FROM users
WHERE users.username ILIKE $1
AND users.archived_on IS NULL
AND users.two_factor_secret_verified_on IS NOT NULL
`

type SearchForUserByUsernameRow struct {
	ID                           string
	Username                     string
	EmailAddress                 string
	AvatarSrc                    sql.NullString
	HashedPassword               string
	RequiresPasswordChange       bool
	PasswordLastChangedOn        sql.NullInt32
	TwoFactorSecret              string
	TwoFactorSecretVerifiedOn    sql.NullInt64
	ServiceRoles                 string
	UserAccountStatus            string
	UserAccountStatusExplanation string
	BirthDay                     sql.NullInt16
	BirthMonth                   sql.NullInt16
	CreatedOn                    int64
	LastUpdatedOn                sql.NullInt64
	ArchivedOn                   sql.NullInt64
}

func (q *Queries) SearchForUserByUsername(ctx context.Context, username string) ([]*SearchForUserByUsernameRow, error) {
	rows, err := q.db.QueryContext(ctx, SearchForUserByUsername, username)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchForUserByUsernameRow
	for rows.Next() {
		var i SearchForUserByUsernameRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.EmailAddress,
			&i.AvatarSrc,
			&i.HashedPassword,
			&i.RequiresPasswordChange,
			&i.PasswordLastChangedOn,
			&i.TwoFactorSecret,
			&i.TwoFactorSecretVerifiedOn,
			&i.ServiceRoles,
			&i.UserAccountStatus,
			&i.UserAccountStatusExplanation,
			&i.BirthDay,
			&i.BirthMonth,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUser = `-- name: UpdateUser :exec
UPDATE users SET
	username = $1,
	hashed_password = $2,
	avatar_src = $3,
	two_factor_secret = $4,
	two_factor_secret_verified_on = $5,
	birth_day = $6,
	birth_month = $7,
	last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL
AND id = $8
`

type UpdateUserParams struct {
	Username                  string
	HashedPassword            string
	AvatarSrc                 sql.NullString
	TwoFactorSecret           string
	TwoFactorSecretVerifiedOn sql.NullInt64
	BirthDay                  sql.NullInt16
	BirthMonth                sql.NullInt16
	ID                        string
}

func (q *Queries) UpdateUser(ctx context.Context, arg *UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, UpdateUser,
		arg.Username,
		arg.HashedPassword,
		arg.AvatarSrc,
		arg.TwoFactorSecret,
		arg.TwoFactorSecretVerifiedOn,
		arg.BirthDay,
		arg.BirthMonth,
		arg.ID,
	)
	return err
}

const UpdateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET
	hashed_password = $1,
	requires_password_change = $2,
	password_last_changed_on = extract(epoch FROM NOW()),
	last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL
AND id = $3
`

type UpdateUserPasswordParams struct {
	HashedPassword         string
	RequiresPasswordChange bool
	ID                     string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg *UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, UpdateUserPassword, arg.HashedPassword, arg.RequiresPasswordChange, arg.ID)
	return err
}

const UpdateUserTwoFactorSecret = `-- name: UpdateUserTwoFactorSecret :exec
UPDATE users SET
	two_factor_secret_verified_on = $1,
	two_factor_secret = $2
WHERE archived_on IS NULL
AND id = $3
`

type UpdateUserTwoFactorSecretParams struct {
	TwoFactorSecretVerifiedOn sql.NullInt64
	TwoFactorSecret           string
	ID                        string
}

func (q *Queries) UpdateUserTwoFactorSecret(ctx context.Context, arg *UpdateUserTwoFactorSecretParams) error {
	_, err := q.db.ExecContext(ctx, UpdateUserTwoFactorSecret, arg.TwoFactorSecretVerifiedOn, arg.TwoFactorSecret, arg.ID)
	return err
}

const UserHasStatus = `-- name: UserHasStatus :one
SELECT EXISTS ( SELECT users.id FROM users WHERE users.archived_on IS NULL AND users.id = $1 AND (users.user_account_status = $2 OR users.user_account_status = $3) )
`

type UserHasStatusParams struct {
	ID                  string
	UserAccountStatus   string
	UserAccountStatus_2 string
}

func (q *Queries) UserHasStatus(ctx context.Context, arg *UserHasStatusParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, UserHasStatus, arg.ID, arg.UserAccountStatus, arg.UserAccountStatus_2)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
