// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: recipe_step_products.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveRecipeStepProduct = `-- name: ArchiveRecipeStepProduct :exec
UPDATE recipe_step_products SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepProduct(ctx context.Context, arg *ArchiveRecipeStepProductParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveRecipeStepProduct, arg.BelongsToRecipeStep, arg.ID)
	return err
}

const CreateRecipeStepProduct = `-- name: CreateRecipeStepProduct :exec
INSERT INTO recipe_step_products (id,name,type,measurement_unit,minimum_quantity_value,maximum_quantity_value,quantity_notes,belongs_to_recipe_step) VALUES ($1,$2,$3,$4,$5,$6,$7,$8)
`

type CreateRecipeStepProductParams struct {
	ID                   string
	Name                 string
	Type                 RecipeStepProductType
	MeasurementUnit      sql.NullString
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	QuantityNotes        string
	BelongsToRecipeStep  string
}

func (q *Queries) CreateRecipeStepProduct(ctx context.Context, arg *CreateRecipeStepProductParams) error {
	_, err := q.db.ExecContext(ctx, CreateRecipeStepProduct,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.BelongsToRecipeStep,
	)
	return err
}

const GetRecipeStepProduct = `-- name: GetRecipeStepProduct :many
SELECT
    recipe_step_products.id,
    recipe_step_products.name,
    recipe_step_products.type,
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on,
    recipe_step_products.minimum_quantity_value,
    recipe_step_products.maximum_quantity_value,
    recipe_step_products.quantity_notes,
    recipe_step_products.created_on,
    recipe_step_products.last_updated_on,
    recipe_step_products.archived_on,
    recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
         JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
         JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
         JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_on IS NULL
  AND recipe_step_products.belongs_to_recipe_step = $1
  AND recipe_step_products.id = $2
  AND recipe_steps.archived_on IS NULL
  AND recipe_steps.belongs_to_recipe = $3
  AND recipe_steps.id = $4
  AND recipes.archived_on IS NULL
  AND recipes.id = $5
`

type GetRecipeStepProductParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepProductRow struct {
	ID                   string
	Name                 string
	Type                 RecipeStepProductType
	ID_2                 string
	Name_2               string
	Description          string
	Volumetric           sql.NullBool
	IconPath             string
	CreatedOn            int64
	LastUpdatedOn        sql.NullInt64
	ArchivedOn           sql.NullInt64
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	QuantityNotes        string
	CreatedOn_2          int64
	LastUpdatedOn_2      sql.NullInt64
	ArchivedOn_2         sql.NullInt64
	BelongsToRecipeStep  string
}

func (q *Queries) GetRecipeStepProduct(ctx context.Context, arg *GetRecipeStepProductParams) ([]*GetRecipeStepProductRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRecipeStepProduct,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecipeStepProductRow
	for rows.Next() {
		var i GetRecipeStepProductRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ID_2,
			&i.Name_2,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RecipeStepProductExists = `-- name: RecipeStepProductExists :one
SELECT EXISTS ( SELECT recipe_step_products.id FROM recipe_step_products JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id WHERE recipe_step_products.archived_on IS NULL AND recipe_step_products.belongs_to_recipe_step = $1 AND recipe_step_products.id = $2 AND recipe_steps.archived_on IS NULL AND recipe_steps.belongs_to_recipe = $3 AND recipe_steps.id = $4 AND recipes.archived_on IS NULL AND recipes.id = $5 )
`

type RecipeStepProductExistsParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

func (q *Queries) RecipeStepProductExists(ctx context.Context, arg *RecipeStepProductExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, RecipeStepProductExists,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const RecipeStepProductsForRecipeQuery = `-- name: RecipeStepProductsForRecipeQuery :many
SELECT
    recipe_step_products.id,
    recipe_step_products.name,
    recipe_step_products.type,
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on,
    recipe_step_products.minimum_quantity_value,
    recipe_step_products.maximum_quantity_value,
    recipe_step_products.quantity_notes,
    recipe_step_products.created_on,
    recipe_step_products.last_updated_on,
    recipe_step_products.archived_on,
    recipe_step_products.belongs_to_recipe_step
FROM recipe_step_products
         JOIN recipe_steps ON recipe_step_products.belongs_to_recipe_step=recipe_steps.id
         JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
         LEFT OUTER JOIN valid_measurement_units ON recipe_step_products.measurement_unit=valid_measurement_units.id
WHERE recipe_step_products.archived_on IS NULL
  AND recipe_steps.archived_on IS NULL
  AND recipe_steps.belongs_to_recipe = $1
  AND recipes.archived_on IS NULL
  AND recipes.id = $2
`

type RecipeStepProductsForRecipeQueryParams struct {
	BelongsToRecipe string
	ID              string
}

type RecipeStepProductsForRecipeQueryRow struct {
	ID                   string
	Name                 string
	Type                 RecipeStepProductType
	ID_2                 sql.NullString
	Name_2               sql.NullString
	Description          sql.NullString
	Volumetric           sql.NullBool
	IconPath             sql.NullString
	CreatedOn            sql.NullInt64
	LastUpdatedOn        sql.NullInt64
	ArchivedOn           sql.NullInt64
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	QuantityNotes        string
	CreatedOn_2          int64
	LastUpdatedOn_2      sql.NullInt64
	ArchivedOn_2         sql.NullInt64
	BelongsToRecipeStep  string
}

func (q *Queries) RecipeStepProductsForRecipeQuery(ctx context.Context, arg *RecipeStepProductsForRecipeQueryParams) ([]*RecipeStepProductsForRecipeQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, RecipeStepProductsForRecipeQuery, arg.BelongsToRecipe, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RecipeStepProductsForRecipeQueryRow
	for rows.Next() {
		var i RecipeStepProductsForRecipeQueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Type,
			&i.ID_2,
			&i.Name_2,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const TotalRecipeStepProductCount = `-- name: TotalRecipeStepProductCount :one
SELECT COUNT(recipe_step_products.id) FROM recipe_step_products WHERE recipe_step_products.archived_on IS NULL
`

func (q *Queries) TotalRecipeStepProductCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, TotalRecipeStepProductCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const UpdateRecipeStepProduct = `-- name: UpdateRecipeStepProduct :exec
UPDATE recipe_step_products SET name = $1, type = $2, measurement_unit = $3, minimum_quantity_value = $4, maximum_quantity_value = $5, quantity_notes = $6, last_updated_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_recipe_step = $7 AND id = $8
`

type UpdateRecipeStepProductParams struct {
	Name                 string
	Type                 RecipeStepProductType
	MeasurementUnit      sql.NullString
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	QuantityNotes        string
	BelongsToRecipeStep  string
	ID                   string
}

func (q *Queries) UpdateRecipeStepProduct(ctx context.Context, arg *UpdateRecipeStepProductParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipeStepProduct,
		arg.Name,
		arg.Type,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.QuantityNotes,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}
