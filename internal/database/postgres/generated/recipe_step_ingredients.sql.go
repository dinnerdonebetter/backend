// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: recipe_step_ingredients.sql

package generated

import (
	"context"
	"database/sql"
)

const ArchiveRecipeStepIngredient = `-- name: ArchiveRecipeStepIngredient :exec
UPDATE recipe_step_ingredients SET archived_on = extract(epoch FROM NOW()) WHERE archived_on IS NULL AND belongs_to_recipe_step = $1 AND id = $2
`

type ArchiveRecipeStepIngredientParams struct {
	BelongsToRecipeStep string
	ID                  string
}

func (q *Queries) ArchiveRecipeStepIngredient(ctx context.Context, arg *ArchiveRecipeStepIngredientParams) error {
	_, err := q.db.ExecContext(ctx, ArchiveRecipeStepIngredient, arg.BelongsToRecipeStep, arg.ID)
	return err
}

const CreateRecipeStepIngredient = `-- name: CreateRecipeStepIngredient :exec
INSERT INTO recipe_step_ingredients (
    id,
    name,
    ingredient_id,
    measurement_unit,
    minimum_quantity_value,
    maximum_quantity_value,
    optional,
    quantity_notes,
    product_of_recipe_step,
    recipe_step_product_id,
    ingredient_notes,
    belongs_to_recipe_step
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12)
`

type CreateRecipeStepIngredientParams struct {
	ID                   string
	Name                 string
	IngredientID         sql.NullString
	MeasurementUnit      sql.NullString
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	Optional             bool
	QuantityNotes        string
	ProductOfRecipeStep  bool
	RecipeStepProductID  sql.NullString
	IngredientNotes      string
	BelongsToRecipeStep  string
}

func (q *Queries) CreateRecipeStepIngredient(ctx context.Context, arg *CreateRecipeStepIngredientParams) error {
	_, err := q.db.ExecContext(ctx, CreateRecipeStepIngredient,
		arg.ID,
		arg.Name,
		arg.IngredientID,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.Optional,
		arg.QuantityNotes,
		arg.ProductOfRecipeStep,
		arg.RecipeStepProductID,
		arg.IngredientNotes,
		arg.BelongsToRecipeStep,
	)
	return err
}

const GetRecipeStepIngredient = `-- name: GetRecipeStepIngredient :many
SELECT
    recipe_step_ingredients.id,
    recipe_step_ingredients.name,
    recipe_step_ingredients.ingredient_id,
    valid_measurement_units.id,
    valid_measurement_units.name,
    valid_measurement_units.description,
    valid_measurement_units.volumetric,
    valid_measurement_units.icon_path,
    valid_measurement_units.created_on,
    valid_measurement_units.last_updated_on,
    valid_measurement_units.archived_on,
    recipe_step_ingredients.minimum_quantity_value,
    recipe_step_ingredients.maximum_quantity_value,
    recipe_step_ingredients.quantity_notes,
    recipe_step_ingredients.optional,
    recipe_step_ingredients.product_of_recipe_step,
    recipe_step_ingredients.recipe_step_product_id,
    recipe_step_ingredients.ingredient_notes,
    recipe_step_ingredients.created_on,
    recipe_step_ingredients.last_updated_on,
    recipe_step_ingredients.archived_on,
    recipe_step_ingredients.belongs_to_recipe_step
FROM recipe_step_ingredients
  JOIN recipe_steps ON recipe_step_ingredients.belongs_to_recipe_step=recipe_steps.id
  JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id
  JOIN valid_ingredients ON recipe_step_ingredients.ingredient_id=valid_ingredients.id
  JOIN valid_measurement_units ON recipe_step_ingredients.measurement_unit=valid_measurement_units.id
WHERE recipe_step_ingredients.archived_on IS NULL
  AND recipe_step_ingredients.belongs_to_recipe_step = $1
  AND recipe_step_ingredients.id = $2
  AND recipe_steps.archived_on IS NULL
  AND recipe_steps.belongs_to_recipe = $3
  AND recipe_steps.id = $4
  AND recipes.archived_on IS NULL
  AND recipes.id = $5
`

type GetRecipeStepIngredientParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

type GetRecipeStepIngredientRow struct {
	ID                   string
	Name                 string
	IngredientID         sql.NullString
	ID_2                 string
	Name_2               string
	Description          string
	Volumetric           sql.NullBool
	IconPath             string
	CreatedOn            int64
	LastUpdatedOn        sql.NullInt64
	ArchivedOn           sql.NullInt64
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	QuantityNotes        string
	Optional             bool
	ProductOfRecipeStep  bool
	RecipeStepProductID  sql.NullString
	IngredientNotes      string
	CreatedOn_2          int64
	LastUpdatedOn_2      sql.NullInt64
	ArchivedOn_2         sql.NullInt64
	BelongsToRecipeStep  string
}

func (q *Queries) GetRecipeStepIngredient(ctx context.Context, arg *GetRecipeStepIngredientParams) ([]*GetRecipeStepIngredientRow, error) {
	rows, err := q.db.QueryContext(ctx, GetRecipeStepIngredient,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetRecipeStepIngredientRow
	for rows.Next() {
		var i GetRecipeStepIngredientRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IngredientID,
			&i.ID_2,
			&i.Name_2,
			&i.Description,
			&i.Volumetric,
			&i.IconPath,
			&i.CreatedOn,
			&i.LastUpdatedOn,
			&i.ArchivedOn,
			&i.MinimumQuantityValue,
			&i.MaximumQuantityValue,
			&i.QuantityNotes,
			&i.Optional,
			&i.ProductOfRecipeStep,
			&i.RecipeStepProductID,
			&i.IngredientNotes,
			&i.CreatedOn_2,
			&i.LastUpdatedOn_2,
			&i.ArchivedOn_2,
			&i.BelongsToRecipeStep,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RecipeStepIngredientExists = `-- name: RecipeStepIngredientExists :one
SELECT EXISTS ( SELECT recipe_step_ingredients.id FROM recipe_step_ingredients JOIN recipe_steps ON recipe_step_ingredients.belongs_to_recipe_step=recipe_steps.id JOIN recipes ON recipe_steps.belongs_to_recipe=recipes.id WHERE recipe_step_ingredients.archived_on IS NULL AND recipe_step_ingredients.belongs_to_recipe_step = $1 AND recipe_step_ingredients.id = $2 AND recipe_steps.archived_on IS NULL AND recipe_steps.belongs_to_recipe = $3 AND recipe_steps.id = $4 AND recipes.archived_on IS NULL AND recipes.id = $5 )
`

type RecipeStepIngredientExistsParams struct {
	BelongsToRecipeStep string
	ID                  string
	BelongsToRecipe     string
	ID_2                string
	ID_3                string
}

func (q *Queries) RecipeStepIngredientExists(ctx context.Context, arg *RecipeStepIngredientExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, RecipeStepIngredientExists,
		arg.BelongsToRecipeStep,
		arg.ID,
		arg.BelongsToRecipe,
		arg.ID_2,
		arg.ID_3,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const TotalRecipeStepIngredientCount = `-- name: TotalRecipeStepIngredientCount :one
SELECT COUNT(recipe_step_ingredients.id) FROM recipe_step_ingredients WHERE recipe_step_ingredients.archived_on IS NULL
`

func (q *Queries) TotalRecipeStepIngredientCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, TotalRecipeStepIngredientCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const UpdateRecipeStepIngredient = `-- name: UpdateRecipeStepIngredient :exec

UPDATE recipe_step_ingredients SET
    ingredient_id = $1,
    name = $2,
    measurement_unit = $3,
    minimum_quantity_value = $4,
    maximum_quantity_value = $5,
    optional = $6,
    quantity_notes = $7,
    product_of_recipe_step = $8,
    recipe_step_product_id = $9,
    ingredient_notes = $10,
    last_updated_on = extract(epoch FROM NOW())
WHERE archived_on IS NULL AND belongs_to_recipe_step = $11
  AND id = $12
`

type UpdateRecipeStepIngredientParams struct {
	IngredientID         sql.NullString
	Name                 string
	MeasurementUnit      sql.NullString
	MinimumQuantityValue float64
	MaximumQuantityValue float64
	Optional             bool
	QuantityNotes        string
	ProductOfRecipeStep  bool
	RecipeStepProductID  sql.NullString
	IngredientNotes      string
	BelongsToRecipeStep  string
	ID                   string
}

func (q *Queries) UpdateRecipeStepIngredient(ctx context.Context, arg *UpdateRecipeStepIngredientParams) error {
	_, err := q.db.ExecContext(ctx, UpdateRecipeStepIngredient,
		arg.IngredientID,
		arg.Name,
		arg.MeasurementUnit,
		arg.MinimumQuantityValue,
		arg.MaximumQuantityValue,
		arg.Optional,
		arg.QuantityNotes,
		arg.ProductOfRecipeStep,
		arg.RecipeStepProductID,
		arg.IngredientNotes,
		arg.BelongsToRecipeStep,
		arg.ID,
	)
	return err
}
